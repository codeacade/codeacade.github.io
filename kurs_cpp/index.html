<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl" xml:lang="pl">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Zaawansowane CPP</title>
    <!-- <base href="http://smurf.mimuw.edu.pl" /> -->
    <link type="text/css" rel="stylesheet" href="misc/print.css" />
      </head>
  <body>
        
    <div id="node-1232" class="section-1">
  <h1 class="book-heading">Zaawansowane CPP</h1>
  <h1>Forma zajęć</h1>
<p>Wykład (30 godzin) + laboratorium (30 godzin)</p>
<h1>Opis</h1>
<p>Celem przedmiotu jest zapoznanie studentów z zaawansowanymi technikami programowania obiektowego w C++.</p>
<h1>Sylabus</h1>
<p>Autorzy</p>
<ul>
<li>Piotr Białas - Uniwersytet Jagielloński, Wydział Fizyki, Astronomii i Informatyki Stosowanej,
</li>
<li>Wojciech Palacz - Uniwersytet Jagielloński, Wydział Fizyki, Astronomii i Informatyki Stosowanej,
</li>
</ul>
<h1>Wymagania wstępne</h1>
<ul>
<li>Programowanie Obiektowe
</li>
<li>Znajomość C++
</li>
</ul>
  <div id="node-1233" class="section-2">
  <h1 class="book-heading">Szablony I</h1>
  <h2>Szablony funkcji</h2>
<hr />
<br />
<h3>Funkcje uogólnione</h3>
<br />

<p>W praktyce programowania często spotykamy się z funkcjami
(algorytmami), które można zastosować do szerokiej klasy typów i
struktur danych. Typowym przykładem jest funkcja obliczająca maksimum
dwu wartości. Ten trywialny, aczkolwiek przydatny kod można zapisać np.
w postaci:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span> b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Przykład 1.1
</p>

<p>Funkcja <tt>max</tt> wybiera większy z dwu <tt>int</tt>-ów, ale widać, że kod
będzie identyczny dla argumentów dowolnego innego typu pod warunkiem,
iż istnieje dla niego operator porównania i konstruktor kopiujący. W
językach programowania z silną kontrolą typów, takich jak C, C++ czy
Java definiując funkcję musimy jednak podać typy przekazywanych
parametrów oraz typ wartości zwracanej. Oznacza to, że dla każdego typu
argumentów musimy definiować nową funkcję <tt>max</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span>    max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b<span style="color: #000000;">&#41;</span>      <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">double</span> max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> a,<span style="color: #0000ff;">double</span> b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>;
string max<span style="color: #000000;">&#40;</span>string a,string b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>;
&lt;i&gt;skorzystaliśmy tu z dostępnej w C++ możliwości przeładowywania funkcji&lt;/i&gt;&lt;br /&gt;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  cout&lt;&lt; max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">7</span>,<span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span> &lt;&lt;end;
  cout&lt;&lt; max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.1415</span>,<span style="color: #0000dd;">2.71</span><span style="color: #000000;">&#41;</span> &lt;&lt;endl;
  cout&lt;&lt; max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;Ania&quot;</span>,<span style="color: #666666;">&quot;Basia&quot;</span><span style="color: #000000;">&#41;</span> &lt;&lt;endl;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Przykład 1.2
</p>

<p>Takie powtarzanie kodu, poza oczywistym zwiększeniem nakładu pracy, ma
inne niepożądane efekty, związane z trudnością zapewnienia
synchronizacji kodu każdej z funkcji. Jeśli np. zauważymy błąd w
kodzie, to musimy go poprawić w kilku miejscach. To samo dotyczy
optymalizacji kodu. W powyższym przykładzie kod jest wyjątkowo prosty,
ale taki sam problem dotyczy np. funkcji sortujących. Rozważmy prosty
algorytm sortowania bąbelkowego:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">void</span> swap<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> &amp;a,<span style="color: #0000ff;">double</span> &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">double</span>   tmp=a;a=b;b=tmp;
<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">void</span> buble_sort<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> *data,<span style="color: #0000ff;">int</span> N<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=n<span style="color: #0000dd;">-1</span>;i&gt;<span style="color: #0000dd;">0</span>;--i<span style="color: #000000;">&#41;</span>
        <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> j=<span style="color: #0000dd;">0</span>; j &lt; i;++j<span style="color: #000000;">&#41;</span> 
                <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>j<span style="color: #000000;">&#93;</span>&gt;data<span style="color: #000000;">&#91;</span>j<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>
                        swap<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>j<span style="color: #000000;">&#93;</span>,data<span style="color: #000000;">&#91;</span>j<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Powyższa funkcja sortuje tablicę zawierającą wartości typu <tt>double</tt>,
ale widać, że znów kod będzie identyczny, jeśli zamiast <tt>double</tt>
użyjemy dowolnego innego typu, którego wartości możemy porównywać za
pomocą funkcji <tt>operator>()</tt> i dla którego zdefiniowany jest
operator przypisania. Co więcej, kod nie zmieni się jeśli zamiast
tablicy użyjemy dowolnej innej struktury danych, umożliwiającej
indeksowany dostęp do swoich składowych, np. <tt>std::vector</tt> ze
Standardowej Biblioteki Szablonów STL. W tym przypadku kod jest już
bardziej skomplikowany i kłopoty związane z jego powielaniem będą
większe.  Przykłady takie można mnożyć, istnieje bowiem wiele takich
funkcji czy <i>algorytmów uogólnionych</i>. Ich kod może być znacznie
bardziej skomplikowany niż w podanych przykładach, a zależność od typu
argumentów nie musi ograniczać się do sygnatury, ale występować również
we wnętrzu funkcji, jak np. w przypadku zmiennej <tt>tmp</tt> w funkcji
<tt>swap</tt>.  Powielanie takiego kodu dla różnych typów parametrów może
łatwo prowadzić do błędów, utrudnia ich wykrywanie, a konieczność
edycji każdego egzemplarza kodu zniechęca do wprowadzania ulepszeń.
</p>

<h3>Funkcje uogólnione bez szablonów</h3>

<p>Jak radzili, a właściwie jak radzą sobie programiści bez możliwości
skorzystania z szablonów? 
Tradycyjne sposoby rozwiązywania tego typu problemów to między innymi
makra:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#define max(a,b) ( (a&gt;b)?a:b) )</span></pre></div>
<p>lub używanie wskaźników typów ogólnych, takich jak <tt>void *</tt>,
jak np. w funkcji <tt>qsort</tt> ze standardowej biblioteki C:  
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> <span style="color: #0000dd;">qsort</span> <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> *base, <span style="color: #0000ff;">size_t</span> nmemb, <span style="color: #0000ff;">size_t</span> size,
           <span style="color: #0000ff;">int</span><span style="color: #000000;">&#40;</span>*compar<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span> *, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span> *<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Mimo iż użyteczne, żadne z
tych rozwiązań nie może zostać uznane za wystarczająco ogólne i bezpieczne.
</p><p>Można się również pokusić o próbę rozwiązania tego problemu za pomocą
mechanizmów programowania obiektowego.  W sumie jest to bardziej
wyrafinowana odmiana rzutowania na <tt>void *</tt>.  Polega  na
zdefiniowaniu ogólnego typu dla obiektów, które mogą być porównywane:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> GreaterThanComparable <span style="color: #000000;">&#123;</span> 
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">bool</span> operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> GreaterThanComparable &amp;<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> = <span style="color: #0000dd;">0</span>; 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>następnie zdefiniowaniu funkcji <tt>max</tt> w postaci: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">const</span> GreaterThanComparable &amp;
max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> GreaterThanComparable &amp;a, 
    <span style="color: #0000ff;">const</span> GreaterThanComparable &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
      <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>? a:b; 
    <span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_oop.cpp)
</p><p>i używaniu jej np. w następujący sposób:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> <span style="color: #0000ff;">Int</span>:<span style="color: #0000ff;">public</span> GreaterThanComparable <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">int</span> val;
<span style="color: #0000ff;">public</span>: <span style="color: #0000ff;">Int</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i &lt;nowiki&gt;=&lt;/nowiki&gt; <span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>:val<span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>; 
  operator <span style="color: #0000ff;">int</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> val;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">bool</span> 
  operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> GreaterThanComparable &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> val &gt; static_cast&lt;const Int&amp;&gt;<span style="color: #000000;">&#40;</span>b<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span>;
  <span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">Int</span> a<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>,b<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">Int</span> c;
  c = <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">Int</span> &amp;<span style="color: #000000;">&#41;</span>::<span style="color: #00eeff;">max</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>;
  cout&lt;&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>c&lt;&lt;endl;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_oop.cpp)
</p><p>Widać więc wyraźnie, że to podejście wymaga sporego nakładu pracy, a
więc w szczególności w przypadku tak prostej funkcji jak <tt>max</tt> jest
wysoce niepraktyczne. Ogólnie rzecz biorąc ma ono następujące wady:
</p>

<ol><li> Wymaga dziedziczenia z abstrakcyjnej klasy bazowej <tt>GreaterThanComparable</tt>, czyli może być zastosowane tylko do typów zdefiniowanych przez nas.  Inne typy, w tym typy wbudowane, wymagają kopertowania w klasie opakowującej, takiej jak klasa <tt>Int</tt> w powyższym przykładzie.
</li><li> Ponieważ potrzebujemy polimorfizmu funkcja <tt>operator>()</tt> musi być funkcją wirtualną, a więc musi być funkcją składową klasy i nie może być typu <tt>inline</tt>. W przypadku tak prostych funkcji niemożność rozwinięcia ich w miejscu wywołania może prowadzić do dużych narzutów w czasie wykonania.
</li><li> Funkcja <tt>max</tt> zwraca zawsze referencje do <tt>GreaterThanComparable</tt>, więc konieczne jest rzutowanie na typ wynikowy (tu <tt>Int</tt>).
</li></ol>

<h3>Szablony funkcji</h3>
<br />

<p>Widać, że podejście obiektowe nie nadaje się najlepiej do rozwiązywania
tego szczególnego problemu powielania kodu. Dlatego w C++ wprowadzono
nowy mechanizm: szablony.  Szablony zezwalają na definiowanie całych
rodzin funkcji, które następnie mogą być używane dla różnych typów
argumentów.
</p><p>Definicja szablonu funkcji <tt>max</tt>, odpowiadającej definicji 1.1 wygląda następująco:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>;</pre></div>
<p>( Źródło: max_template.cpp)
</p><p>Przyjrzyjmy się jej z bliska. Wyrażenie <tt>template<typename T></typename></tt>
oznacza, że mamy do czynienia z szablonem, który posiada jeden parametr
formalny nazwany <tt>T</tt>. Słowo kluczowe <tt>typename</tt> oznacza, że
parametr ten jest typem (nazwą typu). Zamiast słowa <tt>typename</tt>
możmy użyć słowa kluczowego <tt>class</tt>.  Nazwa tego parametru może być
następnie wykorzystywana w definicji funkcji w miejscach, gdzie
spodziewamy się nazwy typu. I tak powyższe wyrażenie definiuje funkcję
<tt>max</tt>, która przyjmuje dwa argumenty typu <tt>T</tt> i zwraca wartość
typu <tt>T</tt>, będącą wartością większego z dwu argumentów. Typ <tt>T</tt>
jest na razie niewyspecyfikowany. W tym sensie szablon definiuje całą
rodzinę funkcji. Konkretną funkcję z tej rodziny wybieramy poprzez
podstawienie za formalny parametr <tt>T</tt> konkretnego typu będącego
argumentem szablonu. Takie podstawienie nazywamy konkretyzacją
szablonu. Argument szablonu umieszczamy w nawiasach ostrych za nazwą
szablonu (w praktyce można uniknąć konieczności jawnej specyfikacji
argumentów szablonu, opiszemy to w następnych częściach wykładu):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> i,j,k;
k=max&lt;int&gt;<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>;</pre></div>

<p>Takie użycie szablonu spowoduje wygenerowanie identycznej funkcji jak 1.1. W powyższym przypadku za <tt>T</tt> podstawiamy <tt>int</tt>. Oczywiście możemy podstawić za <tt>T</tt> dowolny typ i używając szablonów program 1.2 można zapisać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">7</span>,<span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.1415</span>,<span style="color: #0000dd;">2.71</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;string&gt;<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;Ania&quot;</span>,<span style="color: #666666;">&quot;Basia&quot;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_template.cpp)
</p><p>W powyższym kodzie użyliśmy konstrukcji <tt>::max(a,b)</tt>. Dwa dwukropki
oznaczają, że używamy funkcji <tt>max</tt> zdefiniowanej w ogólnej
przestrzeni nazw. Jest to konieczne aby kod się skompilował, ponieważ
szablon <tt>max</tt> istnieje już w standardowej przestrzeni nazw
<tt>std</tt>. W dalszej części wykładu będziemy te podwójne dwukropki pomijać.
</p><p>Oczywiście istnieją typy których podstawienie spowoduje błędy
kompilacji, np.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">complex&lt;double&gt; c1,c2;
max&lt;complex&lt;double&gt; &gt;<span style="color: #000000;">&#40;</span>c1,c2<span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//brak operatora &gt;</span></pre></div>

<p>( Źródło: max_template.cpp)
</p><p>lub
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> X <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:
  X<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> X &amp;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
X a,b;
max&lt;X&gt;<span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//prywatny (niewidoczny) konstruktor kopiujący</span></pre></div>
<p>( Źródło: max_template.cpp)
</p><p>Ogólnie rzecz biorąc, każdy szablon definiuje pewną klasę typów, które
mogą zostać podstawione jako jego argumenty.
</p>

<h3>Dedukcja argumentów szablonu</h3>

<p>Użyteczność szablonów funkcji zwiększa istotnie fakt, że argumenty szablonu nie muszą być podawane jawnie. Kompilator może je wydedukować z argumentów funkcji. Tak więc zamiast 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> i,j,k;
k=max&lt;int&gt;<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>;</pre></div>

<p>możemy napisać
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> i,j,k;
k=max<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>;</pre></div>

<p>i kompilator zauważy, że tylko podstawienie <tt>int</tt>-a za <tt>T</tt> umożliwi
dopasowanie sygnatury funkcji do parametrów jej wywołania i
automatycznie dokona odpowiedniej konkretyzacji.
</p><p>Może się zdarzyć, że podamy takie argumenty funkcji, że dopasowanie
argumentów wzorca będzie niemożliwe, otrzymamy wtedy błąd kompilacji.
Trzeba pamiętać, że mechanizm automatycznego dopasowywania argumentów
szablonu powoduje wyłączenie automatycznej konwersji argumentów
funkcji. Podanie jawnie argumentów szablonu (w nawiasach ostrych za
nazwą szablonu) jednoznacznie określa sygnaturę funkcji, a więc
umożliwia automatyczną konwersję typów.  Ilustruje to poniższy kod:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  cout&lt;&lt;::<span style="color: #00eeff;">max</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.14</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
  <span style="color: #ff0000;">// błąd: kompilator nie jest w stanie wydedukowac argumentu szablonu, bo typy </span>
  <span style="color: #ff0000;">// argumentów (double,int) nie pasują  do (T,T)</span>
&nbsp;
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.14</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
  <span style="color: #ff0000;">// podając argument jawnie wymuszamy sygnaturę int max(int,int), a co za tym </span>
  <span style="color: #ff0000;">// idzie automatyczną konwersję argumentu 1 do int-a</span>
&nbsp;
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.14</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
  <span style="color: #ff0000;">// podając argument szablonu jawnie wymuszamy sygnaturę </span>
  <span style="color: #ff0000;">// double max(double,double)</span>
  <span style="color: #ff0000;">// a co za tym idzie automatyczną konwersję argumentu 2 do double-a</span>
&nbsp;
  <span style="color: #0000ff;">int</span> i;
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;int *&gt;<span style="color: #000000;">&#40;</span>&amp;i,i<span style="color: #000000;">&#41;</span>&lt;&lt;endl; 
  <span style="color: #ff0000;">//błąd: nie istnieje konwersja z typu int na int*</span></pre></div>

<p>( Źródło: max_template.cpp)
</p><p>Może warto zauważyć, że automatyczna dedukcja parametrów szablonu jest
możliwa tylko wtedy, jeśli parametry wywołania funkcji w jakiś sposób
zależą od parametrów szablonu. Jeśli tej zależności nie ma, z przyczyn
oczywistych dedukcja nie jest możliwa i trzeba parametry podawać
jawnie. Wtedy istotna jest kolejność parametrów na liście. Jeżeli
parametry, których nie da się wydedukować, umieścimy jako pierwsze,
wystarczy, że tylko je podamy jawnie, a kompilator wydedukuje resztę.
Ilustruje to poniższy kod:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> U&gt; T convert<span style="color: #000000;">&#40;</span>U u<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>T<span style="color: #000000;">&#41;</span>u;
<span style="color: #000000;">&#125;</span>;
template&lt;typename U,<span style="color: #0000ff;">typename</span> T&gt; T inv_convert<span style="color: #000000;">&#40;</span>U u<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>T<span style="color: #000000;">&#41;</span>u;
<span style="color: #000000;">&#125;</span>;
fukcje różnią się tylko kolejnością parametrów szablonu
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
cout&lt;&lt;convert<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">33</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
błąd: kompilator nie jest w stanie wydedukować pierwszego parametru 
szablonu,  bo  nie zależy on od parametru wywołania funkcji
&nbsp;
cout&lt;&lt;convert&lt;char&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">33</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
w porządku: podajemy jawnie argument T, kompilator sam dedukuje 
argument U z typu argumentu wywołania funkcji
&nbsp;
cout&lt;&lt;inv_convert&lt;char&gt;<span style="color: #000000;">&#40;</span><span style="color: #666666;">'a'</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl; 
błąd: podajemy jawnie argument odpowiadający parametrowi U. 
<span style="color: #00eeff;">Kompilator</span> nie jest w stanie wydedukować argumentu T, bo nie zależy on od argumentu 
wywołania funkcji
&nbsp;
cout&lt;&lt;inv_convert&lt;int,char&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">33</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
w porządku: podajemy jawnie oba argumenty szablonu
<span style="color: #000000;">&#125;</span></pre></div>



<p>( Źródło: convert.cpp)
</p>

<h3>Używanie szablonów</h3>

<p>Z użyciem szablonów wiąże się parę zagadnień niewidocznych w prostych
przykładach. W językach C i C++ zwykle rozdzielamy deklarację funkcji
od jej definicji i zwyczajowo umieszczamy deklarację w plikach
nagłówkowych <tt>*.h</tt>, a definicję w plikach źródłowych <tt>*.c</tt>,
<tt>*.cpp</tt> itp. Pliki nagłówkowe są w czasie kompilacji włączane do
plików, w których chcemy korzystać z danej funkcji, a pliki źródłowe są
pojedynczo kompilowane do plików “obiektowych” <tt>*.o</tt>. Następnie
pliki obiektowe są łączone w jeden plik wynikowy (zob. rysunek 1.1). W pliku
korzystającym z danej funkcji nie musimy więc znać jej definicji, a
tylko deklarację.  Na podstawie nazwy funkcji konsolidator powiąże
wywołanie funkcji z jej implementacją znajdującą się w innym pliku
obiektowym. W ten sposób tylko zmiana deklaracji funkcji wymaga
rekompilacji plików, w których z niej korzystamy, a zmiana definicji
wymaga jedynie rekompilacji pliku, w którym dana funkcja jest
zdefiniowana.
</p>

<span class="inline inline-center"><img src="images/Cpp-1-kod1_1.png" alt="Rysunek 1.1. Przykład organizacji kodu C++ w przypadku użycia zwykłych funkcji." title="Rysunek 1.1. Przykład organizacji kodu C++ w przypadku użycia zwykłych funkcji."  class="image image-_original " width="640" height="453" /><span class="caption"><strong>Rysunek 1.1. Przykład organizacji kodu C++ w przypadku użycia zwykłych funkcji.</strong></span></span>


<p>Taka organizacja umożliwia przestrzeganie "reguły jednej definicji"
(one definition rule), wymaganej przez C++. 
Osobom nieobeznanym z programowaniem w C/C++ zwracam uwagę na konstrukcję
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#ifndef _nazwa_pliku_</span>
<span style="color: #339900;">#define _nazwa_pliku_</span>
...
<span style="color: #339900;">#endif</span></pre></div>

<p>uniemożliwiajacą podwójne włączenie tego pliku do jednej jednostki
translacyjnej.
</p><p>Podobne podejście do kompilacje szablonów się nie powiedzie (zob. rysunek 1.2).
Powodem jest fakt, że w trakcie kompilacji pliku <tt>utils.cpp</tt>
kompilator nie wie jeszcze, że potrzebna będzie funkcja <tt>max<int></int></tt>,
wobec czego nie generuje kodu żadnej funkcji, a jedynie sprawdza
poprawność gramatyczną szablonu. Z kolei podczas kompilacji pliku
<tt>main.cpp</tt> kompilator już wie, że ma skonkretyzować szablon dla <tt>T = int</tt>,
ale nie ma dostępu do kodu szablonu.
</p>

<span class="inline inline-center"><img src="images/Cpp-1-kod2.png" alt="Rysunek 1.2. Przykład błędnej organizacji kodu w przypadku użycia szablonów." title="Rysunek 1.2. Przykład błędnej organizacji kodu w przypadku użycia szablonów."  class="image image-_original " width="640" height="416" /><span class="caption"><strong>Rysunek 1.2. Przykład błędnej organizacji kodu w przypadku użycia szablonów.</strong></span></span>


<p>Istnieją różne rozwiązania tego problemu. Najprościej chyba jest
zauważyć, że opisane zachowanie jest analogiczne do zachowania podczas
kompilacji funkcji rozwijanych w miejscu wywołania (<tt>inline</tt>),
których definicja również musi być dostępna w czasie kompilacji.
Podobnie więc jak w tym przypadku możemy zamieścić wszystkie
deklaracje i definicje szablonów w pliknu nagłówkowym, włączanym do
plików, w ktorych z tych szablonów korzystamy (zob. rysunek 1.3). Podobnie
jak w przypadku funkcji <tt>inline</tt> reguła jednej definicji zezwala na
powtarzanie definicji/deklaracji szablonów w różnych jednostkach
translacyjnych, pod warunkiem, że są  one identyczne. Stąd konieczność 
umieszczania ich w plikach nagłówkowych.  
</p>


<span class="inline inline-center"><img src="images/Cpp-1-kod3.png" alt="Rysunek 1.3. Przykład organizacji kodu z szablonami, wykorzystującego strategię włączania." title="Rysunek 1.3. Przykład organizacji kodu z szablonami, wykorzystującego strategię włączania."  class="image image-_original " width="640" height="424" /><span class="caption"><strong>Rysunek 1.3. Przykład organizacji kodu z szablonami, wykorzystującego strategię włączania.</strong></span></span>


<p>Ten sposób organizacji pracy z szablonami, nazywany modelem włączenia,
jest  najbardziej uniwersalny. Jego główną wadą jestkonieczność
rekompilacji całego kodu korzystającego z szablonów przy każdej
zmianie definicji szablonu.  Również jeśli zmienimy coś w pliku, w
którym korzystamy z szablonu, to musimy rekompilować cały kod szablonu
włączony do tego pliku, nawet jeśli nie uległ on zmianie. Jeśli się
uwzględni fakt, że kompilacja szablonu jest bardziej skomplikowana od
kompilacji "zwykłego" kodu, to duży projekt intensywnie korzystający z
szablonów może wymagać bardzo długich czasów kompilacji.
</p><p>Możemy też w jakiś sposób dać znać kompilatorowi, że podczas kompilacji
pliku <tt>utils.cpp</tt> powinien wygenerować kod dla funkcji
<tt>max<int></int></tt>. Można to zrobić dodając jawne żądanie konkretyzacji
szablonu (zob. rysunek 1.4):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">template</span> <span style="color: #0000ff;">int</span> max&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> ,<span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>; &lt;i&gt;konkretyzacja jawna&lt;/i&gt;</pre></div>

<p>Używając konkretyzacji jawnej musimy pamiętać o dokonaniu
konkretyzacji każdej używanej funkcji, tak że to podejście nie
skaluje się zbyt dobrze.  Ponadto w przypadku szablonów klas (omawianych w
następnym module) konkretyzacja jawna pociąga za sobą konkretyzację
wszystkich metod danej klasy, a konkretyzacja “na żądanie” - jedynie
tych używanych w programie.
</p>


<span class="inline inline-center"><img src="images/Cpp-1-kod4_1.png" alt="Rysunek 1.4. Przykład organizacji kodu z szablonami, wykorzystującego jawną konkretyzację." title="Rysunek 1.4. Przykład organizacji kodu z szablonami, wykorzystującego jawną konkretyzację."  class="image image-_original " width="640" height="444" /><span class="caption"><strong>Rysunek 1.4. Przykład organizacji kodu z szablonami, wykorzystującego jawną konkretyzację.</strong></span></span>
<br />

<h2>Pozatypowe parametry szablonów </h2>

<p>Poza parametrami określającymi typ, takimi jak parametr <tt>T</tt> w
dotychczasowych przykładach, szablony funkcji mogą przyjmować również
parametry innego rodzaju. Obecnie mogą to być inne szablony, co omówię w
następnym podrozdziale lub parametry określające nie typ, ale wartości.
Jak na razie (w obecnym standardzie) te wartości nie mogą być dowolne,
ale muszą mieć jeden z poniższych typów:
</p>

<ol><li> typ całkowitoliczbowy bądź typ wyliczeniowy
</li><li> typ wskaźnikowy 
</li><li> typ referencyjny.
</li></ol>

<p>Takie parametry  określające wartość nazywamy parametrami pozatypowymi.
W praktyce z parametrów pozatypowych najczęściej używa się
parametrów typu całkowitoliczbowego. Np.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;size_t N,<span style="color: #0000ff;">typename</span> T&gt; T dot_product<span style="color: #000000;">&#40;</span>T *a,T *b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
        T total=<span style="color: #0000dd;">0.0</span>;
        <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;N;++i<span style="color: #000000;">&#41;</span>
                total += a<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>*b<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span> ;
&nbsp;
<span style="color: #0000ff;">return</span> total;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: dot_product.cpp)
</p><p>Po raz drugi zwracam uwagę na kolejność parametrów szablonu na liście
parametrów. Dzięki temu, że niededukowalny parametr <tt>N</tt> jest na
pierwszym miejscu wystarczy podać jawnie tylko jego, drugi parametr
typu <tt>T</tt> zostanie sam automatycznie wydedukowany na podstawie
przekazanych argumentów wywołania funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#93;</span>,y<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#93;</span>;
dot_product&lt;<span style="color: #0000dd;">3</span>&gt;<span style="color: #000000;">&#40;</span>x,y<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: dot_product.cpp)
</p><p>Parametry pozatypowe są zresztą "ciężko dedukowalne". Właściwie
jedynym sposobem na przekazania wartości stałej poprzez typ argumentu
wywołania jest skorzystanie z parametrów będących szablonami
klas (zob. następny podrozdział). 
</p><p>Używając pozatypowych parametrów szablonów musimy pamiętać, że
odpowiadające im argumenty muszą być stałymi wyrażeniami czasu
kompilacji.  Stąd jeżeli używamy typów wskaźnikowych, muszą to być
wskaźniki do obiektów łączonych zewnętrznie, a nie lokalnych. Ponieważ
jednak jeszcze ani razu nie używałem pozatypowych parametrów szablonów
innych niż typy całkowite, to nie będę podawał żadnych przykładów
takich paremtrów na tym wykładzie.
</p>

<h3>Szablony parametrów szablonu</h3>

<p>Jak już wspomniałem w poprzednim podrozdziale, parametrami szablonu
funkcji mogą być również szablony klas (zob. następny podrozdział).
Szablony parametrów szablonu umożliwiają przekazanie nazwy szablonu
jako argumentu szablonu funkcji. Więcej o nich napiszę w drugiej
części wykładu. Tutaj tylko pokażę jako ciekawostkę w jaki sposób można
dedukować wartości pozatypowych argumentów szablonu.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt; template&lt;int N&gt; <span style="color: #0000ff;">class</span>  C,<span style="color: #0000ff;">int</span> K&gt;
&lt;i&gt;taka definicja oznacza, że parametr C określa szablon klasy 
posiadający jeden parametr typu &lt;tt&gt;int&lt;/tt&gt;. <span style="color: #00eeff;">Parametr</span> N służy tylko 
<span style="color: #0000ff;">do</span> definicji szablonu C i nie może być użyty nigdzie indziej&lt;/i&gt;
<span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span>C&lt;K&gt;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
  cout&lt;&lt;K&lt;&lt;endl;
<span style="color: #000000;">&#125;</span>;&lt;br /&gt;
template&lt;int N&gt; <span style="color: #0000ff;">struct</span> SomeClass <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;&lt;br /&gt;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  SomeClass&lt;<span style="color: #0000dd;">1</span>&gt;  c1;
  SomeClass&lt;<span style="color: #0000dd;">2</span>&gt;  c2;&lt;br /&gt;
  f<span style="color: #000000;">&#40;</span>c1<span style="color: #000000;">&#41;</span>; &lt;i&gt;C=SomeClass K=<span style="color: #0000dd;">1</span>&lt;/i&gt;
  f<span style="color: #000000;">&#40;</span>c2<span style="color: #000000;">&#41;</span>; &lt;i&gt;C=SomeClass K=<span style="color: #0000dd;">2</span>&lt;/i&gt;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: deduce_N.cpp)
</p>

<h3>Szablony metod</h3>

<p>Jak na razie definiowaliśmy szablony zwykłych funkcji. C++ umożliwia
również definiowanie szablonów metod klasy np.:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> Max <span style="color: #000000;">&#123;</span>
  template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  Max m;
  m.<span style="color: #00eeff;">max</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_method.cpp)
</p><p>Szablonów metod składowych dotyczą takie same reguły jak szablonów funkcji.
</p>

<h2>Szablony klas</h2>
<hr />
<br />
<h3>Typy uogólnione</h3>

<p>Uwagi na początku poprzedniego rozdziału odnoszą się w tej samej
mierze do klas, jak i do funkcji. I tutaj mamy do czynienia z kodem,
który w niezmienionej postaci musimy powielać dla różnych typów.
Sztandarowym przykładem takiego kodu są różnego rodzaju kontenery (pojemniki),
czyli obiekty służące do przechowywania innych obiektów. Jest
oczywiste, że kod kontenera jest w dużej mierze niezależny od typu
obiektów w nim przechowywanych. Jako przykład weźmy
sobie stos liczb całkowitych. Możliwa definicja klasy stos może
wyglądać następująco, choć nie polecam jej jako wzoru do naśladowania
w prawdziwych aplikacjach:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:
  <span style="color: #0000ff;">int</span> rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">size_t</span> top;
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">size_t</span> N=<span style="color: #0000dd;">100</span>;
  Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">int</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> rep<span style="color: #000000;">&#91;</span>--top<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>top==<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>


<p>Ewidentnie ten kod będzie identyczny dla stosu obiektów dowolnego
innego typu, pod warunkiem, że typ ten posiada zdefiniowany
<tt>operator=()</tt> i konstruktor kopiujący.
</p><p>W celu zaimplementowania kontenerów bez pomocy szablonów możemy
probować podobnych sztuczek jak te opisane w poprzednim rozdziale. W
językach takich jak Java czy Smalltalk, które posiadają uniwersalną
klasę <tt>Object</tt>, z której są dziedziczone wszystkie inne klasy, a nie
posiadają (Java już posiada) szablonów, uniwersalne kontenery są
implementowane właśnie poprzez rzutowanie na ten ogólny typ.  W
przypadku C++ nawet to rozwiązanie nie jest praktyczne, bo C++ nie
posiada pojedynczej hierarchii klas.
</p>

<h3>Szablony klas</h3>

<p>Rozwiązaniem są znów szablony, tym razem szablony klas. Podobnie jak w
przypadku szablonów funkcji, szablon klasy definiuje nam w
rzeczywistości całą rodzinę klas. Szablon klasy <tt>Stack</tt> możemy zapisać
następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">size_t</span> N=<span style="color: #0000dd;">100</span>;
<span style="color: #0000ff;">private</span>:
  T _rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">size_t</span> _top;&lt;br&gt;
<span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;<span style="color: #000000;">&#125;</span>
  T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>--_top<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>_top==<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span> 
 <span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: stack.cpp)
</p><p>Tak zdefiniowanego szablonu możemy używać podając jawnie jego argumenty.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;string&gt; st ;
st.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;ania&quot;</span><span style="color: #000000;">&#41;</span>;
st.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;asia&quot;</span><span style="color: #000000;">&#41;</span>;
st.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;basia&quot;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>!st.<span style="color: #00eeff;">is_empty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
  cout&lt;&lt;st.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: stack.cpp)
</p><p>Dla szablonów klas nie ma możliwości automatycznej dedukcji argumentów
szablonu, ponieważ klasy nie posiadają argumentów wywołania, które
mogłyby do tej dedukcji posłużyć. Jest natomiast możliwość podania
argumentów domyślnych, np.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = int&gt; Stack <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span></pre></div>



<p>( Źródło: stack.cpp)
</p><p>Wtedy możemy korzystać ze stosu bez podawania argumentów szablonu i
wyrażenie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack s;</pre></div>

<p>będzie równoważne wyrażeniu: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;int&gt; s;</pre></div>

<p>Dla domyślnych argmentów szablonów klas obowiązują te same reguły, co dla
domyślnych argumentów wywołania funkcji. 
</p><p>Należy pamiętać, że każda konkretyzacja szablonu klasy dla 
różniących się zestawów argumentów jest osobną klasą: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;int&gt; si;
Stack&lt;double&gt; sd;
sd=si; <span style="color: #ff0000;">//błąd: to są obiekty różnych klas a nie zdefiniowano przypisania</span></pre></div>

<p>( Źródło: stack.cpp)
</p><p>Okazuje się, że próba zdefiniowania operatora przypisania, który
np. przypisywałby do siebie stosy różnych typów, nie jest łatwa,
ponieważ  dwa takie stosy nie widzą swoich reprezentacji.
</p>

<h3>Pozatypowe parametry szablonów klas</h3>

<p>Zestaw możliwych parametrów szablonów klas jest taki sam jak dla
szablonów funkcji. Podobnie najczęściej wykorzystywane są wyrażenia
całkowitoliczbowe. W naszym przykładzie ze stosem możemy ich użyć do
przekazania rozmiaru stosu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:	
 T rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
 <span style="color: #0000ff;">size_t</span> top;
<span style="color: #0000ff;">public</span>:
 Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;&lt;br /&gt;
 <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;<span style="color: #000000;">&#125;</span>
 T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>          <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> rep<span style="color: #000000;">&#91;</span>--top<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">bool</span> is_empty    <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>top==<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: stack_N.cpp)
</p><p>Podkreślam jeszcze raz, że <tt>Stack<int,100></int,100></tt> i <tt>Stack<int,101></int,101></tt> to
dwie różne klasy.
</p>

<h3>Szablony parametrów szablonu</h3>

<p>Stos jest nie tyle strukturą danych, ile sposobem dostępu do nich.
Stos realizuje regułę LIFO czyli Last In First Out. W tym sensie nie
jest istotne w jaki sposób dane są na stosie przechowywane. Może to
być tablica, jak w powyższych przykładach, ale może to być praktycznie
dowolny inny kontener. Np. w Standardowej Bibliotece Szablonów C++
stos jest zaimplementowany jako
adapter do któregoś z istniejących już kontenerów. Ponieważ kontenery
STL są szablonami, szablon adaptera mógłby wyglądać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,
         template&lt;typename X &gt; <span style="color: #0000ff;">class</span> Sequence=std::<span style="color: #00eeff;">deque</span> &gt; 
<span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
  Sequence&lt;T&gt; _rep;
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep.<span style="color: #00eeff;">push_back</span><span style="color: #000000;">&#40;</span>e<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
  T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>T top=_rep.<span style="color: #00eeff;">top</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;_rep.<span style="color: #00eeff;">pop_back</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;return top;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep.<span style="color: #00eeff;">empty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Konkretyzując stos możemy wybrać kontener, w którym będą przechowywane
jego elementy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;double,std::<span style="color: #00eeff;">vector</span>&gt; sv;</pre></div>

<p>Można zamiast szablonu użyć zwykłego parametru typu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> C &gt; <span style="color: #0000ff;">class</span> stos <span style="color: #000000;">&#123;</span>
  C rep;
  <span style="color: #0000ff;">public</span>:
   ...
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: stack_adapter.cpp)
</p><p>i używać go w następujący sposób:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">stos&lt;double,std::<span style="color: #00eeff;">vector</span>&lt;double&gt; &gt; sv;</pre></div>


<p>W  przypadku użycia szablonu jako parametru szablonu 
zapewniamy konsystencję pomiędzy typem <tt>T</tt> i kontenerem <tt>C</tt>,
uniemożliwiając  pomyłkę podstawienia
niepasujących parametrów:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">stos&lt;double,std::<span style="color: #00eeff;">vector</span>&lt;int&gt; &gt; sv; &lt;i&gt;błąd: niezgodność typow&lt;/i&gt;</pre></div>


<p>Uczciwość nakazuje jednak w tym miejscu stwierdzić, że właśnie takie
rozwiązanie jest zastosowane w STL-u. Ma ono tę zaletę, że możemy
adaptować na stos dowolny kontener, niekoniecznie będący szablonem.
</p><p>Na koniec jeszcze jedna uwaga: szablony kontenerów z STL posiadają po
dwa parametry typów, z tym, że drugi posiada wartość domyślną (standard dopuszcza dowolną ilość argumentów w implemetacji kontenerów STL jak długo będą one posiadały wartości domyślne). Autorzy D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i> ostrzegają, że w tej sytuacji kompilator może nie zaakceptować wyrażenia:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">stos&lt;double,std::<span style="color: #00eeff;">vector</span>&gt; sv;</pre></div>

<p>ponieważ ignoruje fakt istnienia wartości domyślnej dla
drugiego parametru szablonu <tt>std::vector</tt>. 
Mamy wtedy  niezgodność pomiędzy przekazanym argumentem szablonu
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; 
std::<span style="color: #00eeff;">vector</span>&lt;T,<span style="color: #0000ff;">typename</span> A = std::<span style="color: #00eeff;">allocator</span>&lt;T&gt; &gt;;</pre></div>


<p>oraz deklaracją paremetru <tt>Sequence</tt> jako:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename X &gt; <span style="color: #0000ff;">class</span> Sequence ;</pre></div>

<p>która zakłada tylko jeden parametr szablonu.  Można wtedy zmienić
deklarację szablonu <tt>stos</tt> i podać domyślny argument dla szablony w
liście parametrów:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,template&lt;typename X ,<span style="color: #0000ff;">typename</span> A =
std::<span style="color: #00eeff;">allocator</span>&lt;X&gt; &gt; <span style="color: #0000ff;">class</span> C &gt; <span style="color: #0000ff;">class</span> stos <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span></pre></div>

<p>W praktyce używane przeze mnie kompilatory (g++ wersja >= 3.3) nie
wymagały takiej konstrukcji. Przyznaję, że nie udało mi się doczytać czy
jest to cecha kompilatora g++, czy nowego standardu C++ (autorzy D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i> opierali się na poprzednim wydaniu standardu).
</p>


<h3>Konkretyzacja na żądanie</h3>

<p>Jak już wspomniałem wcześniej, konkretyzacja szablonów może odbywać się
"na żądanie". W takim przypadku kompilator będzie konkretyzował
tylko funkcje napotkane w kodzie. I tak, jeśli np. nie użyjemy w naszym
kodzie funckji <tt>Stack<int>::pop()</int></tt>, to nie zostanie ona
wygenerowana. Można z tego skorzystać i konkretyzować klasy typami,
które nie spełniają wszystkich ograniczeń nałożonych na parametry
szablonu. Wszystko bedzię w porządku jak długo nie będziemy używać
funkcji łamiących te ograniczenia. Np. załóżmy, że do szablonu
<tt>Stack</tt> dodajemy możliwość jego sortowania (wiem, to nie jest zgodne z duchem programowania obiektowego, stos nie posiada operacji sortowania, puryści mogą zastąpić ten przykład kontenerem <tt>list</tt>):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N&gt; <span style="color: #0000ff;">void</span> Stack&lt;T,N&gt;::<span style="color: #00eeff;">sort</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
bubble_sort<span style="color: #000000;">&#40;</span>_rep,N<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Możemy teraz np. używać
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;std::<span style="color: #00eeff;">complex</span>&lt;double&gt;&gt; sc;
sc.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span> std::<span style="color: #00eeff;">complex</span>&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
sc.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>ale nie 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">sc.<span style="color: #00eeff;">sort</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>( Źródło: stack_sort.cpp)
</p><p>Natomiast konkretyzacja jawna
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> Stack&lt;std::<span style="color: #00eeff;">complex</span>&lt;double&gt;&gt;;</pre></div>

<p>( Źródło: stack_sort.cpp)
</p><p>nie powiedzie się, bo kompilator będzie się starał skonkretyzować
wszystkie składowe klasy <tt>Stack</tt>, w tym metodę <tt>sort()</tt>.
</p>

<h3>Typy stowarzyszone</h3>
<hr />
<br />

<p>W klasach poza metodami i polami możemy definiować również typy, które
będziemy nazywali stowarzyszonymi z daną klasą. Jest to szczególnie
przydatne w przypadku szablonów. Rozważmy następujący przykład:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
<span style="color: #0000ff;">typedef</span> T value_type;
...
<span style="color: #000000;">&#125;</span></pre></div>

<p>Możemy teraz używać tej definicji w innych szablonach
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename S&gt; <span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span>S s<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typename</span> S::<span style="color: #00eeff;">value_type</span> total; 
    słowo <span style="color: #0000ff;">typename</span> jest wymagane, inaczej kompilator założy, że 
    S::<span style="color: #00eeff;">value_type</span> odnosi się <span style="color: #0000ff;">do</span> statycznej składowej klasy
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>!s.<span style="color: #00eeff;">is_empty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    total+=s.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">return</span> total;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: stack_N.cpp)
</p><p>Bez takich możliwości musielibyśmy przekazać typ elementów stosu w
osobnym argumencie. Mechanizm typów stowarzyszonych jest 
bardzo czesto używany w uogólnionym kodzie.
</p>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_oop.cpp">Max_oop.cpp</a></td><td>620 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_template.cpp">Max_template.cpp</a></td><td>1.2 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Convert.cpp">Convert.cpp</a></td><td>767 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Dot_product.cpp">Dot_product.cpp</a></td><td>414 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Deduce_N.cpp">Deduce_N.cpp</a></td><td>283 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_method.cpp">Max_method.cpp</a></td><td>170 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack.cpp">Stack.cpp</a></td><td>573 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_N.cpp">Stack_N.cpp</a></td><td>842 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_adapter.cpp">Stack_adapter.cpp</a></td><td>501 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_sort.cpp">Stack_sort.cpp</a></td><td>806 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1238" class="section-2">
  <h1 class="book-heading">Programowanie uogólnione</h1>
  <h2>Wprowadzenie</h2>
<hr />
<br />

<p>W poprzednim wykładzie wprowadziłem pojęcia szablonów funkcji i klas.
Są to bardzo ważne konstrukcje języka C++ dające programistom
bezpośrednie, czyli z poziomu języka, wsparcie dla tworzenia
uogólnionych funkcji i typów (nazywanych też funkcjami lub typami
parametryzowanymi). Uogólnienie polega na tym, że za jednym zamachem
definiujemy całe rodziny klas lub funkcji.  Po podstawieniu za
parametry konkretnych argumentów szablonu dostajemy już egzemplarz
"zwykłego" typu (klasy) lub funkcji (nazywane również instancjami
szablonu). Argumenty szablonu mogą reprezentować typy i w ten sposób
dostajemy narzędzie umożliwiające pisanie ogólnego kodu
parametryzowanego typem używanych w nim zmiennych, typem argumentów
wywołania funkcji itp.
</p><p>Szablony okazały się bardzo silnym narzędziem, których zastosowanie
daleko przekracza implementację prostych kontenerów i można spokojnie
stwierdzić, że ich prawdziwy potencjał jest ciągle odkrywany.  Szablony
idealnie wspierają styl programowania nazywany programowaniem
uogólnionym. Polega on na generalizowaniu algorytmów i struktur danych
tak, aby były w dużej mierze niezależne od typów danych, na których
działają lub z których się składają.  Mam nadzieję, że po lekturze
poprzedniego wykładu Państwo już widzą, że to jest właśnie to, do czego
szablony zostały wymyślone. Nie oznacza to, że automatycznie każdy
program używajacy szablonów jest od razu programem uogólnionym. Tak
jak i w przypadku tworzenia zwykłych (bez szablonów) programów, trzeba
się sporo natrudzić, aby uzyskać uniwersalny, łatwy do ponownego
wykorzystania kod. Ten wykład ma właśnie za zadanie przekazać Państwu
podstawowe wiadomości na temat pisania dobrych programów uogólnionych.
</p><p>W programowaniu uogólnionym ważną rolę gra pojęcie konceptu.  Koncept
to asbtrakcyjna definicja rodziny typów. To pojęcie pełni podobną rolę
jak interfejs w programowaniu uogólnionym, ale przynależność do tej
rodziny jest określona proceduralnie: do konceptu należą typy, które
spełniają pewne wymagania. Czyli jeśli coś kwacze jak kaczka to
jest to kaczka, a nie: to jest kaczka jeśli należy do rodziny
"kaczowatych". Koncepty omówię w dalszej części tego wykładu. 
</p><p>Co to jest programowanie uogólnione łatwiej jest pokazać na
przykładach niż opisać.  Niewątpliwie najważniejszą i najbardziej
znaną aplikacją programowania ogólnego jest Standardowa Biblioteka
Szablonów (STL - Standard Template Library), będąca oficjalną częścią
standardu C++. W tych wykladach będę się bardzo często posługiwał
przykładami z STL-a, ale szczegółowe nauczenie posługiwania się tą
biblioteką <b>nie</b> jest celem tego wykładu. Powinni jednak Państwo
zrobić to sami. Dlatego zachęcam do analizy przykładów zamieszczonych
na wykładzie oraz wykonywanie podanych ćwiczeń. 
</p><p>Drugim znakomitycm źródłem przykladów uogólnionego kodu jest
repozytorium bibliotek boost. Stamtąd
też będę podawał przykłady i znów gorąco zachęcam Państwa do
zaglądania tam samemu.
</p><p>Programowanie uogólnione samo w sobie szczególnie obiektowe nie jest,
choć oczywiście wymaga możliwości definiowania własnych typów.  Oba
style programowania: uogólniony i obiektowy można oczywiście stosować
razem. Każdy ma swoje charakterystyczne cechy i aby je  podkreślić
jeszcze raz przypomnę podstawy programowania obiektowego rozumianego
jako programowanie z użyciem interfejsów(klas abstrakcyjnych) i
funkcji wirtulanych.
</p>

<h2>Polimorfizm dynamiczny</h2>
<hr />
<br />

<p>Sercem programowania obiektowego, oczywiście poza koncepcją klasy i
obiektu, jest polimorfizm dynamiczny, czyli możliwość decydowania o tym
jaka funkcja zostanie wywołana pod daną nazwą nie w momencie
kompilacji (czyli pisania kodu), ale w samym momecie wywołania.
Zilustrujemy to na przykładzie. W tym celu skorzystamy z "matki
wszystkich przykładów programowania obiektowego", czyli klasy
kształtów graficznych:).
</p><p>Problem jest następujący: nasz program w pewnym momencie musi
manipulować kształtami graficznym: rysować, przesuwać, obracać itp.
Jest w miarę oczywiste, że każdy kształt będzie posiadał swoją klasę.
Następnym krokiem jest ocena które operacje w naszym kodzie wymagają
szczególowej znajomości kształtu, a które tylko ogólnych jego
własności. Ewidentnie operacja rysowania obiektu należy do tych
pierwszych i musi być zdefiniowana w klasie danego kształtu. Mówimy, że
"obiekt wie jak się narysować". Często mówi się o tym również jako o
ustaleniu odpowiedzialności, czy o podziale obowiązków. Tak więc
ustaliliśmy, że do obowiązków obiektu należy umiejętność narysowania
się. Jeśli tak, to właściwie cała część kodu manipulującego kształtami
nie musi znać szczegółów ich implementacji.  Weźmy na przykład
fragment aplikacji odpowiedzialny za odświeżanie ekranu. Zakładamy, że
wskaźniki do wyświetlanych kształtów są przechowywane w tablicy
<tt>shape_table</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;n;++i<span style="color: #000000;">&#41;</span>
   shape_table<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>-&gt;draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p><font color="red">kod źródłowy</font>

</p><p>Programista piszący ten kod nie musi wiedziec jakiego typu kształt
jest przechowywany w danym elemencie tablicy <tt>shape_table</tt> i jak
jest zaimplementowana funkcja <tt>draw</tt>. Istotne jest by każdy obiekt,
którego wkaźnik przechowywany jest w tej tablicy posiadał metodę
<tt>draw</tt>.  Innymi słowy programista korzysta tu tylko ze znajomości i
dostępności interfejsu obiektów typu kształt, a resztę wykonuje
kompilator, który generuje kod zapewniający wywołanie odpowiedniej
funkcji.  Aby taki interfejs zdefiniować tworzymy abstrakcyjną klasę
obiektów typu kształt:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Shape <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">protected</span>:
  <span style="color: #0000ff;">long</span> <span style="color: #0000ff;">int</span> _x; 
  <span style="color: #0000ff;">long</span> <span style="color: #0000ff;">int</span> _y;
<span style="color: #0000ff;">public</span>:
  Shape<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">long</span> x,<span style="color: #0000ff;">long</span> y<span style="color: #000000;">&#41;</span>:_x<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>,_y<span style="color: #000000;">&#40;</span>y<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">long</span> get_x<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _x;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">long</span> get_y<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _y;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span> draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> = <span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">virtual</span> ~Shape<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło shape.h)
</p><p>Klasa ta stanowić będzie klasę bazową dla wszystkich klas opisujących
kształty. Klasa <tt>Shape</tt> jest klasą abstrakcyjną, ponieważ zawiera
niezaimplementowaną wirtualną  czystą fukcję <tt>void draw()</tt>.
Kod definiujący konkretne klasy kształtów może wyglądać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Rectangle: <span style="color: #0000ff;">public</span> Shape <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">protected</span>:
  <span style="color: #0000ff;">long</span> _ur_x;
  <span style="color: #0000ff;">long</span> _ur_y;
<span style="color: #0000ff;">public</span>:
  Rectangle<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">long</span> ll_x,<span style="color: #0000ff;">long</span> ll_y,<span style="color: #0000ff;">long</span>  ur_x,<span style="color: #0000ff;">long</span> ur_y<span style="color: #000000;">&#41;</span>:
    Shape<span style="color: #000000;">&#40;</span>ll_x,ll_y<span style="color: #000000;">&#41;</span>,_ur_x<span style="color: #000000;">&#40;</span>ur_x-ll_x<span style="color: #000000;">&#41;</span>,_ur_y<span style="color: #000000;">&#40;</span>ur_y-ll_y<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span> draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #666666;">&quot;rectangle : &quot;</span>&lt;&lt;_x&lt;&lt;<span style="color: #666666;">&quot; &quot;</span>&lt;&lt;_y&lt;&lt;<span style="color: #666666;">&quot; : &quot;</span>;
    std::<span style="color: #00eeff;">cerr</span>&lt;&lt;_ur_x+_x&lt;&lt;<span style="color: #666666;">&quot; &quot;</span>&lt;&lt;_ur_y+_y&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">long</span> get_ur_x<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _ur_x;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">long</span> get_ur_y<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _ur_y;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło rectangle.h)
</p><p>i
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Circle: <span style="color: #0000ff;">public</span> Shape <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">protected</span>: 
  <span style="color: #0000ff;">long</span> _r;
 <span style="color: #0000ff;">public</span>:
  Circle<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">long</span> x, <span style="color: #0000ff;">long</span> y,<span style="color: #0000ff;">long</span> r<span style="color: #000000;">&#41;</span> :Shape<span style="color: #000000;">&#40;</span>x,y<span style="color: #000000;">&#41;</span>, _r<span style="color: #000000;">&#40;</span>r<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span> draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #666666;">&quot;Circle : &quot;</span>&lt;&lt;_x&lt;&lt;<span style="color: #666666;">&quot; &quot;</span>&lt;&lt;_y&lt;&lt;<span style="color: #666666;">&quot; : &quot;</span>&lt;&lt;_r&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">long</span> get_r<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _r;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło circle.h)
</p><p>Teraz możemy zdefiniować już  funkcję odświeżającą ekran:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> draw_shapes<span style="color: #000000;">&#40;</span>Shape *table<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;n;++i<span style="color: #000000;">&#41;</span>
    table<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>-&gt;draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło draw.cpp)
</p><p>Funkcja <tt>draw_shapes</tt> wykorzystuje zachowanie polimorficzne: to
która funkcja <tt>draw</tt> zostanie wywołana zależy od tego jaki
konkretny kształt jest wskazywany przez element tablicy. 
Łatwo się o tym przekonać wykonując np. następujący kod
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  Shape *list<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">4</span><span style="color: #000000;">&#93;</span>;
  list<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">new</span> Circle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
  list<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">new</span> Rectangle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">20</span>,<span style="color: #0000dd;">20</span>,<span style="color: #0000dd;">80</span>,<span style="color: #0000dd;">80</span><span style="color: #000000;">&#41;</span>;
  list<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">new</span> Circle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span>,<span style="color: #0000dd;">10</span>,<span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
  list<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">new</span> Rectangle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">20</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">80</span>,<span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>;
  draw_shapes<span style="color: #000000;">&#40;</span>list,<span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p><font color="red">kod źródłowy</font>

</p><p>W ten sposób zaimplementowaliśmy podstawowy paradygmat programowania
obiektowego: rozdzielenie interfejsu od implementacji za pomocą
abstrakcyjnej klasy bazowej i wykorzystanie funkcji wirtualnych.
Ważną częścią tego procesu jest więc właśnie odpowiedni wybór
interfejsów (klas bazowych).
</p>

<h2>Polimorfizm statyczny</h2>
<hr />
<br />

<p>Patrząc na kod funkcji <tt>draw_shapes</tt> możemy zauważyć, że korzysta on
jedynie z własności posiadania przez wskazywane obiekty metody
<tt>draw()</tt>. To sygnatura, czyli typ parametru wywołania tej funkcji
określa, że musi to być wskaźnik na typ <tt>Shape</tt>.  Z poprzedniego
wykładu pamiętamy, że możemy zrezygnować z wymuszania typu argumentu
wywołania funkcji poprzez użycie szablonu funcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">void</span> draw_template<span style="color: #000000;">&#40;</span>T table<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;n;++i<span style="color: #000000;">&#41;</span>
    table<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>.<span style="color: #00eeff;">draw</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło draw_template.h)
</p><p>Taką funkcję możemy wywołać dla dowolnej tablicy, byle tylko
przechowywany typ posiadał metodę <tt>draw</tt>. Mogą to być obiekty typów
<tt>Circle</tt> i <tt>Rectangle</tt> (nie <tt>Shape</tt>, obiekty klasy <tt>Shape</tt>
nie istnieją!),  ale też inne zupełnie z nimi nie związane.
Ilustruje to poniższy przykład:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Drawable <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>cerr&lt;&lt;<span style="color: #666666;">&quot;hello world!&quot;</span>&lt;&lt;endl;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">int</span> main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  Drawable table_d<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span>=<span style="color: #000000;">&#123;</span>Drawable<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#125;</span>;
  Circle   table_c<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span>=<span style="color: #000000;">&#123;</span>Circle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span>,<span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>,Circle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">50</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  draw_template<span style="color: #000000;">&#40;</span>table_d,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
  draw_template<span style="color: #000000;">&#40;</span>table_c,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p><font color="red">kod źródłowy</font>
</p>

<p>Korzystając z szablonów uzyskaliśmy więc również pewien efekt
zachowania polimorficznego. W przeciwieństwie do poprzedniego
przykładu jest to polimorfizm statyczny: to kompilator zadecyduje na
podstawie typu tablicy jaką funkcję <tt>draw</tt> wywołać. Oczywiście w
rozważanym przypadku to podejście jest całkowicie nieadekwatne, mamy
bowiem do czynienia z niejednorodną rodziną kształtów, a wybór
konkretnych kształtów dokunuje się podczas wykonywania programu.
Podając przykład z szablonami chciałem tylko podkreślić różnice
pomiędzy tymi dwoma technikami.  Przykłady kiedy to szablony okazują
się lepszym rozwiązaniem zostały podane w poprzednim wykładzie.
</p>

<h2>Polimorfizm statyczny vs. dynamiczny</h2>
<hr />
<br />

<p>Jak już wspomniałem każdy styl posiada swoje cechy, które w zależności
od okoliczności mogą być postrzegane jako wady lub zalety. Poniżej
podaję zebrane głowne właściwości każdego podejścia.
</p>

<ol><li> Dziedzieczenie i funkcje wirtualne
<ol><li> umożliwia pracę ze zbiorami niejednorodnych obiektów i korzysta z polimorfizmu dynamicznego
</li><li> wymaga wspólnej hierarchii dziedziczenia
</li><li> wymusza korzystanie ze wskaźników lub referencji i funkcji wirtualnych
</li><li> zazwyczaj generuje mniejszy kod.
</li></ol>
</li><li> Szablony
<ol><li> implementuje polimorfizm statyczny
</li><li> bezpiecznie obsługuje jednorodne zbiory obiektów
</li><li> nie trzeba korzystać ze wskaźników i referencji ani funkcji wirtualnych
</li><li> nie musimy korzystać ze wspólnej hierarchii dziedziczenia.
</li></ol>
</li></ol>

<h2>Koncepty</h2>
<hr />
<br />

<p>Przyjrzyjmy się jeszcze raz deklaracji funkcji <tt>draw_shapes</tt> i
<tt>draw_template</tt>. Kiedy programista widzi deklarację:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> draw_shapes<span style="color: #000000;">&#40;</span>Shape *table<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span></pre></div>

<p>wie, że interfejs wykorzystywany przez funkcję <tt>draw</tt> jest
zdefiniowany przez klasę <tt>Shape</tt>. Aby go poznać musi przeczytać kod
i dokumentację tej klasy. 
Natomiast kiedy programista widzi deklarację:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">void</span> draw_template<span style="color: #000000;">&#40;</span>T table<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span>;</pre></div>

<p>to musi prześledzić kod funkcji <tt>draw_templates</tt> aby poznać
ograniczenia nałożone na argument szablonu <tt>T</tt>. W tym przypadku nie
jest to trudne, ale ogólnie może to być nietrywialne zadanie.
</p>

<p>Zamiast jednak definiować ograniczenia i warunki dla każdego szablonu
osobno, możemy szukać wspólnych, powtarzających się zestawów warunków.
Taki zestaw nazwiemy konceptem i będziemy go traktować jako
abstrakcyjną definicję całej rodziny typów, niezależną od konkretnego
szablonu. Typ spełniający warunki konceptu nazywamy modelem konceptu
lub mówimy, że modeluje ten koncept.  Mając wybrany, dobrze
przygotowany zestaw konceptów dla danej dziedziny, możemy się nimi
posługiwać przy definiowaniu typów i algorytmów uogólnionych. 
</p>

<p>Koncepty mogą tworzyć hierachie analogiczne do hierarachii
dziedziecznia. Mówimy, że koncept <tt>A</tt> jest bardziej wyspecjalizowany
niż <tt>B</tt> (<tt>A</tt> is-refinement-of <tt>B</tt>), jeśli zestaw ograniczeń
konceptu <tt>B</tt> zawiera się w zestwie ograniczeń konceptu <tt>A</tt>.
Będę też używał określenia <tt>A</tt> jest "uszczegółowieniem" <tt>B</tt>.  
</p><p>Pojęcie konceptu pełni więc przy programowaniu za pomocą szablonów
podobną rolę jak pojęcie interfejsu przy programowaniu za pomocą
abstrakcyjnych klas bazowych i polimorfizmu dynamicznego. W
przeciwieństwie do interfejsu jest to jednak pojęcie bardziej
"ulotne", bo nie narzucamy go za pomocą formalnej definicji klasy
abstrakcyjnej. Koncepty definiujemy poprzez mniej lub bardziej
ścisłe  wypisanie nakładanych przez nie  ograniczeń. Ograniczenia te
mogą zawierać między  innymi:
</p>

<ol><li> Prawidłowe wyrażenia. Zestaw wyrażeń języka C++, które muszą się poprawnie kompilować.
</li><li> Typy stowarzyszone. Ewentualne dodatkowe typy występujące w prawidłowych wyrażeniach.
</li><li> Semantyka: zanczenie wyrażeń. Jednym ze sposobów określanie semantyki jest podawanie niezmienników, czyli wyrażeń, które dla danego konceptu są zawsze prawdziwe.
</li><li> Złożoność algorytmów. Gwarancje co do czasu i innych zasobów potrzebnych do wykonania danego wyrażenia.
</li></ol>

<p>Programowanie uogólnione polega więc na wyszukiwaniu konceptów na
tyle ogólnych, aby pasowały do dużej liczby typów i na tyle
szczegółowych, aby zezwalały na wydajną implementację. 
</p>

<h3>Definiowanie konceptów</h3>
<hr />
<br />


<p>Weźmy za przykład szablon funkcji <tt>max</tt> z poprzedniego wykładu
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>


<p>i zastanówmy się, jakie koncepty możemy odkryć w tak prostym
kodzie.
</p><p>Zacznijmy od gramatyki.  Jakie warunki musi spełniać typ <tt>T</tt>, aby
podstawienie go jako argument szablonu <tt>max</tt> dawało poprawne
wyrażenie? Oczywistym warunkiem jest, że dla tego typu musi być
zdefiniowany operator porównania <tt>bool operator>(...)</tt>. Specjalnie
nie wyspecyfikowałem sygnatury tego operatora. Nie ma np. znaczenia
jak parametry są przekazywane, co więcej <tt>operator>(...)</tt> może być
zdefiniowany jako składowa klasy i posiadać tylko jeden jawny argument. 
Ważne jest to, że jeśli <tt>x</tt> i <tt>y</tt> są obiektami typu <tt>T</tt>
to wyrażenie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">x&gt;y</pre></div>

<p>jest poprawne (skompiluje się). 
</p><p>Łatwiej jest przeoczyć fakt,
że ponieważ argumenty wywołania są zwracane i przekazywane przez
wartość, to typ <tt>T</tt> musi posiadać konstruktor kopiujący. Oznacza to, że 
jeśli <tt>x</tt> i <tt>y</tt> są obiektami typu <tt>T</tt> to wyrażenia:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
T x<span style="color: #000000;">&#40;</span>y<span style="color: #000000;">&#41;</span>;
T x = y;</pre></div>

<p>są poprawne.
</p><p>Przykład 2.1
</p>


<p>Spełnienie obydwu tych warunków zapewni nam poprawność gramatyczną
wywołania szablonu z danym typem, tzn. kod się skompiluje.
</p><p>A co z poprawnością semantyczną? Mogłoby sie wydawać, że jest bez znaczenia 
jak zdefiniujemy <tt>operator>(...)</tt>. 
Koncept  typu <tt>T</tt> jest jednak częścią kontraktu dla
funkcji <tt>max</tt>. Kontraktu zawieranego pomiędzy twórcą tego wielce
skomplikowanego kodu, a jego użytkownikiem. Kontrakt stanowi, że jeżeli
użytkownik dostarczy do funkcji argumenty o typach zgodnych z
konceptem i o wartościach spełniających być może inne warunki wstępne,
to twórca funkcji gwarantuje, że zwróci ona poprawny wynik.  
</p><p>Zastanówny się więc jak zdefiniować poprawność dla funkcji maksimum. Z
definicji maksimum żaden element argument funkcji <tt>max</tt> nie może być
większy od wyniku, czyli wyrażenie
</p>

<div style="text-align: center">\(!( a> max(a,b) ) \wedge!(b> max(a,b)) \quad\mbox{(2.1)}\)</div>
<p>musi być zawsze prawdziwe.  Jasne jest, że jeśli dla jakiegoś typu
<tt>X</tt> zdefiniujemy operator porównania tak, aby zwracał zawsze prawdę
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">bool</span> operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> X &amp;a,<span style="color: #0000ff;">const</span> X &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">1</span>;<span style="color: #000000;">&#125;</span></pre></div>


<p>lub aby był równoważny operatorowi równości:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">bool</span> operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> X &amp;a,<span style="color: #0000ff;">const</span> X &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> a==b;<span style="color: #000000;">&#125;</span></pre></div>

<p>to wyrażenie 2.1 nie może być prawdziwe dla żadnej
wartości <tt>a</tt> i <tt>b</tt>. Aby funkcja <tt>max</tt> mogła spełnić swój
warunek końcowy musimy narzucić pewne ograniczenia semantyczne na
<tt>operator>()</tt>. Te warunki to żądanie, aby relacja większości
definiowana przez ten operator byłą relacją porządku częściowego, a
więc aby spełnione było
</p>

<div style="text-align: center">\((x>x) = false\) i \((x>y) \wedge (y>z) => (x>z)\)</div>

<p>To rozumowanie możnaby ciągnąć dalej i zauważyć, że nawet z tym
ograniczeniem uzyskamy nieintuicyjne wyniki w przypadku, gdy obiekty
<tt>a</tt> i <tt>b</tt> będą nieporównywalne, tzn. \(!(a>b)\) i \(!(b>a)\).
</p><p>Poprawność semantyczną konstruktora kopiującego jest trudniej
zdefiniować, ograniczymy się więc tylko do stwierdzenia, że wykonanie
operacji 2.1 powoduje powstanie kopii obiektu <tt>x</tt>
(cokolwiek by to nie znaczyło).
</p>

<h3>Comparable i Assignable</h3>
<hr />
<br />

<p>Reasumując, dostajemy zbiór warunków, które musi
spełniać typ <tt>T</tt>, aby móc go podstawić do szablonu funkcji <tt>max</tt>.
Czy to oznacza, że zdefiniowaliśmy już poprawny koncept? Żeby się o tym
przekonać spróbujmy go nazwać. Narzuca się nazwa w stylu
<tt>Comparable</tt>, ale wtedy łatwo zauważyć, że istnienie konstruktora
kopiującego nie ma z tym nic wspólnego. Próbujemy upchnąc dwa
niezależne pojęcia do jednego worka. Co więcej bardzo łatwo jest
zrezygnować z konieczności posiadania konstruktora kopiujacego,
zmieniając deklarację <tt>max</tt> na:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">const</span> T&amp; max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T&amp;,<span style="color: #0000ff;">const</span> T&amp;<span style="color: #000000;">&#41;</span>;</pre></div>

<p>Teraz argumenty i wartość zwracana przekazywane są przez referencję i
nie ma potrzeby kopiowania obiektów. 
</p><p>Logiczne jest więc wydzielenie dwu konceptów: jednego definiującego
typy porównywalne, drugiego - typy "kopiowalne".  Dalej możemy
zauważyć, że istnienie operatora <tt>></tt> automatycznie pozwala na
zdefiniowanie operatora <tt>&lt;</tt> poprzez:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">bool</span> operator&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T&amp; a,<span style="color: #0000ff;">const</span> T&amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> b&gt;a;<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Podobnie istnienie konstruktora kopiującego jest blisko związane z
istnieniem operatora przypisania. 
</p><p>Tak więc dochodzimy do dwu konceptów: <tt>Comparable</tt> reprezentującego
typy, których obiekty można porównywać za pomocą operatorów <tt>&lt;</tt> i
<tt>></tt> oraz <tt>Assignable</tt> reprezentujacego typy, których
obiekty możemy kopiować i przypisywać do siebie.  Taką
zabawę można kontynuować, pytając np. co z operatorem porównania
<tt>operator==()</tt>?, co z konstruktorem defaultowym? itd. Widać więc, że
koncepty to sprawa subietywna, ale to żadna nowość. Wybór używanych
abstrakcji jest zawsze sprawą mniej lub bardziej subiektywną i silnie
zależną od rozpatrywanego problemu. O tym czy dwa pojęcia włączymy do
jednego konceptu czy nie decyduje np. odpowiedź na pytanie czy
prawdopodobne jest użycie kiedykolwiek któregoś z tych pojęć osobno? 
</p><p>Tak więc zanim zaczniemy defniować koncepty musimy ustalić w jakim
kontekście je rozpatrujemy. Na tym wykladzie kontekstem jest STL i oba
wprowadzone koncepty są wzorowane na koncetach z
STL-a.  Należy jednak nadmienić, że pojęcie
konceptu nie pojawia się wprost w definicji stadardu C++. Najlepiej
koncepty STL przedstawione są na stronach firmy SGI dokąd Państwa odsyłam.
</p>


<h2>STL</h2>
<hr />
<br />

<p>Standardowa Biblioteka Szablonów (STL) to doskonałe narzędzie
programistyczne zawarte w standardzie C++.  Stanowi ona również
znakomity, niejako sztandarowy, przykład programowania uogólnionego.
Na tę bibliotekę można patrzeć więc dwojako: jako rozszerzenie języka
C++ o dodatkowe funkcje lub jako na zbiór konceptów stanowiących
podstawę do projetowania programów uogólnionych. Ja chciałbym
podkreślić tutaj ten drugi aspekt, podkreślając jednak, że dobre poznanie
możliwości STL-a może bardzo ułatwić Państwu prace programistyczne.
</p><p>Biblioteka składa się zasadniczo z dwu części: uogólnionych kontenerów 
i uogólnionych algorytmów. Trzecią cześcią, niejako sklejającą te dwie, są 
iteratory. 
</p><p>Kontenery to obiekty służące do przechowywania innych obiektów.
Kontenery w STL są jednorodne, tzn. mogą przechowywać tylko zbiory
(kolekcje) obiektów tego samego typu. Kluczem do efektywnego
programowania uogólnionego jest jednak sprawa ujednolicenia dostępu do
zawartości kontenera. Rozważmy dla przykładu dwa typowe kontenery
<tt>vector</tt> i <tt>list</tt>, implementujące odpowiednio "inteligentną"
tablicę oraz listę dwukierunkową. Naturalnym sposobem dostępu do
tablicy jest indeksowanie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">vector</span>&lt;int&gt; v<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>;
v<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">8</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">1</span>;</pre></div>

<p>a listy przeglądamy po kolei, przesuwając się o jeden element w przód czy w tył
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Uwaga! To nie jest kod STL-owy !!!
lista&lt;int&gt; l;
l.<span style="color: #00eeff;">reset</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; ustawia element bieżacy na początek listy
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;<span style="color: #0000dd;">8</span>;i++<span style="color: #000000;">&#41;</span>
     l.<span style="color: #00eeff;">next</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; przesuwa element bieżący o jeden element <span style="color: #0000ff;">do</span> przodu
&nbsp;
l.<span style="color: #00eeff;">current</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>=<span style="color: #0000dd;">1</span>; zwraca referencję <span style="color: #0000ff;">do</span> elementu bieżącego</pre></div>

<p>Widać, że w takim sformułowaniu praktycznie nie jest możliwe napisanie
ogólnego kodu np. dodającego wszystkie elementy kontenera czy
wyszukującego jakiś element w kontenerze. Ponadto opisany sposób
dostępu do listy ogranicza nas do korzystania z jednego bieżącego
elementu na raz. 
</p><p>Rozwiązaniem tego problemu zastosowanym w STL jest koncept iteratora,
który definiuje abstrakcyjny interfejs dostępu do elementów kontenera.
W STL iterator posiada semantykę wskaźnika, w szczególności może być
zwykłym wskaźnikiem, choć normalnie jest to wskaźnik inteligentny.
Każdy kontener posiada zestaw funkcji zwracających iteratory do
swojego początku i na swój koniec.  Korzystając z nich można listę
przeglądać następująco
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">list</span>&lt;int&gt; l;
tu jakoś inicjalizujemy liste
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>list&lt;int&gt;::<span style="color: #00eeff;">iterator</span> it=l.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;it!=l.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;it++<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
     każdy kontener definiuje typ stowarzyszony nazwany iterator
  cout&lt;&lt;*it&lt;&lt;endl;
     korzystamy z iteratorów jak ze zwykłych wskaźników
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>

<p>Przykładowy ogólny algorytm oparty o iteratory może wyglądać w ten sposób:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator, <span style="color: #0000ff;">class</span> T&gt;
T accumulate<span style="color: #000000;">&#40;</span>InputIterator first, InputIterator last, T init<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
T total=init;
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>;; first;!= last;++first<span style="color: #000000;">&#41;</span> 
   total+= *first;
<span style="color: #0000ff;">return</span> total;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: accumulate.cpp)
</p><p>Oczywiście nie da się zignorować fundamentalnych różnic pomiędzy listą
a wektorem. Dlatego np. iterator wektora zezwala na konstrukcje
<tt>it[i]</tt>, a iterator listy już nie. Oznacza to, że algorytm, który
działa dla iteratorów wektora (np. <tt>sort</tt>), nie musi działać dla
iteratora listy. W języku konceptów oznacza to, że
<tt>std::vector<T>::iterator</t></tt> jest modelem konceptu bardziej
wyspecjalizowanego niż koncept, którego modelem jest
<tt>std::list<T>::iterator</t></tt>. Zobaczymy to w następnej części tego
wykładu.
</p>

<h3>Kontenery</h3>
<hr />
<br />

<p>Standard C++  definiuje dwa zestawy kontenerów wchodzące w skład STL:
</p>

<ol><li>Sekwencje czyli pojemniki, w których kolejność elementów jest ustalana przez korzystającego z pojemnika (klienta) są to: 
<ol><li> <tt>vector</tt>
</li><li> <tt>deque</tt>
</li><li> <tt>list</tt>
</li></ol>
</li><li> Kontenery asocjacyjne, czyli pojemniki, w których klient nie ma kontroli nad kolejnością elementów, są to:
<ol><li> <tt>set</tt>
</li><li> <tt>map</tt>
</li><li> <tt>multiset</tt>
</li><li> <tt>multimap</tt>
</li></ol>
</li></ol>

<p>Ponadto różni dostawcy oferują dodatkowe pojemniki. Na uwagę zasługuje
znakomita darmowa implementacja STL firmy Silicon Graphics, która
miedy innymi wchodzi w skład pakietu g++ i dostarcza dodatkowo takich
kontenerów jak: lista jednokierunkowa <tt>slist</tt> oraz tablice
haszujące <tt>hash_set</tt> czy <tt>hash_map</tt> (zob. STL). Hierachię
konceptów kontenerów typu sekwencji przedstawia rysunek 2.1, a kontenerów asocjacyjnych rysunek 2.2.
</p>

<span class="inline inline-center"><img src="images/Cpp-2-1.png" alt="Rysunek 2.1. Hierarchia konceptów dla pojemników typu sekwencyjnego." title="Rysunek 2.1. Hierarchia konceptów dla pojemników typu sekwencyjnego."  class="image image-_original " width="592" height="391" /><span class="caption"><strong>Rysunek 2.1. Hierarchia konceptów dla pojemników typu sekwencyjnego.</strong></span></span>
<br />


<span class="inline inline-center"><img src="images/Cpp-2-2.png" alt="Rysunek 2.2. Hierarchia konceptów dla pojemników typu asocjacyjnego." title="Rysunek 2.2. Hierarchia konceptów dla pojemników typu asocjacyjnego."  class="image image-_original " width="599" height="395" /><span class="caption"><strong>Rysunek 2.2. Hierarchia konceptów dla pojemników typu asocjacyjnego.</strong></span></span>

<p>Nie będę tu omawiał tych wszystkich konceptów. Ich szczegółowe opisy
znajdują się na stronie <a href="http://www.sgi.com/tech/stl/" title="http://www.sgi.com/tech/stl/">http://www.sgi.com/tech/stl/</a>. Tutaj chciałbym tylko dodać parę luźnych
komentarzy.
</p><p>Po pierwsze, rodzi się pytanie czy taka skomplikowana taksonomia jest
potrzebna?  W końcu patrząc na rysunki widać, że konceptów jest dużo
więcej niż typów kontenerów. Rzeczywiście, do posługiwania się biblioteką
w zasadzie wystarczy zaznajomić się z opisami kontenerów i hierarchią
iteratorów (zob. rysunek 2.3).  Podane klasyfikacje przydają się dopiero kiedy dodajemy własne elementy do biblioteki.
Dobierając do implemetacji najbardziej ogólny koncept spełniający
nasze wymagania zwiększamy potencjał ponownego użycia naszego kodu z
innymi komponentami biblioteki, czy kodem innych developerów.
</p><p>Kontenery z STL są właścicielami swoich elementów, zniszczenie
kontenera powoduje zniszczenie jego elementów.  Wszytkie operacje
wkładania elementów do kontenera używają przekazywania przez wartość,
czyli kopiują wkładany obiekt. Jeżeli chcemy, aby czas życia elementów
kontenera był dłuższy od czasu życia kontenera, należy użyć wskaźników. 
</p><p>Kontenery różnią się nie tylko rodzajem iteratorów, jaki implementują,
ale również rodzajem operacji, które można wykonać bez unieważnienia
istniejących iteratorów. Pokażę to na przykładzie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">vector</span>&lt;int&gt;::<span style="color: #00eeff;">iterator</span> it;
<span style="color: #0000ff;">int</span> i;
&nbsp;
std::<span style="color: #00eeff;">vector</span>&lt;int&gt; v<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
std::<span style="color: #00eeff;">vector</span>&lt;int&gt; buff<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>; staramy się zająć pamięć za v
&nbsp;
v<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">0</span>;
it=v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
i=<span style="color: #000000;">&#40;</span>*it<span style="color: #000000;">&#41;</span>; OK, przypisuje i=<span style="color: #0000dd;">0</span>
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;<span style="color: #0000dd;">10</span>;++i<span style="color: #000000;">&#41;</span>
  v.<span style="color: #00eeff;">push_back</span><span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&#41;</span>;   
    ponieważ przekraczamy koniec wektora, kontener zaalokuje dodatkową pamięć. <span style="color: #00eeff;">Mo</span>że
    się to wiązać z koniecznośćią przeniesienia zawartości wektora v w inne miejsce 
    pamięci. <span style="color: #00eeff;">To</span> spowoduje, że wskaźnik it przestanie pokazywać na początek wektora v
&nbsp;
std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #000000;">&#40;</span>*it<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span> ;                  niezdefiniowane
&nbsp;
std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #666666;">&quot;iterator nieprawidlowy&quot;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>; 
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>;it != v.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; ++it<span style="color: #000000;">&#41;</span>  potencjalnie nieskończona pętla  
  std::<span style="color: #00eeff;">cerr</span>&lt;&lt;*it&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
;
&nbsp;
std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #666666;">&quot;iterator prawidlowy&quot;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>; 
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>it=v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;it != v.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; ++it<span style="color: #000000;">&#41;</span>  
std::<span style="color: #00eeff;">cerr</span>&lt;&lt;*it&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
;</pre></div>

<p>( Źródło: invalid.cpp)
</p><p>Bardzo Państwa na ten problem uczulam. Efekt działania powyższego kodu
jest gorzej niż zły: jest niezdefiniowany!, tzn. będzie zależał od
implementacji kompilatora, od zadeklarownych wcześniej zmiennych itp.
Proszę np. spróbować wykomentować linijkę
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">vector</span>&lt;int&gt; buff<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>; staramy się zająć pamięć za v</pre></div>


<p>i porównać wynik działania programu.  Może się również zdarzyć, że
program zadziała poprawnie (wbrew pozorom jest to najgorsza
możliwa sytuacja!).
</p><p>Ważne są gwarancje złożoności metod kontenera.  Ewidentnie każdy
rodzaj kontenera może dostarczyć każdego rodzaju operacji, różny
będzie jednak czas ich wykonywania. I tak rząd O(1) jest gwarantowany w operacji indeksowania
wektora. Natomiast operacja dodania
elementu w środku wektora jest rzędu O(N). Z listą jest odwrotnie i
dlatego listy w STL nie posiadają operacji indeksowania. 
</p><p>Nie wszystkie własności kontenerów są zdefiniowane w konceptach.
Każdy kontener może definiować dodatkowe metody właściwe tylko
dla niego.
</p>

<h3>Iteratory</h3>
<hr />
<br />


<p>Iteratory to koncept, który uogólnia pojęcie wskaźnika. 
Hierarchię konceptów iteratorów przedstawia rysunek 2.3. Zaznaczono na nim również które 
koncepty kontenerów wymagają danego modelu iteratora.
</p>

<span class="inline inline-center"><img src="images/Cpp-2-3.png" alt="Rysunek 2.3. Hierarchia konceptów dla iteratorów." title="Rysunek 2.3. Hierarchia konceptów dla iteratorów."  class="image image-_original " width="596" height="396" /><span class="caption"><strong>Rysunek 2.3. Hierarchia konceptów dla iteratorów.</strong></span></span>
<br />

<p>Najprostsze iteratory pojawiające sie w STL-u to iteratory wejściowe i
wyjściowe. Wprawdzie żaden kontener nie posiada iteratorów tego typu,
ale iteratory wejściowe, umożliwiające tylko jednoprzebiegowe
odczytanie wartości kontenera, są częstym wymaganiem dla argumentów
algorytmów nie zmieniających elementów kontenera (non mutable
algorithms).
</p><p>Należy pamiętać, że iterator nie wie na jaki kontener wskazuje, czyli
poprzez iterator nie ma dostępu do interfejsu kontenera.
</p><p>Iteratory pozwalają na określanie zakresu elementów w kontenerze poprzez
podanie iteratora wskazującego na początek i na pierwszy element poza
końcem zakresu.  Zakres oznaczamy poprzez (<tt>it1</tt>,<tt>it2</tt>) (zob. rysunek 2.4).  
</p>

<span class="inline inline-center"><img src="images/Cpp-2-4_1.png" alt="Rysunek 2.4. Zakres." title="Rysunek 2.4. Zakres."  class="image image-_original " width="498" height="195" /><span class="caption"><strong>Rysunek 2.4. Zakres.</strong></span></span><br />


<p>Z tego powodu dozwolona jest instrukcja
pobrania adresu pierwszego elementu poza końcem tablicy.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#93;</span>;
<span style="color: #0000ff;">double</span> *end=&amp;x<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#93;</span>;
<span style="color: #ff0000;">//zwykłe wskażniki mogą być użyte jako iteratory</span>
std::<span style="color: #00eeff;">cout</span>&lt;&lt;accumulate<span style="color: #000000;">&#40;</span>x,end,<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl; &lt;i&gt;suma elementów tablicy&lt;/i&gt;</pre></div>

<p>Każdy kontener posiada motody <tt>begin()</tt> i <tt>end()</tt>, zwracające
iterator na początek i "poza koniec". Typowa pętla obsługi kontenera
wygląda więc następująco:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">typedef</span> vector&lt;int&gt;::<span style="color: #00eeff;">iterator</span> iterator;
vector&lt;it&gt; v<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>iterator it=v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;it!=v.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;++it<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 ...
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: accumulate.cpp)
</p><p>Proszę zwrócić uwagę na wykorzystanie operatora <tt>!=</tt> do sprawdzenia
końca zakresu. Tylko iteratory o dostępie swobodnym mogą być
porównywane za pomocą operatora <tt>operator&lt;()</tt>. Reszta jest tylko
<tt>EqualityComparable</tt>.
</p>


<h3>Algorytmy</h3>
<hr />
<br />

<p>Algorytmy działają na zakresach elementów kontenera definiowanych
przez dwa iteratory, a nie na kontenerach. Umożliwia to jednolity
dostęp do różnych kontenerów.  Takie podejście ma też inne
konsekwencje, jak już pisałem iterator nie wie z jakiego kontenera
pochodzi, w szczególności oznacza to, że algorytmy ogólne nie mogą
usuwać elementów z kontenera. 
</p><p>Oczywiście część algorytmów, np.
<tt>sort</tt>, wymaga bardziej wyrafinowanych iteratorów, nie dostarczanych
przez każdy kontener.  Wiele jednak jednoprzebiegowych algorytmów
zadawala się iteratorami wejściowymi. 
</p><p>Poza iteratorami uogólnione algorytmy wykorzystują obiekty funkcyjne
czyli funktory. Obiekt funkcyjny to koncept będący uogólnieniem
pojęcia fukcji, czyli coś do czego można zastosować składnię
wywołania funkcji. W C++ mogą to być funkcje, wskaźniki do funkcji
oraz obiekty klas, w których zdefiniowano <tt>operator()(...)</tt> .
</p><p>Funktory w STL są podzielone ze względu na liczbę argumentów wywołania.
<tt>Generator</tt> nie przyjmuje żadnego argumentu, <tt>UnaryFunction</tt>
posiada jeden argument, a <tt>BinaryFunction</tt> - dwa argumenty wywołania.
Ważną podklasą są funkcje zwracające wartość typu <tt>bool</tt>, nazywane
predykatami. Rozróżniamy więc  <tt>UnaryPredicate</tt> i
<tt>BinaryPredicate</tt>.
</p><p>Żeby zilustrować użycie algorytmów i funktorów rozważmy następujący
przykład.  Najpierw definiujemy funktor, który posłuży nam do
generowania sekwencji obiektów:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> SequenceGen <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:
  T _start; 
  T _step;
<span style="color: #0000ff;">public</span>:
  SequenceGen<span style="color: #000000;">&#40;</span>T start = T<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,T step = <span style="color: #0000dd;">1</span> <span style="color: #000000;">&#41;</span>:
  _start<span style="color: #000000;">&#40;</span>start<span style="color: #000000;">&#41;</span>,_step<span style="color: #000000;">&#40;</span>step<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  T operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>T tmp=_start; _start+=_step; <span style="color: #0000ff;">return</span> tmp;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: bind.cpp)
</p><p>Za pomocą obiektu klasy <tt>SequenceGen</tt> możemy wypełnić wektor
sekwencją 20 pierwszych nieparzystych liczb całkowitych:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">size_t</span> n = <span style="color: #0000dd;">20</span> ;
vector&lt;int&gt; v<span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span>;
generate_n<span style="color: #000000;">&#40;</span>v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,n,SequenceGen&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>( Źródło: bind.cpp)
</p><p>Standardowy algorytm
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class OutputIterator, <span style="color: #0000ff;">class</span> Size, <span style="color: #0000ff;">class</span> Generator&gt;
OutputIterator generate_n<span style="color: #000000;">&#40;</span>OutputIterator first, 
                          Size n, Generator gen<span style="color: #000000;">&#41;</span>;</pre></div>


<p>służy właśnie do wypełniania kontenerów za pomocą <tt>n</tt> kolejnych
wyników wywołania funktora <tt>gen</tt>.  Powyższy kod ilustruje typowy
sposób opisu algorytmów w STL. Nazwy parametrów szablonu odpowiadają
nazwom konceptów, które muszą modelować.  
</p><p>W tak wypełnionym kontenerze
poszukamy pierwszego elementu większego od czterech (powinno to być
pięć). Służy do tego algorytm 
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;class InputIterator, <span style="color: #0000ff;">class</span> Predicate&gt;
InputIterator find_if<span style="color: #000000;">&#40;</span>InputIterator first, 
                      InputIterator last,
                      Predicate pred<span style="color: #000000;">&#41;</span>;</pre></div>


<p>Który przeszukuje zakres <tt>[first,last)</tt> do napotkania pierwszego
elementu, dla którego predykat <tt>pred</tt> jest prawdziwy i zwraca
iterator do tego elementu. Jeśli takiego elementu nie ma, to
<tt>find_if</tt> zwraca <tt>last</tt>. Do zakończenia programu potrzebujemy
jeszcze predykatu, który testuje czy dana wartość jest większa od
czterech. Zamiast go implementować skorzystamy z adaptera funkcji
<tt>bind2nd</tt>.  Ta funkcja przyjmuje funktor dwuargumentowy
(<tt>AdaptableBinaryFunction</tt>) <tt>F(T,U)</tt> i jakąś wartość <tt>x</tt> typu
<tt>U</tt> i zwraca funktor jednoparametrowy <tt>F(T,x)</tt>. Korzystając z
predefiniowanego predykatu <tt>greater</tt> możemy napisać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">vector&lt;int&gt;::<span style="color: #00eeff;">iterator</span> it= find_if<span style="color: #000000;">&#40;</span>v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,v.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,
                                  bind2nd<span style="color: #000000;">&#40;</span>greater&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>it!=v.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>
  cout&lt;&lt;*it&lt;&lt;endl;
<span style="color: #0000ff;">else</span>
  cout&lt;&lt;<span style="color: #666666;">&quot;nie znaleziono zadanego elementu&quot;</span>;
<span style="color: #000000;">&#125;</span></pre></div>



<p>( Źródło: bind.cpp)
</p><p>STL wprowadza więc do C++ elementy programowania funkcyjnego.
</p>

<h2>Debugowanie</h2>
<hr />
<br />

<h3>Sprawdzanie konceptów</h3>

<p>Programowanie uogólnione korzysta istotnie z pojęcia konceptu. Koncept
opisuje abstrakcyjne typy danych (czy funkcji), które mogą być użyte
jako argumenty danego szablonu. Definiowanie konceptu polega tylko na
jego opisie. C++ nie posiada żadnego mechanizmu pozwalającego na
bardziej formalną definicję. Co za tym idzie, nie  można
też automatycznie sprawdzać czy nasz typ modeluje żądany koncept.
</p><p>Oczywiście kompilator podczas konkretyzacji szablonu sprawdza
syntaktyczną zgodność przekazanego typu z wymaganiami szablonu. Nie
jest to jednak idealne narzędzie diagnostyczne. Po pierwsze, komunikat
o błedzie może być bardzo zawiły i na pewno nie będzie się odnosił do
nazwy konceptu. Po drugie, może się okazać, że szablon, który
konkretyzujemy nie wykorzystuje wszystkich możliwych wyrażeń konceptu.
Zresztą idea konceptu polega na rozdzieleniu definicji abstrakcyjnego
typu od definicji szablonu, którego ten typ może być argumentem.
Rozwiazaniem jest napisanie własnego zestawu szablonów, których
jedynem zadaniem jest sprawdzanie zgodności przekazanych argumentów
szablonu z definiowanym przez ten szablon konceptem. Niestety, można w
ten sposób sprawdzać tylko zgodność syntaktyczną. 
</p><p>Idea tworzenia takich szablonów jest prosta (zob. <a href="http://www.boost.org/libs/concept_check/concept_check.htm" title="http://www.boost.org/libs/concept_check/concept_check.htm">http://www.boost.org/libs/concept_check/concept_check.htm</a>): dla każdego
konceptu tworzymy szablon zawierający funkcję <tt>constraints()</tt>, która
zawiera wszystkie możliwe poprawne wyrażenia dla danego konceptu. Np.
dla konceptu <tt>Comparable</tt> możemy zdefiniować:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> ComparableConcept <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">void</span> constraints<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  require_boolean_expr<span style="color: #000000;">&#40;</span> a &gt; b<span style="color: #000000;">&#41;</span>;
  require_boolean_expr<span style="color: #000000;">&#40;</span> a &lt; b<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;
T a,b; 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: concept_check.cpp)
</p><p>Szablon <tt>require_boolean_expr</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class TT&gt;
 <span style="color: #0000ff;">void</span> require_boolean_expr<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> TT&amp; t<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   <span style="color: #0000ff;">bool</span> x = t;
   ignore_unused_variable_warning<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
   używa zmiennej x aby kompilator nie generował ostrzeżenia
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: concept_check.cpp)
</p><p>sprawdza czy jego argument, a więc wartość zwracana przez operatory,
może być konwertowana na <tt>bool</tt>.
</p><p>Zwracam uwagę, że nie możemy w kodzie szablonu <tt>Comparable</tt> użyć
defaultowego konstruktora, bo nie jest on wymagany.  Dlatego zmienne
<tt>a</tt> i <tt>b</tt> nie były zdefiniowane wewnątrz funkcji
<tt>constraints()</tt>, tylko jako pola składowe klasy. Ponieważ nie
tworzymy żadnej instancji tej klasy, to nie będą wywoływane
konstruktory, a więc kompilator nie będzie generował ich kodu. 
</p><p>Teraz potrzebujemy jeszcze sposobu, aby skompilować, ale nie wywołać,
funkcję <tt>ComparableConcept<T>::constraints()</t></tt>. Możemy
tego dokonać pobierając adres funkcji i przypisując go do wskaźnika.
Kompilator skompiluje kod funkcji, ale jej nie wykona. Dodatkowo
najprawdopodobniej kompilator optymalizujący usunie to przypisanie
jako nieużywany kod, ale dopiero po kompilacji (no chyba, że jest
bardzo, ale to bardzo inteligentny). Dla wygody opakujemy tę
konstrukcję w szablon funkcji:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class Concept&gt;
<span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">void</span> function_requires<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>Concept::<span style="color: #00eeff;">*x</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> = &amp;Concept::<span style="color: #00eeff;">constraints</span>;
  ignore_unused_variable_warning<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: concept_check.cpp)
</p><p>Możemy teraz używać szablonu <tt>Comparable</tt> w następujący sposób:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 function_requires&lt;ComparableConcept&lt;int&gt; &gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
 function_requires&lt;ComparableConcept&lt;std::<span style="color: #00eeff;">complex</span>&gt; &gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; błąd
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: concept_check.cpp)
</p><p>Bardziej skomplikowane koncepty możemy sprawdzać korzystając z 
klas sprawdzających dla innych konceptów, np:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class Container&gt;
<span style="color: #0000ff;">struct</span> Mutable_ContainerConcept
<span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Container::<span style="color: #00eeff;">value_type</span> value_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Container::<span style="color: #00eeff;">reference</span> reference;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Container::<span style="color: #00eeff;">iterator</span> iterator;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Container::<span style="color: #00eeff;">pointer</span> pointer;
&nbsp;
  <span style="color: #0000ff;">void</span> constraints<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    sprawdzamy czy spełnia wymagania konceptu Container
    function_requires&lt; ContainerConcept&lt;Container&gt; &gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    function_requires&lt; AssignableConcept&lt;value_type&gt; &gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    function_requires&lt; InputIteratorConcept&lt;iterator&gt; &gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
    i = c.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    i = c.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    c.<span style="color: #00eeff;">swap</span><span style="color: #000000;">&#40;</span>c2<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  iterator i;
  Container c, c2;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Biblioteka <tt>boost</tt>, skąd wzięty został ten przykład, posiada
implementację szablonów dla każdego konceptu z
STL (<a href="http://www.boost.org/libs/concept_check/concept_check.htm" title="http://www.boost.org/libs/concept_check/concept_check.htm">http://www.boost.org/libs/concept_check/concept_check.htm</a>). Hierachia, którą
można tam odczytać, różni się trochę od tej, którą wcześniej
zaprezentowałem i która jest opisana w <a href="http://www.sgi.com/tech/stl/" title="http://www.sgi.com/tech/stl/">http://www.sgi.com/tech/stl/</a>. Główna
różnica to wprowadzenie rozróżnienia pomiędzy kontenerami, które
umożliwiaja modyfikację swoich elementów (<tt>MutableContainer</tt>) i tych,
które na to nie pozwalają (<tt>Container</tt>).
</p>


<h3>Archeotypy</h3>
<hr />

<p>Klasy sprawdzające koncepty służą do pomocy w implementacji typów
będących modelami danego konceptu. Możemy jednak mieć sytuację
odwrotną: implementujemy jakiś algorytm ogólny i chcemy się dowiedzieć
jaki koncept jest wymagany dla parametrów szablonu? Chcemy wybrać jak
najogólniejszy koncept, który jeszcze pozwala na poprawne działanie
algorytmu. Pomóc mogą nam w tym archeotypy. Są to klasy, które
dokładnie implementują interfejs danego konceptu. Opierając się na
<a href="http://www.boost.org/libs/concept_check/concept_check.htm" title="http://www.boost.org/libs/concept_check/concept_check.htm">http://www.boost.org/libs/concept_check/concept_check.htm</a>, przedstawię teraz
implementację archeotypu dla konceptu <tt>Comparable</tt>.
</p><p>Koncept
<tt>Comparable</tt> nie wymaga posiadania konstruktora defaultowego,
konstruktora kopiujacego oraz operatora przypisania, dlatego w naszym
archeotypie zdefiniujemy je jako prywatne:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> comparable_archetype <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:
  comparable_archetype<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  comparable_archetype<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> comparable_archetype &amp;<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  comparable_archetype &amp;operator=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> comparable_archetype &amp;<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> *<span style="color: #0000dd;">this</span>;<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">public</span>:
  comparable_archetype<span style="color: #000000;">&#40;</span>dummy_argument<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: archeotype.cpp)
</p><p>Aby móc tworzyć obiekty typu <tt>comparable_archetype</tt> dodaliśmy
niestandardowy konstruktor z argumentem sztucznego typu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> dummy_argument <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>


<p>używanego tylko na tę okazję (jego nazwa powinna być unikatowa).
</p><p>Operator <tt>operator&lt;()</tt> nie musi zwracać wartości typu <tt>bool</tt>, a
jedynie wartość typu konwertowalnego na <tt>bool</tt>, dlatego tworzymy taki typ:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> boolean_archetype  <span style="color: #000000;">&#123;</span>
  operator <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>i podajemy go jako typ zwracany przez operatory porównania
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">boolean_archetype operator&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> comparable_archetype &amp;,
                            <span style="color: #0000ff;">const</span> comparable_archetype &amp;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> boolean_archetype<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;
boolean_archetype  operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> comparable_archetype &amp;,
                             <span style="color: #0000ff;">const</span> comparable_archetype &amp;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> boolean_archetype<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: archeotype.cpp)
</p><p>Teraz możemy już przetestować nasz szablon <tt>max</tt>.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; 
<span style="color: #0000ff;">const</span> T &amp;max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;a,<span style="color: #0000ff;">const</span> T &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
comparable_archetype ca<span style="color: #000000;">&#40;</span>dummy_argument<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; 
max<span style="color: #000000;">&#40;</span>ca,ca<span style="color: #000000;">&#41;</span>; 
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: archeotype.cpp)
</p><p>Poprawna kompilacja tego kodu przekonuje nas, że koncept
<tt>Comparable</tt> jest wystarczajacy, przynajmniej syntaktycznie. Proszę
zwrócić uwagę, że jeśli użyjemy orginalnego szablonu
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>



<p>( Źródło: archeotype.cpp)
</p><p>to kod się nie skompiluje, bo zabraknie konstruktora kopiujacego. 
</p><p>Większość konceptów jest uszczegółowieniem innych konceptów.
Implementacja archeotypów w biblitece boost zezwala na takie
konstrukcje i gorąco zachęcam do zapoznania się z nią.
</p>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Shape.h">Shape.h</a></td><td>463 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Rectangle.h">Rectangle.h</a></td><td>510 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Circle.h">Circle.h</a></td><td>374 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Draw.cpp">Draw.cpp</a></td><td>119 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Draw_template.h">Draw_template.h</a></td><td>310 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Accumulate.cpp">Accumulate.cpp</a></td><td>891 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Invalid.cpp">Invalid.cpp</a></td><td>974 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Bind.cpp">Bind.cpp</a></td><td>518 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Concept_check.cpp">Concept_check.cpp</a></td><td>742 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Archeotype.cpp">Archeotype.cpp</a></td><td>990 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1239" class="section-2">
  <h1 class="book-heading">Szablony II</h1>
  <h2>Wprowadzenie</h2>
<hr />
<br />

<p>Mechanizm szablonów jest bardzo użyteczny ale może się okazać, że kod
ogólny, który szablon implementuje, nie nadaje się do stosowania w
każdym przypadku. W tej sytuacji mamy do dyspozycji dodatkowe
własności implementacji szablonów w C++: przeciążanie i specjalizację.
W poniższym wykładzie omówię sposób stosowania tych mechanizmów i
różnice pomiędzy nimi.
</p>

<h2>Przeciążanie szablonów funkcji</h2>
<hr />
<br />

<p>Przeciążenie szablonu funkcji, podobnie jak przeciążenie zwykłych
funkcji, definiuje nam nowy szablon. Możemy za pomocą przeciążenia
zdefiniować np. funkcję służącą do znajdywania maksymalnego
elementu w tablicy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T *data,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  T _max = data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;n;i++<span style="color: #000000;">&#41;</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>&gt;_max<span style="color: #000000;">&#41;</span> _max=data<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">return</span> _max;
<span style="color: #000000;">&#125;</span></pre></div>


<p>Oba szablony: powyższy i wcześniej zdefiniowany
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Przykład 3.1
</p>


<p>mogą ze sobą współistnieć i kompilator automatycznie wybierze poprawną
definicję na podstawie argumentów wywołania funkcji. Oczywiście w obu
przypadkach zadziała mechanizm automatycznej dedukcji argumentu szablonu.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> i,j,k;
<span style="color: #0000ff;">double</span> x,t<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">20</span><span style="color: #000000;">&#93;</span>;
k=max<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//wywołanie max(int,int)</span>
x=max<span style="color: #000000;">&#40;</span>t,k<span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//wywołanie max&lt;double&gt;(double *,int)</span></pre></div>

<p>( Źródło: max_overload.cpp)
</p><p>Możemy jednak chcieć nie tyle zdefiniować nową funkcję, ile zmienić
kod już istniejącego szablonu,  tak aby dla pewnego podzbioru
parametrów  działał inaczej.  Np. działanie funkcji <tt>max</tt>
dla dwu wskaźników nie koniecznie jest tym, czego byśmy sobie życzyli.
Możemy się spodziewać, że w tej sytuacji funkcja powinna zwrócić
wskaźnik do większej wartości, a nie wskaźnik o wyższym adresie.
Definiujemy więc nowy przeciążony szablon funkcji <tt>max</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T* max<span style="color: #000000;">&#40;</span>T *a, T *b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #000000;">&#40;</span>*a<span style="color: #000000;">&#41;</span>&gt;<span style="color: #000000;">&#40;</span>*b<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span></pre></div>
<p>( Źródło: max_overload.cpp)
</p>

<p>Przykład 3.2
</p>

<p>Teraz sytuacja nie jest już jednoznaczna. Kompilator, napotykając wyrażenie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> i,j;
max<span style="color: #000000;">&#40;</span>&amp;i,&amp;j<span style="color: #000000;">&#41;</span>;</pre></div>


<p>może dopasować zarówno oryginalny szablon 3.1 z <tt>T = int*</tt>
lub szablon 3.2 z <tt>T = int</tt>. I choć wydaje się że,
otrzymamy błąd kompilacji, to do głosu dochodzi mechanizm rozstrzygania
przeciążenia i kompilator wybierze dopasowanie drugiego szablonu jako
“bardziej wyspecjalizowanego”, tzn. do którego pasuje mniejszy zbiór
argumentów.  Ewidentnie algorytm rozstrzygania przeciążenia szablonów
funkcji nie jest prosty, polega on na częściowym porządkowaniu
przeciążonych funkcji według stopnia ich specjalizacji. Dokładny opis
tego algorytmu można znaleźć w D. Vandervoorde, N. Josuttis <i>"C++ Szablony. Vademecum profesjonalisty"</i>, rozdz. 12. Z grubsza
rzecz biorąc szablon funkcji <tt>F</tt> jest bardziej wyspecjalizowany niż
szablon <tt>G</tt> jeśli każdy zestaw argumentów, który da się dopasować do
<tt>F</tt> da sie również dopasować do szablonu <tt>G</tt>, ale nie na odwrót.
W naszym przypadku do szablonu 3.2 da się dopasować
argumenty typu <tt>(T *,T *)</tt>, które ewidentnie można dopasować
również do szablonu 3.1. Na odwrót już nie:
<tt>(int,int)</tt> pasuje do 3.1, a do szablonu 3.2 nie.
</p>


<h2>Specjalizacja szablonów funkcji</h2>
<hr />
<br />
<p>Przy dotychczasowych definicjach szablonów <tt>max</tt>
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T  max<span style="color: #000000;">&#40;</span>T a, T b<span style="color: #000000;">&#41;</span>;         <span style="color: #ff0000;">//(1)</span>
template&lt;typename T&gt; T* max<span style="color: #000000;">&#40;</span>T *a, T *b<span style="color: #000000;">&#41;</span>;       <span style="color: #ff0000;">//(2)</span>
template&lt;typename T&gt; T  max<span style="color: #000000;">&#40;</span>T *data,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//(3)</span></pre></div>


<p>będziemy dalej mieli kłopoty z
funkcją <tt>max</tt> wywołaną dla argumentów typu <tt>char*</tt>. Takie
argumenty zwyczajowo oznaczają napisy. Zgodnie z tym, co napisałem wcześniej, 
wywołany zostanie dla nich przeciążony szablon (2) i  porówna 
tylko pierwsze litery napisów, co ewidentnie nie jest tym czego się
oczekuje. 
</p><p>Na szczęście można dokonać specjalizacji tego szablonu dla 
argumentów typu <tt>char *</tt> i <tt>const char *</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">char</span> *max&lt;char *&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span>
template&lt;&gt; <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* max&lt;const <span style="color: #0000ff;">char</span> *&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Jak zwykle możemy pominąć argumenty szablonu podane w nawiasach ostrych
za nazwą szablonu, jeśli mogą być one wydedukowane na podstawie
argumentów wywołania i najczęściej spotkamy się z następującym kodem:  
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">char</span> *max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span>
template&lt;&gt; <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_spec.cpp)
</p><p>Powyższe specjalizacje są pełne, tzn. określają
dokładnie wszystkie argumenty wywołania szablonu.  Dlatego lista
parametrów szablonu w tych szablonach jest pusta. Tylko takie
specjalizacje są dozwolone dla szablonów funkcji. Specjalizacja, w
przeciwieństwie do przeciążenia, musi dotyczyć już istniejącego
szablonu. Dlatego niedozwolona  jest specjalizacja:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* max&lt;char *&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_spec.cpp)
</p><p>Przykład 3.3
</p>

<p>ponieważ argumenty są typu <tt>char *</tt> i <tt>const char *</tt>, i jako
takie nie pasują do żadnego z istniejących szablonów (1-3).  Musimy
więc zdefiniować kolejne przeciążenie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">const</span> T* max<span style="color: #000000;">&#40;</span>T *a,<span style="color: #0000ff;">const</span> T*b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>*a<span style="color: #000000;">&#41;</span>&gt;<span style="color: #000000;">&#40;</span>*b<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span></pre></div>


<p>i dopiero wtedy kompilacja kodu 3.3 jest możliwa.  
Sytuację podsumowuje rysunek 3.1. 
</p>


<span class="inline inline-center"><img src="images/Cpp-3-1.png" alt="Rysunek 3.1." title="Rysunek 3.1."  class="image image-_original " width="598" height="345" /><span class="caption"><strong>Rysunek 3.1.</strong></span></span>


<p>Jawne podstawienie argumentów szablonu w miejsce parametru może
prowadzić, w przypadku istnienia szablonów przeciążonych, do powstanie
szeregu przeciążonych funkcji. Wtedy obowiązują "zwykłe" reguły
rozstrzygania przeciążenia, np. wyrażenie 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">max&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>spowoduje "wygenerowanie" trzech funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span>   max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">int</span>  *max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> *,<span style="color: #0000ff;">int</span>*<span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">int</span>   max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> *,<span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>( Źródło: max_over_explicit.cpp)
</p><p>Ponieważ zero lepiej pasuje do <tt>int</tt>-a niż do wskaźnika na
<tt>int</tt>, wybrana zostanie pierwsza z powyższych funkcji.
</p>

<h2>Funkcje zwykłe a szablony</h2>
<hr />
<br />

<p>Obok szablonów mogą istnieć zwykłe funkcje o tej samej nazwie.
Algorytm rozstrzygający przeciążenie preferuje dopasowanie zwykłych
funkcji nad szablonami, więc jeśli zdefiniujemy sobie funkcję
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j<span style="color: #000000;">&#41;</span>;</pre></div>

<p>to kompilator dokona następujących podstawień:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//zwykla funkcja int max(int,int)</span>
max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//zwykla funkcja int max(int,int) z rzutowaniem double na int</span>
max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,<span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//szablon max&lt;double&gt;(double, double)</span></pre></div>

<p>( Źródło: max_func.cpp)
</p><p>Z pozoru specjalizacje pełne opisane w poprzedniej części zachowują
się jak zwykłe funkcje i moglibyśmy napisać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">char</span> *max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>

<p>zamiast
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">char</span> *max&lt;char *&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>


<p>Jest tak jednak tylko, jeśli możliwa jest dedukcja argumentów szablonu. 
W przypadku szablonu
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> U&gt; T convert<span style="color: #000000;">&#40;</span>U u<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> static_cast&lt;T&gt;<span style="color: #000000;">&#40;</span>u<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>możemy zdefiniować np. specjalizacje:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">int</span>    convert&lt;int,double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> u<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;
template&lt;&gt; <span style="color: #0000ff;">double</span> convert&lt;double,double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> u<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;</pre></div>


<p>i używać ich podając jawnie pierwszy, niededukowalny argument szablonu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">convert&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.14</span><span style="color: #000000;">&#41;</span>;
convert&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2.71</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>natomiast zdefiniowanie dwóch funkcji o tej samej nazwie i argumentach
wywołania, różniących się tylko zwracanym typem, nie jest możliwe.
</p>

<h2>Nieudane podstawienie nie jest błędem</h2>
<hr />
<br />

<p>Jawne podstawienie wszystkich argumentów szablonu funkcji generuje nam
jedną lub więcej funkcji "zwykłych". Może się jednak zdażyć, że
niektóre podstawienia generują niepoprawny kod:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">typename</span> T::<span style="color: #00eeff;">value</span> t<span style="color: #000000;">&#40;</span>T x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
cerr&lt;&lt;<span style="color: #666666;">&quot;t1&quot;</span>&lt;&lt;endl;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Wywołanie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">t&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>( Źródło: sfinae.cpp)
</p><p>prowadzi do <tt>int::value</tt> i jest nieprawidłowe. Spowoduje to błąd
kompilacji, ale tylko wtedy, jeśli nie będzie innych przeciążonych
szablonów funkcji <tt>t</tt>. Jeśli dodamy przeciążenie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">void</span> t<span style="color: #000000;">&#40;</span>T x <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>cerr&lt;&lt;<span style="color: #666666;">&quot;t2&quot;</span>&lt;&lt;endl;<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: sfinae.cpp)
</p><p>to wyrażenie <tt>t<int>(0)</int></tt> zostanie do niego dopasowane. Innymi słowy,
algorytm dopasowania przeciążenia pomija błędne podstawienia, nie
generując błędów kompilacji.
</p>

<h2>Specjalizacje szablonów klas</h2>
<hr />
<br />

<p>Podobnie jak dla szablonów funkcji również dla szablonów klas istnieje
możliwość podania różnych implementacji dla różnych zestawów
argumentów szablonu. W przeciwieństwie jednak do szablonów funkcji,
szablony klas nie mogą być przeciążane, a jedynie specjalizowane.
Oznacza to, że w programie może istnieć tylko jeden szablon podstawowy o
danej nazwie. Szablon podstawowy to szablon, w którego definicji nie
występują nawiasy ostre po nazwie szablonu. Wszystkie szablony
prezentowane do tej pory były podstawowe. Z tej reguły wynika, że trzy
zdefiniowane do tej pory szablony stosu 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; Stack <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;
template&lt;typename T,<span style="color: #0000ff;">int</span> N = <span style="color: #0000dd;">100</span>&gt; Stack <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>; <span style="color: #ff0000;">//błąd szablon Stack już istnieje</span>
template&lt;typename T,template&lt;typename X&gt; C&gt; Stack <span style="color: #000000;">&#123;</span>
  C&lt;T&gt; _rep;
<span style="color: #000000;">&#125;</span> <span style="color: #ff0000;">//błąd szablon Stack już istnieje</span></pre></div>

<p>nie mogą istnieć razem!
Oczywiście w przypadku zastosowania domyślnych parametrów szablonu
pierwsza definicja jest niepotrzebna, ale również bardziej pożyteczny
trzeci szablon jest niedozwolony.
</p><p>To ograniczenie można po części obejść, dokonując specjalizacji
częściowej, która jest dozwolona tylko dla szablonów klas i daje
możliwość specjalizacji szablonu dla pewnego podzbioru jego argumentów,
a nie dla pojedynczego zestawu, jak specjalizacja pełna. Oczywiście
specjalizacja pełna też jest możliwa. Rozważmy następujący przykład,
definiując szablon podstawowy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N = <span style="color: #0000dd;">100</span>&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>możemy dokonać następujących specjalizacji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt;        <span style="color: #0000ff;">class</span> Stack&lt;T,<span style="color: #0000dd;">666</span>&gt;     <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>; 
template&lt;typename T,<span style="color: #0000ff;">int</span> N&gt;  <span style="color: #0000ff;">class</span> Stack&lt;T*,N&gt;      <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
template&lt;int N&gt;             <span style="color: #0000ff;">class</span> Stack&lt;double ,N&gt; <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
template&lt;int N&gt;             <span style="color: #0000ff;">class</span> Stack&lt;int *,N&gt;   <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
template&lt;&gt;                  <span style="color: #0000ff;">class</span> Stack&lt;double,<span style="color: #0000dd;">666</span>&gt;<span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
template&lt;&gt;                  <span style="color: #0000ff;">class</span> Stack&lt;double *,<span style="color: #0000dd;">44</span>&gt; <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: stack_spec.cpp)
</p>

<span class="inline inline-center"><img src="images/Cpp-3-2.png" alt="Rysunek 3.2. Symboliczne przedstawienie zbiorów argumentów dla różnych specjalizacji szablonu Stack." title="Rysunek 3.2. Symboliczne przedstawienie zbiorów argumentów dla różnych specjalizacji szablonu Stack."  class="image image-_original " width="497" height="345" /><span class="caption"><strong>Rysunek 3.2. Symboliczne przedstawienie zbiorów argumentów dla różnych specjalizacji szablonu Stack<T,N>.</t,n></strong></span></span>


<p>Każda z tych specjalizacji definiuje pewien podzbiór parametrów
szablonu podstawowego (zob. rysunek 3.2). Jeśli któryś z
podzbiorów zawiera się w drugim, to mówimy, że jedna specjalizacja jest
bardziej wyspecjalizowana od drugiej. Hierarchia specjalizacji dla
powyższego przykładu pokazana jest na rysunek 3.3.  Jeżeli
jakiś zestaw parametrów należy do dwóch (lub więcej) podzbiorów, które
się przecinaja, ale żeden nie zawiera się w drugim, to dla tych
parametrów kompilator nie bedzie w stanie wybrać specjalizacji.
</p>


<span class="inline inline-center"><img src="images/Cpp-3-3.png" alt="Rysunek 3.3. Uporządkownie specjalizacji szablonu Stack." title="Rysunek 3.3. Uporządkownie specjalizacji szablonu Stack."  class="image image-_original " width="640" height="295" /><span class="caption"><strong>Rysunek 3.3. Uporządkownie specjalizacji szablonu Stack<T,N>.</t,n></strong></span></span>


<p>Oczywiście ten przykład jest bardzo sztuczny i trudno sobie wyobrazić
powód tworzenia takich specjalizacji. Rozważmy bardziej realistyczny
przypadek: deklarujemy szablon podstawowy, ale bez podawania jego
definicji; będziemy korzystać jedynie z jego specjalizacji:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N = <span style="color: #0000dd;">100</span>, <span style="color: #0000ff;">typename</span> R = T*&gt; <span style="color: #0000ff;">class</span> Stack;</pre></div>


<p>Następnie definiujemy dwie specjalizacje. Pierwszą dla stosów opartych
o zwykłe tablice:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N&gt; <span style="color: #0000ff;">class</span> Stack&lt;T,N,T*&gt; <span style="color: #000000;">&#123;</span>
  T _rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> _top;
<span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=e;<span style="color: #000000;">&#125;</span>
  T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>--_top<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>i drugą opartą o kontenery STL:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N,template&lt;typename E&gt; <span style="color: #0000ff;">class</span> Sequence&gt; 
  <span style="color: #0000ff;">class</span> Stack&lt;T,N,Sequence&lt;T&gt; &gt; <span style="color: #000000;">&#123;</span>
  Sequence&lt;T&gt; _rep;
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep.<span style="color: #00eeff;">push_back</span><span style="color: #000000;">&#40;</span>e<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
  T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>T top = _rep.<span style="color: #00eeff;">top</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;_rep.<span style="color: #00eeff;">pop_back</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;return top;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep.<span style="color: #00eeff;">empty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: Stack_2.cpp)
</p><p>Korzystając z tych specjalizacji możemy pisać następujący kod. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  Stack&lt;int,<span style="color: #0000dd;">100</span>,<span style="color: #0000ff;">int</span> *&gt;            s_table;
  Stack&lt;int,<span style="color: #0000dd;">100</span>&gt;                  s_default ;
  Stack&lt;int,<span style="color: #0000dd;">0</span>,std::<span style="color: #00eeff;">vector</span>&lt;int&gt; &gt;  s_container;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: Stack_2.cpp)
</p><p>W każdym przypadku kompilator wybierze implementację odpowiednią dla
podanych parametrów.
</p>
<h2>Szablony a dziedziczenie</h2>
<hr />
<br />

<p>Szablony klas mogą oczywiście dziedziczyć z innych klas. Deklaracja
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; Stack: <span style="color: #0000ff;">public</span> Container <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>oznacza, że każda instancja danego szablonu <tt>Stack<T></t></tt> dziedziczy z
klasy <tt>Container</tt>. Ponieważ konkretna instancja szablonu jest
klasą, to dowolna klasa czy szablon może dziedziczyć z instancji
szablonu:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> special Stack_int : <span style="color: #0000ff;">public</span> Stack&lt;int&gt; <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span></pre></div>

<p>Definiując specjalizację szablonu klasy możemy dziedziczyć z innych
specjalizacji tej samej klasy; nie może to jednak prowadzić do
rekurencji. Jeśli napiszemy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N&gt; Stack <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;
template&lt;typename T&gt; 
Stack&lt;T*,N&gt;: <span style="color: #0000ff;">private</span> Stack&lt;void *,N&gt; <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: stack_void.cpp)
</p><p>to kompilator odmówi skompilowania tego kodu z powodu rekurencyjnej
definicji specjalizacji szablonu <tt>Stack</tt>. Wszystko będzie w
porządku  jeśli dodamy specjalizację  dla typu <tt>void *</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;int N&gt; <span style="color: #0000ff;">class</span> Stack&lt;void *,N&gt; <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: stack_void.cpp)
</p><p>Dlaczego mielibyśmy jednak dziedziczyć implementację klasy <tt>void*</tt>?
Powodem jest unikanie powielania kodu.  Ponieważ każda konkretyzacja
(instancja) szablonu jest osobną klasa, to dla każdej generowany jest
pełny kod potrzebnych funkcji. Jeśli te funkcje są proste, to
nie jest to kłopot. W praktyce implementacja stosu musi zwykle
uwzględniać dynamiczne zarządzanie pamięcią i może być  dużo bardziej
skomplikowana, a zatem generowany kod będzie odpowiednio większy.
Ogólnie jest to nie do uniknięcia, ale ponieważ wszystkie wskaźniki
mają ten sam rozmiar i można je rzutować na <tt>void *</tt> to możemy
wykorzystać implementację <tt>Stack<void *></void></tt> do implementacji
pozostałych typów wskaźnikowych:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">size_t</span> N&gt; 
Stack&lt;T*,N&gt;: <span style="color: #0000ff;">private</span> Stack&lt;void *,N&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  T* pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> static_cast&lt;T*&gt;<span style="color: #000000;">&#40;</span>Stack&lt;void *&gt;::<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T *e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    Stack&lt;void *&gt;::<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span>e<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> Stack&lt;void *&gt;::<span style="color: #00eeff;">is_empty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;</pre></div>
<p>( Źródło: stack_void.cpp)
</p><p>Korzystamy tu z automatycznej konwersji <tt>T*</tt> na <tt>void *</tt>.  W ten
sposób, np. kod funkcji <tt>Stack<int *>::push(int *)</int></tt>
będzie zawierał tylko parę instrukcji opakowujących wywołanie kodu
funkcji <tt>Stack<void *>::push(void *)</void></tt>. Proszę zwrócić uwagę na
zastosowanie dziedziczenia prywatnego.
</p>

<h3>Zależne klasy bazowe</h3>
<br />
<p>Szablon klasy może również dziedziczyć z innego szablonu klasy, którego
argumenty bedą zależały od jego parametrów:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;typename T&gt; <span style="color: #0000ff;">class</span> Base&lt;T&gt; <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;
template&lt;typename S&gt; 
<span style="color: #0000ff;">class</span> Derived: <span style="color: #0000ff;">public</span> Base&lt;S&gt; <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>Przy tych definicjach klasa <tt>Derived<double></double></tt> dziedziczy z
klasy <tt>Base<double></double></tt>. Taką klasę nazywamy zależną klasą bazową i
jest to bardzo częsta konstrukcja w programowaniu uogólnionym. 
</p><p>Z zależnymi klasami bazowymi wiąże się jednak pewna zasada, związana z
wyszukiwaniem nazw, która może być sporym zaskoczeniem.  Rozważmy
następujący przykład:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt;  <span style="color: #0000ff;">class</span> Base <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  Base<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:basefield<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">int</span> basefield;
<span style="color: #000000;">&#125;</span>;
template&lt;typename T&gt; <span style="color: #0000ff;">class</span> DD :<span style="color: #0000ff;">public</span> Base&lt;T&gt; <span style="color: #000000;">&#123;</span>       
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>std::<span style="color: #00eeff;">cerr</span>&lt;&lt;basefield&lt;&lt;std::<span style="color: #00eeff;">endl</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: base.cpp)
</p><p>Ten kod się nie skompiluje przy pomocy kompilatora C++ zgodnego ze
standardem. Np. nie skompiluje go kompilator
g++-3.4, a g++-3.3 tak. Powód tego faktu jest następujący: nazwa <tt>basefield</tt>, występująca w
klasie <tt>DD</tt> jest nazwą niezależną (od parametru szablonu). Klasa
bazowa, w której ta nazwa jest zdefiniowana jest klasą bazową zależną
(od parametru szablonu). Według standardu kompilator nie wyszukuje
nazw niezależnych w zależnych klasach bazowych.  Kompilator g++-3.4
jest bliżej stadardu niż g++-3.3 i stąd to całe zamieszanie. Aby kod się skompilował należy uczynić tę nazwę zależną, np. poprzez kwalifikowanie jej nazwą klasy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> DD :<span style="color: #0000ff;">public</span> Base&lt;T&gt; <span style="color: #000000;">&#123;</span>       
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>std::<span style="color: #00eeff;">cerr</span>&lt;&lt;DD::<span style="color: #00eeff;">basefield</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: base.cpp)
</p><p>lub przez 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> DD :<span style="color: #0000ff;">public</span> Base&lt;T&gt; <span style="color: #000000;">&#123;</span>       
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>std::<span style="color: #00eeff;">cerr</span>&lt;&lt;this-&gt;basefield&lt;&lt;std::<span style="color: #00eeff;">endl</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: base.cpp)
</p>
<h3>CRTP</h3>
<br />
<p>Dziedziczenie szablonów można też wykorzystać do przydatnej
"sztuczki", zwanej po angielsku <i>"couriously reccuring template
pattern"</i> (autorem tego idiomu jest James O. Coplien). Rozważmy następujący problem: chcemy
zaimplementować mechanizm automatycznego liczenia ilości obiektów
danej klasy. To standardowe zadanie na zastosowanie konstruktorów,
destruktorów i statycznych składowych klasy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Countable <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">protected</span>:
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">size_t</span> _counter;
<span style="color: #0000ff;">public</span>:
  Countable<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>++_counter;<span style="color: #000000;">&#125;</span>
  Countable<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Countable &amp;<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>++_counter;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">virtual</span> ~Countable <span style="color: #000000;">&#123;</span>--_counter<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">size_t</span> counter<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _counter;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">size_t</span> Countable::_counter = <span style="color: #0000dd;">0</span>;</pre></div>

<p>Oczywiście wpisywanie tego kodu do każdej klasy, której obiekty chcemy
zliczać jest nużące i łamie zasadę niepowielania kodu.  Postaramy się
więc wykorzystać kod klasy <tt>Countable</tt>, dziedzicząc go w innych klasach:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> MyClass1 : <span style="color: #0000ff;">public</span> Countable <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">class</span> MyClass2 : <span style="color: #0000ff;">public</span> Countable <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Niestety ponieważ obie klasy <tt>MyClass1</tt> i <tt>MyClass2</tt> dziedziczą
z tej samej klasy, dziedziczą również ten sam wspólny licznik. Tak
więc zliczaniu podlegać będą obiekty obu klas wspólnie. W rozwiązaniu
pomogą nam szablony. Wystarczy uczynić  klasę <tt>Countable</tt> szablonem
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> Countable <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">protected</span>:
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">size_t</span> _counter;
<span style="color: #0000ff;">public</span>:
  Countable<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>++_counter;<span style="color: #000000;">&#125;</span>
  Countable<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Countable &amp;<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>++_counter;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">virtual</span> ~Countable<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>--_counter<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">size_t</span> counter<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _counter;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;
template&lt;typename T&gt; <span style="color: #0000ff;">size_t</span> Countable&lt;T&gt;::_counter = <span style="color: #0000dd;">0</span>;</pre></div>

<p>( Źródło: countable.cpp)
</p><p>i używać go w następujący sposób:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> MyClass1 : <span style="color: #0000ff;">public</span> Countable&lt;MyClass1&gt; <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">class</span> MyClass2 : <span style="color: #0000ff;">public</span> Countable&lt;MyClass2&gt; <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: countable.cpp)
</p><p>Ponieważ każda konkretyzacja szablonu jest osobną klasą, klasy
<tt>MyClass1</tt> i <tt>MyClass2</tt> dziedziczą z różnych klas bazowych i
będą posiadać różne liczniki, ale ciągle wspólne w ramach każdej
klasy.  Parametryzowanie klasy bazowej typem klasy dziedziczącej
gwarantuje jej unikatowość.
</p>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/max_overload.cpp">max_overload.cpp</a></td><td>506 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_spec.cpp">Max_spec.cpp</a></td><td>953 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_over_explicit.cpp">Max_over_explicit.cpp</a></td><td>393 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sfinae.cpp">Sfinae.cpp</a></td><td>307 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_spec.cpp">Stack_spec.cpp</a></td><td>968 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_2.cpp">Stack_2.cpp</a></td><td>672 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_void.cpp">Stack_void.cpp</a></td><td>1010 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Base.cpp">Base.cpp</a></td><td>364 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Countable.cpp">Countable.cpp</a></td><td>661 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1240" class="section-2">
  <h1 class="book-heading">Testowanie</h1>
  <h2>Wstęp</h2>
<hr />
<br />
<p>Programowanie rozumiane jako pisanie kodu jest tylko częścią procesu
tworzenia oprogramowania. Analiza i opis tego procesu jest przedmiotem
inżynierii oprogramowania i znacznie wykracza poza ramy tego wykładu.
Niemniej chciałbym pokrótce w tym wykładzie poruszyć jedno zagadnienie
związane bezpośrednio z programowaniem - testowanie. 
Testowanie jest nieodłączną częścią programowania i
powinno być obowiązkiem każdego programisty. Jak będę się starał
Państwa przekonać, testowanie to może być coś więcej niż "tylko"
sprawdzenie poprawności kodu.
</p>

<h2>Testowanie</h2>
<br />
<p>Testowanie wydaje się oczywistą koniecznością w przypadku każdego
programu komputerowego (choć co rok zdarza mi się spotkać studentów
przekonanych o swojej nieomylności:)). Mniej oczywiste jest
stwierdzenie kto, gdzie, kiedy i co ma testować. To w ogólności bardzo
złożony problem, ale tu chciałbym się ograniczyć do tzw. testów
jednostkowych. Wyrażenie "test jednostkowy" należy interpretować
jako test jednej jednostki. Przez pojedynczą jednostkę będziemy
rozumieli: funkcję, metodę lub klasę. Zadaniem takiego testu jest
sprawdzenie czy dana jednostka działa poprawnie. 
</p><p>Dlaczego w ogóle pisać takie testy? Czy nie wystarczy przetestowanie
całego programu? Testować cały program też oczywiście trzeba. Służą
do tego liczne testy odbioru, integracyjne itp., wykonywane poprzez
dedykowane zespoły.  Ale im większą część kodu testujemy, tym
trudniejsze są testy i tym trudniej będzie znaleźć przyczynę wykrytej
nieprawidłowości działania programu. Testy jednostkowe wykrywają
błędy (a przynajmniej ich część) "u źródła", często w bardzo prostym
kodzie, a więc ich poprawianie  może być dużo szybsze. 
</p><p>Jak się zastanowić, to testowanie każdej wykonanej jednostki przed
użyciem jej w dalszym kodzie powinno być oczywistą koniecznością. No,
ale równie oczywiste jest, że należy uprawiać sporty, nie palić
papierosów, nie jeździć po pijanemu, itp. Statystyki dobitnie jednak
pokazują, że natura człowiecza grzeszną jest i łatwo ulegamy
słabościom, w tym wypadku pokusie nietestowania programów, a powodem
jest jeden z siedmiu grzechów głównych czyli lenistwo. Testy nie
piszą, ani nie wykonuja się same, w rzeczywistości wymagają całkiem
sporego nakładu pracy (czasami większego niż pisanie testowanego
kodu!). Część programistów traktuje ten wysiłek jako "czas
stracony", tzn. nie wykorzystany na pisanie kodu, za który im płacą.
</p><p>To wszystko jest prawdą, ale w rzeczywistości nie możemy uniknąć tej
straty czasu. Jest to tylko kwestia wyboru gdzie i ile tego czasu
stracimy: czy na pisanie testów w trakcie kodowania jednostek i
poprawianie prostych błędów, czy na szukanie błędów w dużo większych
fragmentach programu? Doświadczenie wykazuje, że czas potrzebny na
znalezienie i poprawienie błędu jest w tym drugim przypadku dużo
większy, w krańcowych przypadkach poprawienie programu może być wręcz
niemożliwe.  Testy jednostkowe skalują się liniowo z rozmiarem
pisanego kodu, a nie ekspotencjalnie jak np. testy integracyjne.
Oczywiście testy jednostkowe nie rozwiążą wszystkich problemów, jeśli mamy zły
projekt całości to nic nam nie pomogą idealnie działające jednostki,
ale przynajmniej będzie nam łatwiej się o tym przekonać.
</p><p>Jak już napisałem testy służą do sprawdzania poprawności działania
danej jednostki: <b>ciągłego</b> sprawdzanie działania tej jednostki.
Ponieważ kod się nieustannie zmienia, powinniśmy wykonywać testy cały
czas aby sprawdzić czy te zmiany wynikające, np. z poprawienia
wykrytych błędów, nie wprowadziły nowych usterek. Aby to było możliwe
testy musza być łatwe do wykonywania czyli zautomatyzowane. Nie mogą
polegać na tym, że puszczamy program, a następnie przeglądamy wydruk.
Musimy "nacisnąć guzik" a w odpowiedzi zapali  nam się szereg
"światełek": zielone wskażą testy zaliczone, a czerwone testy niezaliczone. Taki automatyczny proces testujący może być zintegrowany z
innymi narzędzimi programistycznymi, takimi jak np. <tt>make</tt>.
</p>
<br />
<h3>Refaktoryzacja</h3>
<hr />
<br />

<p>Wysiłek włożony w napisanie takich powtarzalnych testów nie jest
zaniedbywalny, ale korzyści są duże.  Możliwość przetestowania kodu w
dowolnym momencie to więcej niż tylko świadomość, że nasz obecny kod
przeszedł testy. Taka możliwość, w połączeniu z narzędziami
zarządzającymi kodem źródłowym, pozwala na bezpieczne dokonywanie
zmian według schematu: zmieniamy, testujemy, jeśli testy się nie
powiodą szukamy błedów, jeśli ich nie znajdujemy to cofamy zmiany.
Takie podejście jest szczególnie pomocne, a właściwie niezbędne,
podczas programowania przyrostowego i refaktoryzacji. 
</p><p>Programowanie przyrostowe to technika zalecana dla większości
projektów, która polega na programowaniu "malymi krokami", czyli na
kolejnym dodawaniu nowych funkcji do istniejącego działajacego kodu.
Testy umożliwiają sprawdzenie czy dodany kod nie wprowadził błędów do
starej części. Oczywiście każdy przyrost wymaga stworzenia nowego
zestawu testów. 
</p><p>Refaktoryzacja to zmiana kodu bez zmiany jego funkcjonalności w celu
poprawy jego jakości.
</p>

<h3>Projektowanie sterowane testami</h3>
<br />

<p>Pisanie testu sprawdza również nasze zrozumienie tego, co dana
jednostka ma robić. W tym sensie testy stanowią sformalizowany zapis
wymagań. To zaleta, którą trudno przecenić. Jeżeli nie wiemy jak
przestestować daną jednostkę, to najprawdopodobniej nie powinniśmy się
wcale brać za jej kodowanie.  Dlatego niektóre metodologie (np.
extreme programming) zalecają projektowanie sterowane testami, czyli
zaczęcie pisania programu od pisania testów do niego. Przebieg pracy
przy takim podejściu wygląda następująco:
</p>
<ol><li> Piszemy test
</li><li> Kompilujemy test
</li><li> Test się nie kompiluje
</li><li> Piszemy tyle kodu aby test sie skompilował
</li><li> Test się kompiluje
</li><li> Wykonujemy test
</li><li> Test najprawdpodobniej nie wykonuje się poprawnie
</li><li> Poprawiamy/dopisujemy  kod tak aby test się wykonał
</li><li> Test wykonuje się poprawnie 
</li></ol>
<p>Osobiście wydaje mi się, że zalety tego podejścia są ogromne. Nawet
jeśli brakuje czasu i ochoty na pisanie testów, to należy po prostu
zastanowić się nad sposobem przetestowania naszego kodu zanim
zaczniemy go pisać. To znakomicie zmusza do ścisłego określenia 
tego, co właściwie nasz program ma robić.
</p>

<h3>Testy</h3>
<br />

<p>Po tej całej propagandzie - czas na testowanie w praktyce. Przetestujemy
przykłady wprowadzone w poprzednich rozdziałach, zaczynając od funkcji
<tt>max</tt>: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>

<p>Być może część z Państwa oburzy się: jak to? testować
tę jedną linijkę? Gdyby chodziło o tę jedną linijkę to rzeczywiście
wystarczy na nią popatrzeć (i mieć wiarę w kompilator), ale
przypominam, że dodaliśmy do niej dwie przeciążone wersje i dwie 
specjalizacje. A to oznacza, że ta linijka nie działa poprawnie w
każdym przypadku.  Napiszemy więc testy, które to wyłapią. Jak już
pisałem będzie to jednoczesne zdefiniowanie tego jak funkcja <tt>max</tt>
ma działać. Po chwili zastanowienia ustalamy więc, że nasza funkcja
<tt>max</tt> zwraca: 
</p>
<ul><li> większą z dwu przekazanych wartości (większą w sensie porównania operatorem <tt>></tt>)
</li><li> jeśli argumentami są wskaźniki to <tt>max</tt> zwraca wskaźnik na większą wartość
</li><li> jeśli argumentami są wskaźniki na <tt>char</tt> to <tt>max</tt> traktuje je jako napisy i zwraca wskaźnik do napisu większego zgodnie z uporządkowaniem leksykalnym.
</li></ul>
<p>Testować funkcję <tt>max</tt> będziemy poprzez porównanie wartości
zwracanej do wartości poprawnej, którą sami wskażemy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Należy też sprawdzić przypadek symetryczny
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Testowanie szablonu jest trudne, bo w zasadzie musimy rozważyć
przekazanie argumentów dowolnego typu. Co więcej, ten typ wcale nie
musi posiadać operatora porównania <tt>==</tt>. Aby sprawdzić działanie <tt>max</tt> na jakimś typie niewbudowanym posłużymy się własną klasą:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> <span style="color: #0000ff;">Int</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:
 <span style="color: #0000ff;">int</span> _val;
<span style="color: #0000ff;">public</span>:
 <span style="color: #0000ff;">Int</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i<span style="color: #000000;">&#41;</span>:_val<span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
 <span style="color: #0000ff;">int</span> val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _val;<span style="color: #000000;">&#125;</span>;
 <span style="color: #0000ff;">friend</span> <span style="color: #0000ff;">bool</span> operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">Int</span> &amp;a,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">Int</span> &amp;b<span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">return</span> a._val&gt;b._val; 
 <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Kod testowy może teraz wyglądać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">Int</span> i<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">Int</span> j<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>j,i<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>j,j<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>i,i<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Następnie testujemy wersję wskaźnikową:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>&amp;i,&amp;j<span style="color: #000000;">&#41;</span>-&gt;val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>&amp;j,&amp;i<span style="color: #000000;">&#41;</span>-&gt;val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>&amp;j,&amp;j<span style="color: #000000;">&#41;</span>-&gt;val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>&amp;i,&amp;i<span style="color: #000000;">&#41;</span>-&gt;val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>i na koniec wersję dla napisów (<tt>const char *</tt>):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;abcd&quot;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;acde&quot;</span>,<span style="color: #666666;">&quot;abcd&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;abcd&quot;</span>,<span style="color: #666666;">&quot;abcd&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #666666;">&quot;abcd&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;acde&quot;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>oraz (<tt>char *</tt>):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">char</span> s1<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;abcde&quot;</span>;
<span style="color: #0000ff;">char</span> s2<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;ac&quot;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s1,s2<span style="color: #000000;">&#41;</span>,s2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s2,s1<span style="color: #000000;">&#41;</span>,s2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s1,s1<span style="color: #000000;">&#41;</span>,s1<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s2,s2<span style="color: #000000;">&#41;</span>,s2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Napisy zostały tak dobrane, żeby miały pierwszy znak identyczny,
ponieważ procedura ogólna dla wskaźników porównuje właśnie pierwsze
znaki. To pokazuje jak ważny jest wybór danych testowych. Testy
jednostkowe są testami "białej skrzynki", tzn. piszący testy ma wgląd
do implementacji testowanego kodu (powinien to być ten sam
programista), można więc przygotować dane testowe tak, aby pokrywały
możliwie wiele ścieżek wykonywania programu, warunków brzegowych itp. 
</p><p>Oczywiście bezbłędne przejście powyższych testów nie gwarantuje nam
jeszcze poprawności funkcji <tt>max</tt> (tego zresztą nie zagwarantuje
nam żaden test), ale bardzo zwiększa prawdopodobieństwo tego, że tak
jest.
</p><p>Pozostaje nam do wytestowanie procedura szukająca maksimum w tablicy.
To zadanie zostawiam jako ćwiczenie dla czytelników.
</p><p><br />
Powyższy przykład może budzić pewne obawy. Kod funkcji <tt>max</tt> liczy
około 20 linii, a kod testujący 40. No cóż, testowanie kosztuje, tylko
czy możemy sobie pozwolić na zrezygnowanie z niego? Rozważmy powyższy
przykład, te dwadzieścia  linii kodu definiującego szablon <tt>max</tt> jest dużo
bardziej skomplikowane niż te czterdzieści linii kodu testujacego, tak że jeśli
porównamy czas pisania, to nie wypada to już tak źle. Kod szablonu
<tt>max</tt> zawiera przeciążenia i specjalizację, czyli wykorzystany jest
algorytm rozstrzygania przeciążenia. Osobiście nie ufam swojej
znajomości tego algorytmu na tyle, aby nie sprawdzić kodu. Jeżeli i tak
wykonujemy jakieś testy to warto zainwestować trochę więcej pracy i
przygotować porządny zestaw testujący.  Może też się zdarzyć, że
będziemy chcieli dodać kolejne przeciążenia, które mogą wpłynąć w
niezamierzony sposób na przeciążenia już istniejące. Gotowy programik
testujący pozwoli nam to szybko wykryć.
</p><p>Pozostaje jeszcze sprawa poprawności samego programu testującego, w
końcu to też jest kod i może zawierać błędy. Czy więc musimy pisać kod
testujący program testujący, i tak dalej w nieskończoność? Na
szczęście nie, błędy w kodzie testującym mogą mieć dwa efekty.
Pierwszy to wykazanie błędu, który nie jest błędem, w tej sytuacji taki
błąd wykrywa się sam. Musimy tylko pamiętać podczas
szukania źródeł wykazanych przez program testujacy usterek, że mogą
one pochodzić z kodu testującego. Drugi rodzaj błędu to nie wykrycie
błędu w programie. Występowanie tego rodzaju błedów testujemy poprzez
wprowadzanie do programu zamierzonych błędów i sprawdzając czy nasze
testy je wykryją.
</p>

<h3>CppUnit</h3>
<br />

<p>Rysunek 4.1 przedstawia częściową hierachię klas w szkielecie <tt>CppUnit</tt>.
</p>

<span class="inline inline-center"><img src="images/Cpp-4-1.png" alt="Rysunek 4.1. Częściowa hierarchia klas w szkielecie CppUnit." title="Rysunek 4.1. Częściowa hierarchia klas w szkielecie CppUnit."  class="image image-_original " width="498" height="346" /><span class="caption"><strong>Rysunek 4.1. Częściowa hierarchia klas w szkielecie CppUnit.</strong></span></span>

<p>Jest to bardzo mała część, uwzględniająca
tylko te klasy, które zostaną użyte w naszym przykładzie. Proszę przede
wszystkim zwrócić uwagę na hierachię klasy <tt>Test</tt>. Jest to
klasyczny wzorzec <tt>Kompozyt</tt> (zob. E. Gamma, R. Helm, R. Johnson, J. Vlissides <i>"Wzorce projektowe. Elementy oprogramowania obiektowego wielokrotnego użytku"</i>), umożliwiający
dowolne składanie i zagnieżdżanie testów. Jest to możliwe dzieki temu,
że klasa <tt>TestSuite</tt> może zawierać inne testy, w tym też inne
<tt>TestSuite</tt>.
</p><p>Każda klas z tej hierarchii zawiera funkcję <tt>run(TestResult *result)</tt>, która wywołuje funkcję <tt>runTest()</tt>, którą musimy przeładować definiując nasz własny test. Klasa <tt>TestResult</tt>, a raczej jej obiekty, służą do zbierania wyników testów. 
</p><p>Nasz przykład z <tt>max</tt> możemy zapisać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include &lt;cppunit/TestResult.h&gt;</span>
<span style="color: #339900;">#include &lt;cppunit/TestCase.h&gt;</span>
&nbsp;
<span style="color: #0000ff;">class</span> Max_test : <span style="color: #0000ff;">public</span> CppUnit::<span style="color: #00eeff;">TestCase</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
&nbsp;
  <span style="color: #0000ff;">void</span> runTest<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>; &lt;i&gt;sztucznie wprowadzony błąd!&lt;/i&gt;
    <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
&nbsp;
    <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
&nbsp;
    .
    .
    .
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: max_test_case.cpp)
</p><p>Powyższy test możemy wywołać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
CppUnit::<span style="color: #00eeff;">TestResult</span> result;
Max_test max;
&nbsp;
max.<span style="color: #00eeff;">run</span><span style="color: #000000;">&#40;</span> &amp;result <span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>Jak na razie większym kosztem uzyskaliśmy ten sam efekt co programik z
poprzedniego podrozdziału :). Czas więc wykorzystać jakieś własności szkieletu. 
</p><p>Zaczniemy od wykorzystania, zamiast standardowego makra <tt>assert</tt>,
makr szkieletu <tt>CppUnit</tt>: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include &lt;cppunit/TestResult.h&gt;</span>
<span style="color: #339900;">#include &lt;cppunit/TestCase.h&gt;</span>
<span style="color: #339900;">#include &lt;cppunit/TestAssert.h&gt;</span>
&nbsp;
<span style="color: #0000ff;">class</span> Max_test : <span style="color: #0000ff;">public</span> CppUnit::<span style="color: #00eeff;">TestCase</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
&nbsp;
  <span style="color: #0000ff;">void</span> runTest<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; &lt;i&gt;sztucznie wproadzony bład!&lt;/i&gt;
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
    .
    .
    .
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: max_test_runner.cpp)
</p><p>Jednak wykonanie tego samego kodu <tt>main</tt> co poprzednio nie da
żadnych wyników! To dlatego, że makra <tt>CPPUNIT_ASSERT_...</tt> nie
powodują przerwania programu tylko zapisanie wyników do obiektu typu
<tt>TestResult</tt>. Najłatwiej odczytać te wyniki nie uruchamiając
testów samemu tylko za pośrednictwem  obiektu <tt>TextUi::TestRunner</tt>.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include &lt;cppunit/ui/text/TestRunner.h&gt;</span>
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
Max_test *max = <span style="color: #0000dd;">new</span> Max_test;
CppUnit::<span style="color: #00eeff;">TextUi</span>::<span style="color: #00eeff;">TestRunner</span> runner;
&nbsp;
runner.<span style="color: #00eeff;">addTest</span><span style="color: #000000;">&#40;</span> max <span style="color: #000000;">&#41;</span>; 
&lt;i&gt;max musi byc wskaźnikiem utworzynym za pomocą <span style="color: #0000dd;">new</span> bo runner
przejmuje go na własność i sam zwalnia przydzieloną dla niego pamięć&lt;/i&gt; 
runner.<span style="color: #00eeff;">run</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_test_runner.cpp)
</p><p>Teraz uruchomienie programu spowoduje wydrukowanie na <tt>std::cout</tt>
raportu z wykonania testu. Ciągle jednak jest to niewspółmierne do
włożonego wysiłku. Postaramy się więc teraz zacząć strukturyzować
nasze testy. Możemy oczywiście stworzyć kilka różnych klas 
testujących z inną funkcją <tt>runTest()</tt> każda, ale 
zamiast tego wykorzystamy klasę <tt>TestFixture</tt>. Rzut oka
na rysunek 4.1 pokazuje, że nie jest to <tt>Test</tt>, ale
przerobimy ją na test za pomocą <tt>TestCaller</tt>.
</p><p>Zaczynamy od zdefiniowanie szeregu testów w jednej klasie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include &lt;cppunit/TestFixture.h&gt;</span>
<span style="color: #339900;">#include &lt;cppunit/TestAssert.h&gt;</span>
&nbsp;
<span style="color: #0000ff;">class</span> Max_test : <span style="color: #0000ff;">public</span> CppUnit::<span style="color: #00eeff;">TestFixture</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">Int</span> i,j;
<span style="color: #0000ff;">public</span>:
 Max_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:i<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span>,j<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
 <span style="color: #0000ff;">void</span> int_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; &lt;i&gt;sztucznie wprowadzony bład!&lt;/i&gt;
    ...
    <span style="color: #00eeff;">CPPUNIT_ASSERT_EQUAL</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; &lt;i&gt;sztucznie wprowadzony bład!&lt;/i&gt;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> class_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">6</span>,max<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
    ...
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> class_ptr_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">6</span>,max<span style="color: #000000;">&#40;</span>&amp;i,&amp;j<span style="color: #000000;">&#41;</span>-&gt;val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
    ...
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> const_char_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;abcd&quot;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;
    ...
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> char_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">char</span> s1<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;abcde&quot;</span>;
    <span style="color: #0000ff;">char</span> s2<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;ac&quot;</span>;
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s1,s2<span style="color: #000000;">&#41;</span>,s2<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;
    ...
    <span style="color: #00eeff;">CPPUNIT_ASSERT_EQUAL</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s2,s2<span style="color: #000000;">&#41;</span>,s2<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>; 
    &lt;i&gt;sztucznie wprowadzony bład!&lt;/i&gt;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: max_test_caller.cpp)
</p><p>Podzieliliśmy nasz test na kilka mniejszych, z których każdy testuje
zachowanie jednej klasy argumentów funkcji <tt>max</tt>. Zmienne używane
wspólnie zadeklarowalismy jako składowe klasy i inicjalizujemy w
konstruktorze. Potem pokażemy jak można wywoływać dodatkowy kod
inicjalizujący przed wykonaniem każdej metody, ale na razie ten
mechanizm nie jest nam potrzebny. 
</p><p>No, ale jak wywołać te testy? Klasa <tt>TestFixture</tt> nie jest testem i
nie posiada funkcji <tt>runTest</tt>. Aby móc jej użyć musimy skorzystać z
szablonu <tt>TestCaller</tt>. Szablon <tt>TestCaller</tt> przyjmuje jako swój
parametr klasę <tt>TextFixture</tt>, w naszym przypadku <tt>Max_test</tt>. W
konstruktorze obiektów tej klasy podajemy nazwę testu i adres metody
klasy <tt>Max_test</tt>, która ten test implementuje. Tak skonstruowany
obiekt jest już testem i możemy go przekazać do obiektu <tt>runner</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
CppUnit::<span style="color: #00eeff;">TextUi</span>::<span style="color: #00eeff;">TestRunner</span> runner;
&nbsp;
 runner.<span style="color: #00eeff;">addTest</span><span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;int_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">int_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
... &lt;i&gt;podobnie dla reszty metod klasy Maxtest&lt;/i&gt;
&nbsp;
runner.<span style="color: #00eeff;">run</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_test_caller.cpp)
</p><p>Teraz wykonanie programu spowoduje wywołanie 5 testów. Co ważne - 
niepowodzenie ktorejś z asercji w jednym teście przerywa wykonywanie
tego testu, ale nie ma wpływu na wykonywanie się innych testów. 
</p><p>Zamiast dodawać testy do "wykonywacza" pojedynczo, możemy je najpierw
pogrupować za pomocą obiektów <tt>TestSuite</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
CppUnit::<span style="color: #00eeff;">TextUi</span>::<span style="color: #00eeff;">TestRunner</span> runner;
 CppUnit::<span style="color: #00eeff;">TestSuite</span> *obj_suite = <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestSuite</span>;
 CppUnit::<span style="color: #00eeff;">TestSuite</span> *ptr_suite = <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestSuite</span>;
&nbsp;
 obj_suite-&gt;addTest<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;int_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">int_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>; 
 obj_suite-&gt;addTest<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;class_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">class_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
  ptr_suite-&gt;addTest<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;class_ptr_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">class_ptr_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
  ptr_suite-&gt;addTest<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;const_char_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">const_char_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
  ptr_suite-&gt;addTest<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;char_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">char_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
  runner.<span style="color: #00eeff;">addTest</span><span style="color: #000000;">&#40;</span>obj_suite<span style="color: #000000;">&#41;</span>;
  runner.<span style="color: #00eeff;">addTest</span><span style="color: #000000;">&#40;</span>ptr_suite<span style="color: #000000;">&#41;</span>;
  runner.<span style="color: #00eeff;">run</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>Obiekty <tt>TestSuite</tt> są  testami i możemy je dalej grupować:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"> CppUnit::<span style="color: #00eeff;">TestSuite</span> *max_suite = <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestSuite</span>;
&nbsp;
 max_suite-&gt;addTest<span style="color: #000000;">&#40;</span>obj_suite<span style="color: #000000;">&#41;</span>;
 max_suite-&gt;addTest<span style="color: #000000;">&#40;</span>ptr_suite<span style="color: #000000;">&#41;</span>;
 runner.<span style="color: #00eeff;">addTest</span><span style="color: #000000;">&#40;</span>max_suite<span style="color: #000000;">&#41;</span>;
&nbsp;
runner.<span style="color: #00eeff;">run</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>Widać, że szkielet <tt>CppUnit</tt> daje nam sporo możliwości, ale ciągle
jest to niewspółmierne do włożonego wysiłku. Powodem tego jest prostota
użytego przykładu, który nie wymaga takich narzędzi. Pakiet
<tt>CppUnit</tt> posiada jednak o wiele więcej możliwości, między innymi:
</p>
<ul><li> W klasie <tt>TextFixture</tt> można przeładować funkcje <tt>void setUp()</tt> i <tt>void tearDown()</tt>, które będą wywoływane odpowiednio przed i po wykonaniu każdego testu. Mogą być użyte do konstrukcji środowiska testowego i jego rozmontowania. Nie używałem tej możliwości, bo nie była ona potrzebna w tak prostym przykładzie.
</li><li> Bardzo często chcemy wykonać razem wszystkie testy zdefiniowane w jednej klasie. <tt>CppUnit</tt> dostarcza makr ułatwiających grupowanie wszystkich metod danej klasy w jeden <tt>TestSuite</tt>.
</li><li> Szkielet <tt>CppUnit</tt> oferuje poza <tt>CPPUNIT_ASSERT_EQUAL</tt> szereg innych makr ulatwiających pisanie testów.
</li><li> Stosunkowo łatwo można zmienić format wyświetlania wyników testów np. dodanie 
</li></ul>

<div class="geshifilter"><pre class="geshifilter-cpp">      runner.<span style="color: #00eeff;">setOutputter</span><span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">XmlOutputter</span><span style="color: #000000;">&#40;</span> 
                              &amp;runner.<span style="color: #00eeff;">result</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,
                              std::<span style="color: #0000dd;">cout</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;</pre></div>


<p>spowoduje wypisanie wyników testu w formacie XML.
</p>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_test_case.cpp">Max_test_case.cpp</a></td><td>1.54 KB</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_test_runner.cpp">Max_test_runner.cpp</a></td><td>1.84 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_test_caller.cpp">Max_test_caller.cpp</a></td><td>1.15 KB</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1241" class="section-2">
  <h1 class="book-heading">Klasy cech</h1>
  <h2>Wprowadzenie</h2>
<hr />
<br />

<p>Rozważmy próbę implementacji ogólnej funkcji sumowania elementów
tablicy (zob. D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i>, rozdz. 15).  Korzystając z wiadomości o
szablonach i konwencjach używanych w STL możemy napisać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  T total = T<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>;beg!&lt;nowiki&gt;=&lt;/nowiki&gt;end;++beg<span style="color: #000000;">&#41;</span>
    total +&lt;nowiki&gt;=&lt;/nowiki&gt; *beg;
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: sum1.cpp)
</p><p>
Przykład 5.1
</p>

<p>Ten prosty kod ma jednak co najmniej dwa problemy. Pierwszy związany
jest z linijką
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T total &lt;nowiki&gt;=&lt;/nowiki&gt; T<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>i wiąże się z ustaleniem zerowej wartości dla danego typu.  Powyższa
linijka oznacza, że zmienna <tt>total</tt> jest inicjalizowana
konstruktorem domyślnym klasy <tt>T</tt>. W przypadku typów wbudowanych
będzie to inicjalizacja wartością zerową, czyli tak jak tego
oczekujemy.  W przypadku innych typów możemy mieć tylko nadzieję, że
konstruktor defaultowy istnieje i robi to co trzeba :). Popatrzmy na
możliwe alternatywy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T total;</pre></div>

<p>W przypadku typów zdefiniowanych przez użytkownika wywoływany jest
defaultowy konstruktor (domyślny jeśli żaden inny nie jest zdefinowany). 
W przypadku typów wbudowanych wartość jest niekreślona!
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T total &lt;nowiki&gt;=&lt;/nowiki&gt; <span style="color: #0000dd;">0</span>;</pre></div>


<p>jest z kolei niepoprawne dla typów, na które nie ma rzutowania z liczb
całkowitych.
</p><p>Problem można ominąć jeżeli się zauważy, że dla niepustych zakresów
tzn. <tt>beg!=end</tt> nie potrzebujemy wcale wartości zerowej:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  T total= *beg;
  ++beg;
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
     total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>


<p>Jeśli jednak dopuszczamy podanie zakresu pustego, to funkcja powinna
zwrócić zero i problem powraca. 
</p><p>Drugi problem z przykładem 5.1 to typ zmiennej <tt>total</tt>. 
Popatrzmy na zastosowanie funkcji <tt>sum</tt>. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">char</span> name<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;@ @ @&quot;</span>;
<span style="color: #0000ff;">int</span> length=<span style="color: #0000dd;">strlen</span><span style="color: #000000;">&#40;</span>name<span style="color: #000000;">&#41;</span>;
cout&lt;&lt;sum<span style="color: #000000;">&#40;</span>name,&amp;name<span style="color: #000000;">&#91;</span>length<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>Programik powinien wypisać sumę wartości znaków w napisie
<tt>"name"</tt>. Łatwo sprawdzić że wypisuje znak o kodzie zero. Problem polega
na tym, że typ <tt>T</tt> niekoniecznie musi pomieścić wynik dodawania
elementów typu <tt>T</tt>. W tym przykładzie dodawanie znaków dało wynik
256 (co za niezwykły zbieg okoliczności), który już nie mieści się w
zakresie tego typu.
</p><p>Prostym rozwiązaniem jest dodanie dodatkowego parametru szablonu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename R,<span style="color: #0000ff;">typename</span> T&gt; R sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  R total = R<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: sum2.cpp)
</p><p>i wtedy zastosowanie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">cout&lt;&lt;sum&lt;int&gt;<span style="color: #000000;">&#40;</span>name,&amp;name<span style="color: #000000;">&#91;</span>length<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;</pre></div>

<p>da już oczekiwany wynik. Zaletą tego rozwiązania jest jego prostota i
duża elastyczność. Wadą - zwiększenie liczby parametrów szablonu, co
zawsze zwiększa złożoność kodu i możliwości popełnienia błędu, zwłaszcza, że typ <tt>R</tt> jest w większości przypadków określony przez
typ <tt>T</tt> i nie wnosi niezależnej informacji.
</p>

<h2>Klasy cech</h2>
<hr />
<br />

<p>Pomocą mogą służyć klasy cech: klasy, których funkcją jest dostarczanie
dodatkowych informacji o danym typie. W naszym przypadku możemy
zadeklarować szablon:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt;  <span style="color: #0000ff;">struct</span> sum_traits;</pre></div>

<p>i jego specjalizacje:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;char&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">int</span> sum_type; 
<span style="color: #000000;">&#125;</span>;
template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;int&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">long</span> <span style="color: #0000ff;">int</span> sum_type; 
<span style="color: #000000;">&#125;</span>;
template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;float&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">double</span> sum_type; 
<span style="color: #000000;">&#125;</span>;
template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;double&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">double</span> sum_type; 
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Szablon <tt>sum</tt> przerabiamy teraz na 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; 
<span style="color: #0000ff;">typename</span> sum_traits&lt;T&gt;::<span style="color: #00eeff;">sum_type</span> sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> sum_traits&lt;T&gt;::<span style="color: #00eeff;">sum_type</span> sum_type;
  sum_type total = sum_type<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: sum3.cpp)
</p><p>Wadą tego podejścia jest konieczność definiowania specjalizacji
szablonu <tt>sum_traits</tt> dla każdego typu, którego sumę będziemy
chcieli obliczyć. Można tego uniknąć definiując szablon ogólny
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt;  <span style="color: #0000ff;">struct</span> sum_traits <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> T sum_type;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>i możemy już wtedy użyć 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">complex&lt;double&gt; *c1,*c2;
sum<span style="color: #000000;">&#40;</span>c1,c2<span style="color: #000000;">&#41;</span>;</pre></div>

<p>bez dodatkowych definicji. To czy należy implementować uniwersalną
definicję klasy cech zależy od tego czy istnieje sensowna wartość
domyślna dla danej cechy. W naszym przypadku, definiując powyższy szablon,
zyskujemy na wygodzie ale tracimy na bezpieczeństwie, bo łatwiej jest teraz
wywołać funkcję <tt>sum</tt> z nieodpowiednim typem zmiennej <tt>total</tt>.
</p>

<h2>Cechy wartości</h2>
<hr />
<br />

<p>Możemy spróbować rozwiązać za pomocą klas cech również problem
inicjalizacji zmiennej <tt>total</tt>, definiując w każdej klasie
odpwiednią wartość zerową dla danego typu. Pytanie jak to zrobić?
Nasuwa się użycie stałych składowych statycznych:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;char&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">int</span>  sum_type;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> sum_type zero = <span style="color: #0000dd;">0</span>; 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Sęk w tym, że standard zezwala na incijalizowanie w klasie
statycznych stałych jedynie dla typów całkowitoliczbowych. Taka sama
konstrucja dla <tt>double</tt> już nie jest możliwa.
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;float&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">double</span>  sum_type;
<span style="color: #0000ff;">static</span>  <span style="color: #0000ff;">const</span> sum_type zero = <span style="color: #0000dd;">0.0</span>; niedozwolone
<span style="color: #000000;">&#125;</span>;</pre></div>



<p>Inicjalizator 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">typename</span> sum_traits&lt;float&gt;::<span style="color: #00eeff;">sum_type</span> 
sum_traits&lt;float&gt;::<span style="color: #00eeff;">zero</span> = <span style="color: #0000dd;">0.0</span>;</pre></div>

<p>musi być umieszczony w kodzie źródłówym. Po pierwsze nie bardzo wiadomo
gdzie go umieścić (nie może być w pliku nagłówkowym, bo łamało by to
zasadę jednokrotnej definicji). Po drugie kompilator najprawdopodobniej
nie umiałby powiązać nazwy stałej i jej wartości w czasie kompilacji. 
</p><p>Inną możliwością jest użycie funkcji statycznych rozwijanych w miejscu
wywołania:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;char&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">int</span>  sum_type;
<span style="color: #0000ff;">static</span>  sum_type zero<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">0</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;
template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;float&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">double</span>  sum_type;
<span style="color: #0000ff;">static</span>  sum_type zero<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">0.0</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Odpowiadający temu podejściu kod  funkcji <tt>sum</tt> bedzie wyglądał następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; 
<span style="color: #0000ff;">typename</span> sum_traits&lt;T&gt;::<span style="color: #00eeff;">sum_type</span> sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> sum_traits&lt;T&gt;::<span style="color: #00eeff;">sum_type</span> sum_type;
  sum_type total = sum_traits&lt;T&gt;::<span style="color: #00eeff;">zero</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>

<p>Dobry kompilator powinien bez trudu rozwinąć definicję funkcji
i podstawić odpowiednią wartość bezpośrednio w kodzie.
</p>

<h2>Parametryzacja klasami cech</h2>
<hr />
<br />

<p>Opisana powyżej implementacja funkcji <tt>sum</tt> i związanej z nią klasy
<tt>sum_traits</tt> jest mało elastyczna. Wybierając typ przekazanej
tablicy wybieramy typ zmiennej <tt>total</tt>. Może się jednak zdażyć, że
chcemy sumować <tt>int</tt> we <tt>float</tt>, a <tt>float</tt> we <tt>float</tt>. 
</p><p>Możemy dodać dodatkowy parametr do szablonu, który będzie definiował
wybraną klasę cech. Ale to jest powrót do rozwiązania odrzuconego na
początku. Rozwiązaniem może być uczynienie tego parametru parametrem
domyślnym, tak, aby nie trzeba było podawać go jawnie w typowych
przypadkach. Jest to bardzo dobre rozwiązanie w przypadku użycia klas
cech w szablonach klas. Problem w tym, że szablony funkcji nie
dopuszczają stosowania parametrów domyślnych.
Możemy to obejść za pomocą przeciążenia definiując:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename Traits,<span style="color: #0000ff;">typename</span> T &gt; 
<span style="color: #0000ff;">typename</span> Traits::<span style="color: #00eeff;">sum_type</span> sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Traits::<span style="color: #00eeff;">sum_type</span> sum_type;
  sum_type total = sum_type<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span>;
&nbsp;
template&lt;typename T &gt; 
<span style="color: #0000ff;">typename</span> sum_traits&lt;T&gt;::<span style="color: #00eeff;">sum_type</span> sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">return</span> sum&lt;sum_traits&lt;T&gt;, T&gt;<span style="color: #000000;">&#40;</span>beg,end<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>
&nbsp;
<span style="color: #0000ff;">struct</span> char_sum <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">char</span> sum_type;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: sum4.cpp)
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">char</span> name<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;@ @ @&quot;</span>;
<span style="color: #0000ff;">int</span> length=<span style="color: #0000dd;">strlen</span><span style="color: #000000;">&#40;</span>name<span style="color: #000000;">&#41;</span>;
&nbsp;
 cout&lt;&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>sum<span style="color: #000000;">&#40;</span>name,&amp;name<span style="color: #000000;">&#91;</span>length<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
 cout&lt;&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>sum&lt;char_sum&gt;<span style="color: #000000;">&#40;</span>name,&amp;name<span style="color: #000000;">&#91;</span>length<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
 cout&lt;&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>sum&lt;char&gt;<span style="color: #000000;">&#40;</span>name,&amp;name<span style="color: #000000;">&#91;</span>length<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: sum4.cpp)
</p>

<h2>iterator_traits</h2>
<hr />
<br />


<p>Na koniec spróbujmy uogólnić funkcję <tt>sum</tt>, aby działała nie tylko
ze wskaźnikami, ale i iteratorami. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename IT&gt; sum<span style="color: #000000;">&#40;</span>IT *beg,IT *end<span style="color: #000000;">&#41;</span>;</pre></div>

<p>Widać, że tu użycie klas cech jest już niezbędne, musimy bowiem
dowiedzieć się na obiekty jakiego typu wskazuje iterator. Nie można do
tego celu użyć typów stowarzyszonych <tt>IT::value_type</tt>, bo jako
iterator może zostać podstawiony zwykły wskaźnik.  Dlatego w STL
istnieje klasa <tt>iterator_traits</tt>, definiująca podstawowe typy dla
każdego rodzaju iteratora. Korzystając z tej klasy można zdefiniować
ogólny szalon funkcji <tt>sum</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename II&gt; 
<span style="color: #0000ff;">typename</span> 
sum_traits&lt;typename iterator_traits&lt;II&gt;::<span style="color: #00eeff;">value_type</span>&gt;::<span style="color: #00eeff;">sum_type</span> 
sum<span style="color: #000000;">&#40;</span>II beg,II *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> iterator_traits&lt;IT&gt;::<span style="color: #00eeff;">value_type</span> value_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> sum_traits&lt;value_type&gt;::<span style="color: #00eeff;">sum_type</span> sum_type;
  sum_type total = sum_traits&lt;value_type&gt;::<span style="color: #00eeff;">zero</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>


<p>Zanim omówię klasę <tt>iterator_trais</tt> podam rozwiązanie zastosowane w
STL. Tam funkcja nazywa się <tt>accumulate</tt> i jest zaimplementowana
następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator, <span style="color: #0000ff;">class</span> T&gt;
T accumulate<span style="color: #000000;">&#40;</span>InputIterator first, InputIterator last, T init<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      <span style="color: #0000ff;">for</span> <span style="color: #000000;">&#40;</span>; first != last; ++first<span style="color: #000000;">&#41;</span>
        init = init + *first;
      <span style="color: #0000ff;">return</span> init;
    <span style="color: #000000;">&#125;</span></pre></div>


<p>Przykład 5.2
</p>

<p>Dodanie dodatkowego parametru wywołania funkcji rozwiązuje za jednym
zamachem oba nasze problemy: parametr ten dostarcza zarówno typu,
jak i wartości początkowej dla zmiennej sumującej.  Są jednak inne
algorytmy w STL, które wymagają więcej informacji o iteratorze i muszą
je pobrać za pomocą <tt>iterator_traits</tt>. 
</p><p>Dla iteratorów nie będących wskaźnikami <tt>iterator_traits</tt> po prostu
przepisują ich typy stowarzyszone: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class Iterator&gt;
  <span style="color: #0000ff;">struct</span> iterator_traits <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Iterator::<span style="color: #00eeff;">iterator_category</span> iterator_category;
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Iterator::<span style="color: #00eeff;">value_type</span>        value_type;
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Iterator::<span style="color: #00eeff;">difference_type</span>   difference_type;
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Iterator::<span style="color: #00eeff;">pointer</span>           pointer;
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Iterator::<span style="color: #00eeff;">reference</span>         reference;
  <span style="color: #000000;">&#125;</span>;</pre></div>


<p>Dla typów wskaźnikowych jest podana odpowiednia specjalizacja. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T&gt;
  <span style="color: #0000ff;">struct</span> iterator_traits&lt;T*&gt; <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">typedef</span> random_access_iterator_tag iterator_category;
    <span style="color: #0000ff;">typedef</span> T                          value_type;
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">ptrdiff_t</span>                  difference_type;
    <span style="color: #0000ff;">typedef</span> T*                         pointer;
    <span style="color: #0000ff;">typedef</span> T&amp;                         reference;
  <span style="color: #000000;">&#125;</span>;</pre></div>

<p>Widać więc, że każdy iterator nie będący wskaźnikiem musi mieć
zdefiniowane odpowiednie typy stowarzyszone. Ułatwia to szablon klasy
<tt>iterator</tt>, z którego można dziedziczyć:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span>
template&lt;class Category, <span style="color: #0000ff;">class</span> T, <span style="color: #0000ff;">class</span> Distance = <span style="color: #0000ff;">ptrdiff_t</span>,
<span style="color: #0000ff;">class</span> Pointer = T*, <span style="color: #0000ff;">class</span> Reference = T&amp;&gt;
<span style="color: #0000ff;">struct</span> iterator <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> T value_type;
<span style="color: #0000ff;">typedef</span> Distance difference_type;
<span style="color: #0000ff;">typedef</span> Pointer pointer;
<span style="color: #0000ff;">typedef</span> Reference reference;
<span style="color: #0000ff;">typedef</span> Category iterator_category;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Na uwagę zasługuje typ <tt>iterator_category</tt>. Ten typ służy do
automatycznego wyboru odpowiednich funkcji w oparciu o kategorię
iteratora. Kategorie odpowiadają konceptom iteratorów i są
reprezentowane przez puste klasy. W STL zdefiniowano pięć kategorii  
iteratorów:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">struct</span> input_iterator_tag <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">struct</span> output_iterator_tag <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">struct</span> forward_iterator_tag: <span style="color: #0000ff;">public</span> input_iterator_tag <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">struct</span> bidirectional_iterator_tag: <span style="color: #0000ff;">public</span> forward_iterator_tag <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">struct</span> random_access_iterator_tag: <span style="color: #0000ff;">public</span> bidirectional_iterator_tag <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Aby zilustrować zastosowanie typu <tt>iterator_category</tt> przedstawię
implementację funkcji <tt>distance()</tt>, która oblicza odległość pomiędzy
dwoma iteratorami. Potrzeba użycia <tt>iterator_category</tt> bierze się
stąd, że dla iteratorów o dostępie swobodnym możemy policzyć ją
bezpośrednio przez odejmowanie: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class _RandomAccessIterator&gt;
<span style="color: #0000ff;">inline</span> 
<span style="color: #0000ff;">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::<span style="color: #00eeff;">difference_type</span>
__distance<span style="color: #000000;">&#40;</span>_RandomAccessIterator __first, 
           _RandomAccessIterator __last,
             random_access_iterator_tag<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">return</span> __last - __first;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Dla reszty musimy po kolei zwiekszać
jeden iterator aż osiągniemy drugi: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class _InputIterator&gt;
<span style="color: #0000ff;">inline</span> 
<span style="color: #0000ff;">typename</span> iterator_traits&lt;_InputIterator&gt;::<span style="color: #00eeff;">difference_type</span>
__distance<span style="color: #000000;">&#40;</span>_InputIterator __first, 
           _InputIterator __last, 
             input_iterator_tag<span style="color: #000000;">&#41;</span>
<span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typename</span> iterator_traits&lt;_InputIterator&gt;::<span style="color: #00eeff;">difference_type</span> __n = <span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">while</span> <span style="color: #000000;">&#40;</span>__first != __last<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    ++__first; ++__n;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">return</span> __n;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Do wyboru pomiędzy tymi dwoma
implementacjami służy właśnie <tt>iterator_category</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class _InputIterator&gt;
<span style="color: #0000ff;">inline</span> 
<span style="color: #0000ff;">typename</span> iterator_traits&lt;_InputIterator&gt;::<span style="color: #00eeff;">difference_type</span>
distance<span style="color: #000000;">&#40;</span>_InputIterator __first, _InputIterator __last<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> 
     <span style="color: #0000ff;">typename</span> 
     iterator_traits&lt;_InputIterator&gt;::<span style="color: #00eeff;">iterator_category</span> 
    _Category;
&nbsp;
  <span style="color: #0000ff;">return</span> __distance<span style="color: #000000;">&#40;</span>__first, __last, _Category<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<h2>numeric_limits</h2>
<hr />
<br />

<p>Przykładem klasy cech zawartej w standardzie C++ jest szablon 
<tt>numeric_limits</tt>, który zastępuje używane w C makra, zdefiniowane
w pliku <tt>limits.h</tt>. Szablon <tt>numeric_limits</tt> posiada specjalizację dla 
każdego typu podstawowego wbudowanego (zob. tab. 5.1]) i zawiera informację na temat różnych cech ich implementacji (zob. tab. 5.2]).
Warto zwrócić uwagę na następującą konstrukcję: szablon
<tt>numeric_limits</tt> definiuje stałą logiczną <tt>is_specialised</tt>.
Domyślnie jest ona równa <tt>false</tt>. Każda specjalizacja szablonu
ustawia ją na <tt>true</tt>. W ten sposób stała
<tt>std::numeric_limits<T>::is_specialised</t></tt> mówi nam czy dany typ jest
opisany przez <tt>numeric_limits</tt> czy nie.
</p><p><span id="tab.5.1"></span>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span>
template&lt;class T&gt; <span style="color: #0000ff;">class</span> numeric_limits;
<span style="color: #0000ff;">enum</span> float_round_style;
<span style="color: #0000ff;">enum</span> float_denorm_style;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;bool&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;char&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;signed char&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;unsigned char&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;wchar_t&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;short&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;int&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;long&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;unsigned short&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;unsigned int&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;unsigned long&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;float&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;double&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;long double&gt;;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Tablica 5.1. Specjalizacje szablonu <tt>numeric_limits</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span>
template&lt;class T&gt; <span style="color: #0000ff;">class</span> numeric_limits <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_specialized = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> T min<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T max<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> digits = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> digits10 = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_signed = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_integer = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_exact = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> radix = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> T epsilon<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T round_error<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> min_exponent = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> min_exponent10 = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> max_exponent = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> max_exponent10 = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> has_infinity = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> has_quiet_NaN = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> has_signaling_NaN = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> float_denorm_style has_denorm = denorm_absent;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> has_denorm_loss = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> T infinity<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T quiet_NaN<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T signaling_NaN<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T denorm_min<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_iec559 = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_bounded = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_modulo = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> traps = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> tinyness_before = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> float_round_style round_style = round_toward_zero;
<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Tablica 5.2. Szablon <tt>numeric_limits</tt>
</p>
<table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sum1.cpp">Sum1.cpp</a></td><td>284 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sum2.cpp">Sum2.cpp</a></td><td>294 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sum3.cpp">Sum3.cpp</a></td><td>692 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sum4.cpp">Sum4.cpp</a></td><td>975 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1242" class="section-2">
  <h1 class="book-heading">Funkcje typów i inne sztuczki</h1>
  <h2>Wprowadzenie</h2>
<hr />

<p>Funkcja jest podstawowym pojęciem w większości języków programowania,
z którym wszyscy jesteśmy dobrze obeznani.  Funkcje przyjmują zestaw
argumentów i zwracają jakąś wartość. Szablony dają ciekawą możliwość
interpretowania ich jako funkcji typów: funkcje których argumentem są
typy, a wartością zwracaną typ lub jakaś wartość. Weźmy dla przykładu
szablon <tt>sum_traits</tt> z poprzedniego modułu. Można interpretować go
jako dwie funkcje przyjmujące typ poprzez  parametr szablonu i zwracające
albo wartość
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">sum_traits&lt;int&gt;::<span style="color: #00eeff;">zero</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>albo typ
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">sum_traits&lt;int&gt;::<span style="color: #00eeff;">sum_type</span></pre></div>

<p>Takie funkcje możemy definiować poprzez wypisanie wszystkich
specjalizacji pełnych jak w przypadku <tt>sum_traits</tt> albo przez
wykorzystanie specjalizacji częściowych, jak np. dla
<tt>iterator_traits</tt>. Najciekawsza możliwość to jednak pisanie
"obliczalnego kodu" takich funkcji, przy czym "obliczenia" dokonują
się w czasie kompilacji. Przykłady takich funkcji zostaną podane na
tym wykładzie. W realnych zastosowaniach wykorzystuje się kombinację
wszystkich powyższych możliwości.
</p><p>Korzystając z szablonów można również uogólnić pojęcie listy i
definiować listy typów. Umożliwiają one między innymi indeksowany
dostęp do swoich składowych, przekazywanie zmiennej liczby parametrów
typu do szablonów i automatyczną generację hierarchii klas opartych na
tych typach. Listy typów omówię w drugiej części tego wykładu.
</p>

<h2>Funkcje typów</h2>
<hr />
<br />

<h3>If-Then-Else</h3>

<p>Zacznę od przydatnej konstrukcji implementującej możliwość wyboru
jednego z dwu typów na podstawie stałej logicznej (typu <tt>bool</tt>).
Dokonujemy tego za pomocą szablonu podstawowego 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;bool flag,<span style="color: #0000ff;">typename</span> T1,<span style="color: #0000ff;">typename</span> T2&gt; <span style="color: #0000ff;">struct</span> If_then_else <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> T1 Result; 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>który będzie podstawiany dla wartości <tt>flag=true</tt> i jego
specjalizacji dla wartości <tt>flag=false</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T1,<span style="color: #0000ff;">typename</span> T2&gt; 
<span style="color: #0000ff;">struct</span> If_then_else&lt;false,T1,T2&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> T2 Result; 
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Teraz możemy go np. wykorzystać do wybrania większego z dwu typów:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T1,typenameT2&gt; <span style="color: #0000ff;">struct</span> Greater_then <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> If_then_else&lt;sizeof<span style="color: #000000;">&#40;</span>T1<span style="color: #000000;">&#41;</span>&gt;sizeof<span style="color: #000000;">&#40;</span>T2<span style="color: #000000;">&#41;</span>,T1,T2&gt;::<span style="color: #00eeff;">result</span>
 result;
<span style="color: #000000;">&#125;</span>;</pre></div>

<h3>Sprawdzanie czy dany typ jest klasą</h3>
<br />

<p>Następny przykład to szablon służący do sprawdzania czy dany typ jest
klasą. Wykorzystamy w tym celu operator <tt>sizeof()</tt> i przeciążane
szablony funkcji razem z zasadą "nieudane podstawienie nie jest
błędem" (zob. wykład 3.5). Potrzebujemy więc wyrażenia, które nie ma sensu
dla dla typów nie będacych klasami. Takim wyrażeniem będzie <tt>int
C::*</tt> oznaczające wskaźnik do pola składowego klasy <tt>C</tt> typu
<tt>int</tt>.  Cały szablon wygląda następująco.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> Is_class <span style="color: #000000;">&#123;</span>
  <span style="color: #ff0000;">//najpierw definiujemy dwa typy różniące sie rozmiarem</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">char</span> one;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">struct</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">char</span> c<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span> two;
  <span style="color: #ff0000;">//teraz potrzebne bedą dwa przeładowane szablony</span>
  template&lt;typename U&gt; <span style="color: #0000ff;">static</span> one test<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> U::<span style="color: #00eeff;">*</span><span style="color: #000000;">&#41;</span>; 
  template&lt;typename U&gt; <span style="color: #0000ff;">static</span> two test<span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span>;
  <span style="color: #ff0000;">//to który szablon został wybrany sprawdzamy poprzez sprawdzenie rozmiaru zwracanego typu</span>
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>yes = <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>test&lt;T&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>one<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: is_class.cpp)
</p><p>Operator <tt>sizeof(test<T>(0))</t></tt> musi rozpoznać typ zwracany przez
funkcję <tt>test<T>(0)</t></tt>. W tym celu uruchamiany jest mechanizm
rozstrzygania przeciążenia. Jeśli typ <tt>T</tt> nie jest klasą to próba
podstawienia pierwszej funkcji spowoduje powstanie niepoprawnej
konstrukcji <tt>T::*</tt> i podstawienie się nie powiedzie. Druga funkcja
ma argumenty pasujące do czegokolwiek więc jej podstawienie zawsze się
powiedzie.  Druga funkcja zwraca typ o rozmiarze większym od rozmiaru
typu <tt>one</tt> więc stała <tt>yes</tt> otrzyma wartość <tt>false</tt>.
</p><p>Jeśli typ <tt>T</tt> jest klasą to <tt>int T::*</tt> jest poprawne (na tym
etapie nie jest istotne czy klasa w ogóle posiada taką składową) i
mechanizm rozstrzygania będzie pracował dalej, sprawdzając czy argument
wywołania jest zgodny z <tt>int T::*</tt>. W tym przypadku jest to zero,
które może być użyte jako wskaźnik, więc podstawienie się powiedzie.
Oczywiście drugie podstawienie też by się powiodło
ale jest mniej specjalizowane. W wyniku zmienna <tt>yes</tt> otrzyma
wartość <tt>true</tt>.
Warto zauważyć, że gdybyśmy zamiast zera podstawili jako argument
funkcji <tt>test<T>(int T::*)</t></tt> jakąś inna liczbę całkowitą to podstawienie
się nie powiedzie i zawsze otrzymamy fałsz dla zmiennej <tt>yes</tt>.
</p>

<h3>Sprawdzanie możliwości rzutowania</h3>
<br />

<p>Kolejny przykład wykorzystuje tę samą technikę w celu stwierdzenia czy
jeden z typów można rzutować na drugi.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> U&gt; <span style="color: #0000ff;">class</span> Is_convertible <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">char</span> one;
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">struct</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">char</span> c<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span> two;
&lt;i&gt;tym razem korzystamy ze zwykłych przeciążonych funkcji&lt;/i&gt;
<span style="color: #0000ff;">static</span> one test<span style="color: #000000;">&#40;</span>U<span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> two test<span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T makeT<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
<span style="color: #0000ff;">public</span>: <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>yes = <span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>test<span style="color: #000000;">&#40;</span>makeT<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>one<span style="color: #000000;">&#41;</span>,
  same_type=<span style="color: #0000ff;">false</span> <span style="color: #000000;">&#125;</span>; <span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: convertible.cpp)
</p><p>Teraz sprawdzane są dwie przeciążone funkcje.
<tt>makeT()</tt> zwraca obiekt typu <tt>T</tt> więc jeśli typ <tt>T</tt> może być
rzutowany na <tt>U</tt> to wybrane zostanie dopasowanie pierwszej funkcji
jako bardziej wyspecjalizowanej. Funkcja <tt>makeT()</tt> została użyta
zamiast np. <tt>T()</tt>, bo konstruktor defaultowy może dla tego typu nie
istnieć. Dodatkowa specjalizacja 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> Is_convertible&lt;T,T&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>yes = <span style="color: #0000ff;">true</span>,
      same_type=<span style="color: #0000ff;">true</span> <span style="color: #000000;">&#125;</span>; 
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: convertible.cpp)
</p><p>pozwala nam  użyć tej klasy do identyfikacji identycznych typów.
</p>

<h3>Zdejmowanie kwalifikatorów</h3>
<br />

<p>Każdy typ w C++ może być opatrzony dodatkowymi kwalifikatorami, takimi
jak <tt>const</tt> czy <tt>&</tt> (referencja). Mając dany typ <tt>T</tt> dodanie
do niego kwalifikatora jest proste. Z pozoru jednak może się to wiązać
z możliwością wygenerowania niepoprawnych podwójnych kwalifikatorów
np. <tt>const const T</tt>. Okazuje się jednak, że o ile 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> i =<span style="color: #0000dd;">0</span>;</pre></div>

<p>jest konstrukcją nieprawdłową, to w przypadku argumentów szablonu
nadmiarowe kwalifikatory zostaną zignorowane. Wyrażenie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> const_const <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">const</span> T t = T<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;
const_const&lt;const int&gt; a;</pre></div>

<p>jest poprawne i pole <tt>t</tt> będzie typu <tt>const int</tt>. To samo tyczy
się referencji. Pomimo tych udogodnień może być konieczna operacja
usunięcia jednego lub obydwu kwalifikatorów i uzyskanie gołego typu
podstawowego. W tym celu możemy zdefiniować szablon (zob. D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i>, rozdz. 17)
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Strip <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> T arg_t;
  <span style="color: #0000ff;">typedef</span> T striped_t;
  <span style="color: #0000ff;">typedef</span> T base_t;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">const</span> T   const_type;
&nbsp;
  <span style="color: #0000ff;">typedef</span> T&amp;        ref_type;
  <span style="color: #0000ff;">typedef</span> T&amp;        ref_base_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">const</span> T &amp; const_ref_type;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>i jego specjalizację dla typów z kwalifikatorem <tt>const</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Strip&lt; T const&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">const</span> T arg_t;
  <span style="color: #0000ff;">typedef</span>       T striped_t;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Strip&lt;T&gt;::<span style="color: #00eeff;">base_t</span>  base_t;
  <span style="color: #0000ff;">typedef</span> T <span style="color: #0000ff;">const</span>   const_type;
&nbsp;
  <span style="color: #0000ff;">typedef</span> T <span style="color: #0000ff;">const</span> &amp; ref_type;
  <span style="color: #0000ff;">typedef</span> T &amp;       ref_base_type;
  <span style="color: #0000ff;">typedef</span> T <span style="color: #0000ff;">const</span> &amp; const_ref_type;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>i dla  referencji
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Strip&lt;T&amp;&gt; <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">typedef</span> T&amp; arg_t;
  <span style="color: #0000ff;">typedef</span> T  striped_t;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Strip&lt;T&gt;::<span style="color: #00eeff;">base_t</span>  base_t;
  <span style="color: #0000ff;">typedef</span> base_t <span style="color: #0000ff;">const</span>    const_type;
&nbsp;
  <span style="color: #0000ff;">typedef</span> T               ref_type;
  <span style="color: #0000ff;">typedef</span> base_t &amp;        ref_base_type;
  <span style="color: #0000ff;">typedef</span> base_t <span style="color: #0000ff;">const</span> &amp;  const_ref_type;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: strip.cpp)
</p><p>Proszę zwrócić uwagę na  konstrukcję 
</p>


<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Strip&lt;T&gt;::<span style="color: #00eeff;">base_t</span>  base_t;</pre></div>

<p>Ponieważ typ <tt>T</tt> może oznaczać typ kwalifikowany za pomocą
<tt>const</tt>, wykorzystujemy rekurencyjne odwołanie aby uzyskać typ
podstawowy. Jest to przykład techniki metaprogramowania, która 
bardziej szczegółowo będzie omówiona w wykładzie 8.
</p>

<h3>Cechy typów</h3>
<br />

<p>Jednym z rodzajów klas cech (omawianych w poprzednim wykładzie) są cechy typów. Nie są one specjalizowane do jednego konkretnego celu, ale służą do dostarczania ogólnych informacji na temat dowolnych typów. Wymieniamy je w tym wykładzie, ponieważ do ich implementacji często stosowane są różne techniki opisane powyżej. Bardzo dobry szczegółowy opis implementacji cech typów znajduje się w D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i>. Gotową implementację typu <tt>boost::type_traits</tt> można znaleźć w repozytorium <tt>boost</tt>. Inna - to biblioteka <tt>Loki</tt> opisana w A. Alexandrescu <i>"Nowoczesne projektowanie w C++"</i>.
</p>

<h3>Cechy promocji</h3>
<br />

<p>Załóżmy, że postanowiliśmy zaimplementować możliwość 
dodawania wektorów: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; std::<span style="color: #00eeff;">vector</span>&lt;T&gt; 
operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> std::<span style="color: #00eeff;">vector</span>&lt;T&gt;  &amp;a,
           <span style="color: #0000ff;">const</span> std::<span style="color: #00eeff;">vector</span>&lt;T&gt;  &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>a.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==b.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
  std::<span style="color: #00eeff;">vector</span>&lt;T&gt; res<span style="color: #000000;">&#40;</span>a<span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;a.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;++i<span style="color: #000000;">&#41;</span>
    res<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>+=b<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;
&nbsp;
  <span style="color: #0000ff;">return</span> res;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: promote.cpp)
</p><p>Teraz polecenia 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">vector</span>&lt;double&gt; x<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>;
std::<span style="color: #00eeff;">vector</span>&lt;double&gt; y<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>;
&nbsp;
x+y;</pre></div>

<p>( Źródło: promote.cpp)
</p><p>skompilują  się, ale 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">vector</span>&lt;int&gt;    l<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>;
&nbsp;
x+l;</pre></div>
<p>już nie. Ponieważ dodawanie <tt>double</tt> do <tt>int</tt> jest dozwolone, to
rozsądne by było aby nasza implemenatacja też na to zezwalała. Przerabiamy 
więc nasz <tt>operator+()</tt> (lub dodajemy przeciążenie):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> U&gt; std::<span style="color: #00eeff;">vector</span>&lt;T&gt; 
operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> std::<span style="color: #00eeff;">vector</span>&lt;T&gt;  &amp;a,
           <span style="color: #0000ff;">const</span> std::<span style="color: #00eeff;">vector</span>&lt;U&gt;  &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>a.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==b.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
  std::<span style="color: #00eeff;">vector</span>&lt;T&gt; res<span style="color: #000000;">&#40;</span>a<span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;a.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;++i<span style="color: #000000;">&#41;</span>
    res<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>+=b<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;
&nbsp;
  <span style="color: #0000ff;">return</span> res;
<span style="color: #000000;">&#125;</span></pre></div>


<p>Kłopot z tą definicją to typ zwracany, który zależy teraz od
kolejności składników dodawania, a nie od ich typu. Abu rozwiązać ten
problem zdefiniujemy sobie klasę cech, która będzie określała typ
wyniku na podstawie typu składników. Wybierzemy następującą strategię:
jeśli typy mają różny rozmiar to wybieramy typ większy, jeżeli mają
ten sam rozmiar to liczymy na specjalizacje:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T1,<span style="color: #0000ff;">typename</span> T2&gt; <span style="color: #0000ff;">struct</span> Promote <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> 
        If_then_else&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>T1<span style="color: #000000;">&#41;</span> &gt; <span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>T2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>,
                     T1,
                     <span style="color: #0000ff;">typename</span> If_then_else&lt; <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>T1<span style="color: #000000;">&#41;</span>&lt; <span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>T2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>,
                                           T2,
                                           void&gt;::<span style="color: #00eeff;">Result</span> &gt;::<span style="color: #00eeff;">Result</span> Result;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: promote.cpp)
</p><p>Dla identycznych typów wynik jest jasny (choć jak przekonuje nas
przykład 5.1 typ sumy nie musi być typem składników),
ale niemniej musimy go zdefiniować:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Promote&lt;T,T&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> T Result;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: promote.cpp)
</p><p>Resztę musimy definiować ręcznie korzystając ze specjalizacji pełnych.
Można to sobie uprościć definiując makro
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#define MK_PROMOTE(T1,T2,Tr)               \</span>
    template&lt;&gt; <span style="color: #0000ff;">class</span> Promotion&lt;T1, T2&gt; <span style="color: #000000;">&#123;</span>   \
      <span style="color: #0000ff;">public</span>:                              \
        <span style="color: #0000ff;">typedef</span> Tr Result;                 \
    <span style="color: #000000;">&#125;</span>;                                     \
                                           \
    template&lt;&gt; <span style="color: #0000ff;">class</span> Promotion&lt;T2, T1&gt; <span style="color: #000000;">&#123;</span>   \
      <span style="color: #0000ff;">public</span>:                              \
        <span style="color: #0000ff;">typedef</span> Tr Result;                 \
    <span style="color: #000000;">&#125;</span>;
&nbsp;
MK_PROMOTE<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">bool</span>, <span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>
MK_PROMOTE<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">bool</span>, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>
MK_PROMOTE<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">bool</span>, <span style="color: #0000ff;">signed</span> <span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span></pre></div>


<p>( Źródło: promote.cpp)
</p>
<h2>Listy typów</h2>
<hr />
<br />

<h3>Definicja</h3>
<br />

<p>Listy typów są ciekawą konstrukcją zaproponowaną przez Alexandrescu.
Ich szczegółowy opis i zastosowania można znaleźć w A. Alexandrescu <i>"Nowoczesne projektowanie w C++"</i>. Definicja listy typów opiera się na
rekurencyjnej implementacji listy znanej miedzy innymi z <tt>Lisp-a</tt>: lista
składa się z pierwszego elementu (głowy) i reszty (ogona), co możemy
zapisać jako:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename H,<span style="color: #0000ff;">typename</span> T&gt; <span style="color: #0000ff;">struct</span> Type_list <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> H head;
<span style="color: #0000ff;">typedef</span> T tail;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: typelist.h)
</p><p>Do tego potrzebna nam jest jeszcze definicja pustego typu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Null_type <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>jako znacznika końca listy. I tak:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Type_list&lt;int,Null_type&gt;</pre></div>

<p>oznacza jednoelementową listę <tt>(int)</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Type_list&lt;double,Type_list&lt;int,Null_type&gt; &gt;</pre></div>

<p>listę dwuelemntową <tt>(double,int)</tt> i tak dalej.
</p>

<h3>Length</h3>
<br />

<p>Ta prosta struktura daje zadziwiająco wiele możliwości. Na początek
napiszemy funkcję zwracającą długość listy. W tym celu skorzystamy z
rekurencyjnej definicji: długość listy to jeden plus długość ogona,
długość listy pustej wynosi zero. Tę definicję implementujemy następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Length;
template&lt;&gt; <span style="color: #0000ff;">struct</span> Length&lt;Null_type&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>value = <span style="color: #0000dd;">0</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
&nbsp;
template&lt;typename H,<span style="color: #0000ff;">typename</span> T&gt; <span style="color: #0000ff;">struct</span> Length&lt;Type_list&lt;H,T&gt; &gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>value = <span style="color: #0000dd;">1</span> + Length&lt;T&gt;::<span style="color: #00eeff;">value</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: typelist.h)
</p>

<h3>Indeksowanie</h3>
<hr />

<p>Tą samą techniką możemy zaimplementować indeksowany dostęp do
elementów listy.  Znów korzystamy z rekurencji: element o indeksie
<tt>i</tt> to albo głowa (jeśli <tt>i==0</tt>), albo element o indeksie <tt>i-1</tt> w jej ogonie.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">size_t</span> I&gt; <span style="color: #0000ff;">struct</span> At;
&nbsp;
template&lt;typename T,<span style="color: #0000ff;">typename</span> H&gt; <span style="color: #0000ff;">struct</span> At&lt;T,<span style="color: #0000dd;">0</span>&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> T result;
<span style="color: #000000;">&#125;</span>;
&nbsp;
template&lt;typename T,<span style="color: #0000ff;">typename</span> H&gt; <span style="color: #0000ff;">struct</span> At&lt;T,I&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> At&lt;H,I<span style="color: #0000dd;">-1</span>&gt;::<span style="color: #00eeff;">result</span> result;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: typelist.h)
</p>

<h3>Generowanie switch-a</h3>
<br />

<p>W bibliotece <tt>boost</tt> jest zaimplementowana klasa <tt>any</tt>, której obiekty
mogą reprezentować dowolną wartość (zob. boost). Żeby taką wartość odczytać musimy użyć odpowiedniej konkretyzacji szablonu  funkcji <tt>any_cast</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">boost::<span style="color: #00eeff;">any</span> val;
cout&lt;&lt;any_cast&lt;int&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;endl;</pre></div>

<p>Jeśli w szablonie podstawimy nie ten typ co trzeba, to otrzymamy
wyjątek. Chcemy teraz napisać funkcję, która drukuje wartości typu
<tt>any</tt>, przy czym wiemy, że przechowywane są w nich wartości tylko
kilku wybranych typów (np. <tt>int</tt>, <tt>double</tt>, <tt>string</tt>).
Ponieważ <tt>any</tt> udostępnia informację o typie przechowywanej w niej
wartości moglibyśmy taką funkcję <tt>print_any()</tt> zaimplementować
następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">print_any<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">ostream</span> &amp;of,boost::<span style="color: #00eeff;">any</span> val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>val.<span style="color: #00eeff;">type</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000ff;">typeid</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>
       of&lt;&lt;any_cast&lt;int&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
     <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> val.<span style="color: #00eeff;">type</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000ff;">typeid</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>
       of&lt;&lt;any_cast&lt;double&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
     <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> val.<span style="color: #00eeff;">type</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000ff;">typeid</span><span style="color: #000000;">&#40;</span>string<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>
       of&lt;&lt;any_cast&lt;string&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
     <span style="color: #0000ff;">else</span> 
       of&lt;&lt;<span style="color: #666666;">&quot;unsuported type&quot;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;       
<span style="color: #000000;">&#125;</span></pre></div>

<p>Sprobujemy teraz zaimplementować to samo za pomocą list typów, dodatkowo
zażądamy aby móc drukować również wartości typu <tt>vector<T></t></tt>, gdzie
<tt>T</tt> jest typem z listy.
</p><p>Jak zwykle musimy sformułować problem rekurencyjnie: 
sprawdzamy czy typ <tt>val</tt> jest typem głowy listy; jeśli tak to drukujemy,
jeśli nie to próbujemy drukować <tt>val</tt> używając ogona listy. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">void</span> print_val<span style="color: #000000;">&#40;</span>std:ostream &amp;of,boost::<span style="color: #00eeff;">any</span> val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> T::<span style="color: #00eeff;">Head</span> Head;
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> T::<span style="color: #00eeff;">Tail</span> Tail;
&nbsp;
<span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>val.<span style="color: #00eeff;">type</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000ff;">typeid</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
           of&lt;&lt;any_cast&lt;Head&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>; 
         <span style="color: #000000;">&#125;</span>
   <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>val.<span style="color: #00eeff;">type</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==typeif<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">vector</span>&lt;Head&gt;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>
      <span style="color: #000000;">&#123;</span>
        of&lt;&lt;any_cast&lt;std::<span style="color: #00eeff;">vector</span>&lt;Head&gt; &gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>; 
      <span style="color: #000000;">&#125;</span>
      <span style="color: #0000ff;">else</span>
      print_val&lt;Tail&gt;<span style="color: #000000;">&#40;</span>of,val<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: any_print.h)
</p><p>Potrzebujemy jeszcze warunku kończącego rekurencję
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">void</span> print_val&lt;Null_type&gt;<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">ostream</span> &amp;of,boost::<span style="color: #00eeff;">any</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
of&lt;&lt;<span style="color: #666666;">&quot;don't know how to print this&quot;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>i możemy już używać naszego szablonu: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">typedef</span> 
TypeList&lt;double,
        Type_list&lt;int,
                  Type_list&lt;string,
                            Null_type&gt; &gt; &gt; my_list;
&nbsp;
print_val&lt;my_list&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>;</pre></div>

<p>( Źródło: typelist.cpp)
</p>
<table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Is_class.cpp">Is_class.cpp</a></td><td>675 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Convertible.cpp">Convertible.cpp</a></td><td>887 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Strip.cpp">Strip.cpp</a></td><td>1.43 KB</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Promote.cpp">Promote.cpp</a></td><td>1.77 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Typelist.h">Typelist.h</a></td><td>886 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Any_print.h">Any_print.h</a></td><td>780 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Typelist.cpp">Typelist.cpp</a></td><td>656 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1243" class="section-2">
  <h1 class="book-heading">Klasy wytycznych</h1>
  <h2>Wprowadzenie</h2>
<hr />
<br />
<p>Klasy wytycznych, nazywane również klasami reguł (policy classes)
służą do parametryzowania zachowania innych klas. Rozważmy przykład
funkcji <tt>accumulate</tt>. Posiada ona również przeciążoną wersję
umożliwiającą postawienie dowolnej operacji zamiast dodawania:
</p> 

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator, <span style="color: #0000ff;">class</span> T, <span style="color: #0000ff;">class</span> BinaryFunction&gt;
T accumulate<span style="color: #000000;">&#40;</span>InputIterator first, InputIterator last, T init,
             BinaryFunction binary_op<span style="color: #000000;">&#41;</span>;</pre></div>

<p>Jedyna zmiana w implementacji klasy w stosunku do przykładu 5.2 to zmiania operacji sumowania na:
</p>

<pre>        init = binary_op(init, *first);
</pre>

<p>Pomimo, że pojawił się dodatkowy szablon klasy, to nie jest to typowa
klasa wytycznych. Zachowanie jest określone nie tyle przez ten
parametr, co przez funktor przekazany jako argument wywołania.
</p><p>Możemy jednak zmienić trochę implementację:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class Operation, <span style="color: #0000ff;">class</span> InputIterator, <span style="color: #0000ff;">class</span> T &gt;
T accumulate<span style="color: #000000;">&#40;</span>InputIterator first, InputIterator last, T init<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      <span style="color: #0000ff;">for</span> <span style="color: #000000;">&#40;</span>; first != last; ++first<span style="color: #000000;">&#41;</span>
        init = Operation::<span style="color: #00eeff;">op</span><span style="color: #000000;">&#40;</span>init,*first<span style="color: #000000;">&#41;</span>
      <span style="color: #0000ff;">return</span> init;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Takiego szablonu możemy używać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; Sumation <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">static</span> op<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;a,<span style="color: #0000ff;">const</span> T &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
         <span style="color: #0000ff;">return</span> a+b;
       <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
&nbsp;
accumulate&lt;Summation&lt;double&gt; &gt;accumulate<span style="color: #000000;">&#40;</span>first,last,<span style="color: #0000dd;">0.0</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Klasa (szablon) <tt>Summation</tt> jest właśnie klasą wytycznych.  W
zasadzie nie ma powodów aby implementować funkcję <tt>accumulate</tt> za
pomocą klas wytycznych, poza być może nadzieją na trochę bardziej
efektywny kod.
</p><p>W następnej części przedstawię bardziej realistyczny, ale i bardziej
skomplikowany przykład.
</p>

<h2>Projektowanie za pomocą klas wytycznych</h2>
<hr />
<br />

<p>Problemem w uniwersalnych bibliotekach jest duża ilość możliwych
implementacji pojedynczego komponentu. Dzieje się tak kiedy
implementując komponent możemy podjąć kilka prawie niezależnych od
siebie decyzji. Projektując kontener mamy np. do wyboru różne sposoby
alokacji pamięci i różne strategie obsługi błędów. Te zagadanienia są
w dużej mierze ortogonalne do siebie. Jeśli więc mamy trzy strategie
przydziału pamięci i trzy strategie obsługi błędu, to w sumie
dostajemy dziewięć możliwych kombinacji. Decyzja o możliwości pracy w
środowisku wielowątkowym zwiększą tę liczę dwukrotnie.
</p><p>Klasy wytycznych mogą pomóc opanować ten kombinatoryczny wzrost ilości
możliwości. Idea polega na tym, aby za każdą decyzję odpwiedzialną
zrobić jedną klasę wytyczną, przekazywaną jako parametr szablonu.  W
przytoczonym przykładzie szablon kontenera mógłby posiadać dwa
parametry wytycznych
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,
         <span style="color: #0000ff;">typename</span> Allocator_policy,
         <span style="color: #0000ff;">typename</span> Checking_policy&gt;
 Kontener;</pre></div>


<p>i potrzebowalibyśmy 6 (3 <tt>Allocator_policy</tt> i 3 <tt>Checking_policy</tt>) różnych
klas wytycznych. Sześć może się wydawać niewiele mniejsze od
dziewięciu, ale takie podejście  skaluje się liniowo z liczbą
wytycznych: dodanie nowej strategii alokacji pamięci wymaga jednej
dodatkowej klasy, a liczba kombinacji zwieksza się do 12.
W praktyce wszystkie wytyczne miałyby wartości domyślne.
</p>

<h2>Stack</h2>
<hr />
br>

<p>Pokażę teraz jak to działa w praktyce na przykładzie znanego już nam
szablonu klasy <tt>Stack</tt>, w którym na początek dokonam  drobnych zmian:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:	
 T rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
 <span style="color: #0000ff;">size_t</span> _top;
<span style="color: #0000ff;">public</span>:
 Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;<span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">void</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>              <span style="color: #000000;">&#123;</span>--_top;<span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">const</span> T&amp; top<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #0000ff;">const</span>   <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">bool</span> is_empty           <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> !_top;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span></pre></div>

<p>Zmiany polegają na rozdzieniu operacji odczytywania wierzchołka stosu
i zdejmowania elementu ze stosu. Umożliwia to między innymi
przekazywanie wartości zwracanej ze stosu przez referencje, poza tym
jest to bardziej bezpieczne. 
</p><p>Ten kod jest, delikatnie rzecz ujmując, bardzo prościutki. Możemy
rozbudowywać go w co najmniej dwu kierunkach. Po pierwsze można użyć
dynamicznej alokacji pamięci, po drugie możemy zaimplementować
sprawdzanie zakresu aby wykryć próbę włożenia elementu na pełny stos,
lub zdjęcia/odczytania elementu ze stosu pustego.  W tym przypadku
mamy różne możliwości reakcji na te błędy.
</p><p>Żeby zaimplementować sprawdzanie zakresu dodajemy nowy parametr do 
szablonu <tt>Stack</tt>, który będzie określał klasę wytyczną dla tej strategii:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>,
         <span style="color: #0000ff;">typename</span> Checking_policy = No_checking_policy &gt; 
<span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:	
  T _rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">size_t</span> _top;
<span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
    Checking_policy::<span style="color: #00eeff;">check_push</span><span style="color: #000000;">&#40;</span>_top,N<span style="color: #000000;">&#41;</span>;
    _rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">void</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>              <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_pop</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    --_top;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">const</span> T&amp; top<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #0000ff;">const</span>   <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_top</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>         <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> !_top;
  <span style="color: #000000;">&#125;</span>
&nbsp;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: stack1.h)
</p><p>Klasa 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> No_checking_policy <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> check_push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span>,<span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> check_pop<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> check_top<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: checking_policy.h)
</p><p>implementuje najprostszą strategię sprawdzania zakresu: brak
sprawdzania. Proszę zauważyć, że w tym wypadku najprawdopodobniej
żaden kod nie zostanie dodany: kompilator "wyoptymalizuje" puste
funckje. 
</p><p>Inne możliwe strategie to np. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Abort_on_error_policy <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> check_push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> top,<span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>top &gt;= size<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #666666;">&quot;trying to push elemnt on full stack: aborting&quot;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
      <span style="color: #0000dd;">abort</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #000000;">&#125;</span>
  <span style="color: #000000;">&#125;</span>;
&nbsp;
  i podobnie dla pozostałych funkcji sprawdzających
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: checking_policy.h)
</p><p>Programując w C++ wstyd by było nie użyć wyjątków:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> Std_exception_on_error_policy <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> check_push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> top,<span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>top &gt;= size<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      throw std::<span style="color: #00eeff;">range_error</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;over the top&quot;</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #000000;">&#125;</span>
  <span style="color: #000000;">&#125;</span>;
&nbsp;
  i podobnie dla pozostałych funkcji sprawdzających
&nbsp;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: checking_policy.h)
</p><p>Teraz możemy prosto konfigurować szablon <tt>Stack</tt> podając mu
odpowiednie argumenty:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;int,<span style="color: #0000dd;">10</span>&gt;                                  s_no_check;
Stack&lt;double ,<span style="color: #0000dd;">100</span>,Abort_on_error_policy&gt;       s_abort;
Stack&lt;int *,<span style="color: #0000dd;">25</span>,Std_exception_on_error_policy&gt;  s_except;</pre></div>

<p>( Źródło: policy1.cpp)
</p><p>W celu zaimplementowania różnych strategii przydziału pamięci  dodajemy
dodatkowy parametr szablonu, który sam będzie szablonem:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>,
         <span style="color: #0000ff;">typename</span> Checking_policy = No_checking_policy,  
         template&lt;typename U,<span style="color: #0000ff;">size_t</span> M&gt;  <span style="color: #0000ff;">class</span> Allocator_policy 
         = Static_table_allocator &gt; <span style="color: #0000ff;">class</span> Stack;</pre></div>

<p>Szablon typu <tt>Allocator_policy</tt> posiada jeden typ stowarzyszony i
szereg funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">0</span>&gt; <span style="color: #0000ff;">struct</span> Static_table_allocator <span style="color: #000000;">&#123;</span>
         <span style="color: #0000ff;">typedef</span> T rep_type<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
         <span style="color: #0000ff;">void</span> init<span style="color: #000000;">&#40;</span>rep_type &amp;,<span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
         <span style="color: #0000ff;">void</span> expand_if_needed<span style="color: #000000;">&#40;</span>rep_type &amp;,<span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
         <span style="color: #0000ff;">void</span> shrink_if_needed<span style="color: #000000;">&#40;</span>rep_type &amp;size_t<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
         <span style="color: #0000ff;">void</span> dealocate<span style="color: #000000;">&#40;</span>rep_type &amp;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> N;<span style="color: #000000;">&#125;</span>;
&nbsp;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: allocator2.h)
</p><p>Szablon <tt>Stack</tt> implementujemy teraz następująco:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;...&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Allocator_policy&lt;T,N&gt;::<span style="color: #00eeff;">rep_type</span> rep_type;
  rep_type  _rep;
  <span style="color: #0000ff;">size_t</span> _top;
  Allocator_policy&lt;T,N&gt; alloc;
<span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n = N<span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    alloc.<span style="color: #00eeff;">init</span><span style="color: #000000;">&#40;</span>_rep,n<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    alloc.<span style="color: #00eeff;">expand_if_needed</span><span style="color: #000000;">&#40;</span>_rep,_top<span style="color: #000000;">&#41;</span>;
    Checking_policy::<span style="color: #00eeff;">check_push</span><span style="color: #000000;">&#40;</span>_top,alloc.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
    _rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">void</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>              <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_pop</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    --_top;
    alloc.<span style="color: #00eeff;">shrink_if_needed</span><span style="color: #000000;">&#40;</span>_rep,_top<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">const</span> T&amp; top<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #0000ff;">const</span>   <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_top</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>         <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> !_top;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  ~Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>alloc.<span style="color: #00eeff;">dealocate</span><span style="color: #000000;">&#40;</span>_rep<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
&nbsp;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: stack2.h)
</p><p>Szablon 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">size_t</span> N &gt; <span style="color: #0000ff;">struct</span> Expandable_new_allocator <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> T * rep_type;
  <span style="color: #0000ff;">size_t</span> _size;
  <span style="color: #0000ff;">void</span> init<span style="color: #000000;">&#40;</span>rep_type &amp;rep,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_size=n;rep = <span style="color: #0000dd;">new</span> T <span style="color: #000000;">&#91;</span>_size<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> expand_if_needed<span style="color: #000000;">&#40;</span>rep_type &amp; rep,<span style="color: #0000ff;">size_t</span> top<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>top == _size<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      _size=<span style="color: #0000dd;">2</span>*_size;
      T *tmp= <span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>_size<span style="color: #000000;">&#93;</span>;
      std::<span style="color: #00eeff;">copy</span><span style="color: #000000;">&#40;</span>rep,&amp;rep<span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span>,tmp<span style="color: #000000;">&#41;</span>;
      <span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> rep;
      rep = tmp;
    <span style="color: #000000;">&#125;</span>
  <span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> shrink_if_needed<span style="color: #000000;">&#40;</span>rep_type &amp;size_t<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> dealocate<span style="color: #000000;">&#40;</span>rep_type &amp;rep<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> rep;<span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _size;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: allocator2.h)
</p><p>definiuje strategię dynamicznego przydziału pamięci "na żądanie". 
Możemy teraz dowolnie składać nasze strategie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> n=<span style="color: #0000dd;">10</span>;
  Stack&lt;int,<span style="color: #0000dd;">0</span>,Std_exception_on_error_policy,Expandable_new_allocator &gt; s1<span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span>;
  Stack&lt;int,<span style="color: #0000dd;">10</span>,Abort_on_error_policy,Static_table_allocator &gt; s2<span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span>;</pre></div>


<p>( Źródło: policy2.cpp)
</p><p>Widać, że takie podejście jest bardzo elastyczne, użytkownik może
praktycznie dowolnie konfigurować sobie zachowanie klasy <tt>Stack</tt>,
zwłaszcza, że ma możliwość tworzenia własnych klas wytycznych.
</p><p>Oczywiście powyższy przykład nie jest do końca dopracowany. Przede
wszystkim strategie przydziału pamięci i strategie sprawdzenia zakresu
nie są całkowicie niezależne. Np. w funkcji <tt>push</tt> jeśli powiedzie
się wywołanie funkcji <tt>expand_if_needed()</tt> to nie ma potrzeby
wywoływania funkcji <tt>check_push()</tt>. Po drugie - całkowicie
pominęliśmy kwestię diagnostyki funkcji alokujących pamięć. Możliwe
rozwiązanie to przekazanie <tt>Checkin_policy</tt> jako argumentu szablonu
do <tt>allocator_policy</tt>. Można też rozważyć posiadanie dwu różnych
klas wytycznych, jednej dla obsługi błędów przekroczenia zakresu,
drugiej do obsługi błędów przydziału pamięci.
</p>

<h2>Dziedziczenie wytycznych</h2>
<hr />
<br />

<p>Stosowanie wytycznej <tt>Checking_policy</tt> sprowadzało się do używania
funkcji statycznych. W przypadku wytycznej <tt>Allocator_policy</tt>
musieliśmy utworzyć obiekt tej klasy, ponieważ niektóre implementacje
tej wytycznej posiadają stan (w tym przypadku jest to zmienna
<tt>_size</tt>). Alternatywnym sposobem użycia takiej wytycznej 
jest wykorzystanie dziedziczenia:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>,
         <span style="color: #0000ff;">typename</span> Checking_policy = No_checking_policy,  
         template&lt;typename U,<span style="color: #0000ff;">size_t</span> M&gt;  <span style="color: #0000ff;">class</span> Allocator_policy 
         = Static_table_allocator &gt; 
<span style="color: #0000ff;">class</span> Stack: <span style="color: #0000ff;">private</span> Checking_policy, <span style="color: #0000ff;">private</span> Allocator_policy&lt;T,N&gt; <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Allocator_policy&lt;T,N&gt;::<span style="color: #00eeff;">rep_type</span> rep_type;
  rep_type  _rep;
  <span style="color: #0000ff;">size_t</span> _top;
<span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n = N<span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    init<span style="color: #000000;">&#40;</span>_rep,n<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    expand_if_needed<span style="color: #000000;">&#40;</span>_rep,_top<span style="color: #000000;">&#41;</span>;
    Checking_policy::<span style="color: #00eeff;">check_push</span><span style="color: #000000;">&#40;</span>_top,this-&gt;size<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
    _rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>              <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_pop</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    --_top;
    this-&gt;shrink_if_needed<span style="color: #000000;">&#40;</span>_rep,_top<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">const</span> T&amp; top<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #0000ff;">const</span>   <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_top</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>;
  <span style="color: #000000;">&#125;</span>  
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>         <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> !_top;
  <span style="color: #000000;">&#125;</span> 
  ~Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>this-&gt;dealocate<span style="color: #000000;">&#40;</span>_rep<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: stack3.h)
</p><p>Główna zmiana to konieczność kwalifikowania nazw niektórych funkcji
przez <tt>this-></tt> tak, aby stały się nazwami zależnymi (zob. wykład 3.7.1). 
Skorzystałem z dziedziczenia prywatnego aby zaznaczyć, że dziedziczę
implementację a nie interfejs (<tt>Stack</tt> <b>nie jest</b>
<tt>Allocator_policy</tt>). Jednak odziedziczenie również interfejsu
klasy <tt>Allocator_policy</tt> poprzez dziedziczenie publiczne może być użyteczne. Aby się o tym przekonać
rozważymy kolejną modyfikację naszego przykładu: przeniesiemy zmienną
<tt>_rep</tt> z klasy <tt>Stack</tt> do klasy wytycznej np.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">size_t</span> N &gt; <span style="color: #0000ff;">class</span> Dynamic_table_allocator <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">protected</span>:
  <span style="color: #0000ff;">typedef</span> T * rep_type;
  rep_type _rep;
  <span style="color: #0000ff;">size_t</span> _size;
  <span style="color: #0000ff;">void</span> init<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_size=n;_rep = <span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>_size<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> expand_if_needed<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> shrink_if_needed<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> dealocate<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> _rep;<span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _size;<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> resize<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      T *tmp= <span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>n<span style="color: #000000;">&#93;</span>;
      std::
