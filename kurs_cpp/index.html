<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl" xml:lang="pl">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Zaawansowane CPP</title>
    <base href="http://smurf.mimuw.edu.pl" />
    <link type="text/css" rel="stylesheet" href="misc/print.css" />
      </head>
  <body>
        
    <div id="node-1232" class="section-1">
  <h1 class="book-heading">Zaawansowane CPP</h1>
  <h1>Forma zajęć</h1>
<p>Wykład (30 godzin) + laboratorium (30 godzin)</p>
<h1>Opis</h1>
<p>Celem przedmiotu jest zapoznanie studentów z zaawansowanymi technikami programowania obiektowego w C++.</p>
<h1>Sylabus</h1>
<p>Autorzy</p>
<ul>
<li>Piotr Białas - Uniwersytet Jagielloński, Wydział Fizyki, Astronomii i Informatyki Stosowanej,
</li>
<li>Wojciech Palacz - Uniwersytet Jagielloński, Wydział Fizyki, Astronomii i Informatyki Stosowanej,
</li>
</ul>
<h1>Wymagania wstępne</h1>
<ul>
<li>Programowanie Obiektowe
</li>
<li>Znajomość C++
</li>
</ul>
  <div id="node-1233" class="section-2">
  <h1 class="book-heading">Szablony I</h1>
  <h2>Szablony funkcji</h2>
<hr />
<br />
<h3>Funkcje uogólnione</h3>
<br />

<p>W praktyce programowania często spotykamy się z funkcjami
(algorytmami), które można zastosować do szerokiej klasy typów i
struktur danych. Typowym przykładem jest funkcja obliczająca maksimum
dwu wartości. Ten trywialny, aczkolwiek przydatny kod można zapisać np.
w postaci:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span> b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Przykład 1.1
</p>

<p>Funkcja <tt>max</tt> wybiera większy z dwu <tt>int</tt>-ów, ale widać, że kod
będzie identyczny dla argumentów dowolnego innego typu pod warunkiem,
iż istnieje dla niego operator porównania i konstruktor kopiujący. W
językach programowania z silną kontrolą typów, takich jak C, C++ czy
Java definiując funkcję musimy jednak podać typy przekazywanych
parametrów oraz typ wartości zwracanej. Oznacza to, że dla każdego typu
argumentów musimy definiować nową funkcję <tt>max</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span>    max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b<span style="color: #000000;">&#41;</span>      <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">double</span> max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> a,<span style="color: #0000ff;">double</span> b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>;
string max<span style="color: #000000;">&#40;</span>string a,string b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>;
&lt;i&gt;skorzystaliśmy tu z dostępnej w C++ możliwości przeładowywania funkcji&lt;/i&gt;&lt;br /&gt;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  cout&lt;&lt; max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">7</span>,<span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span> &lt;&lt;end;
  cout&lt;&lt; max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.1415</span>,<span style="color: #0000dd;">2.71</span><span style="color: #000000;">&#41;</span> &lt;&lt;endl;
  cout&lt;&lt; max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;Ania&quot;</span>,<span style="color: #666666;">&quot;Basia&quot;</span><span style="color: #000000;">&#41;</span> &lt;&lt;endl;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Przykład 1.2
</p>

<p>Takie powtarzanie kodu, poza oczywistym zwiększeniem nakładu pracy, ma
inne niepożądane efekty, związane z trudnością zapewnienia
synchronizacji kodu każdej z funkcji. Jeśli np. zauważymy błąd w
kodzie, to musimy go poprawić w kilku miejscach. To samo dotyczy
optymalizacji kodu. W powyższym przykładzie kod jest wyjątkowo prosty,
ale taki sam problem dotyczy np. funkcji sortujących. Rozważmy prosty
algorytm sortowania bąbelkowego:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">void</span> swap<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> &amp;a,<span style="color: #0000ff;">double</span> &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">double</span>   tmp=a;a=b;b=tmp;
<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">void</span> buble_sort<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> *data,<span style="color: #0000ff;">int</span> N<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=n<span style="color: #0000dd;">-1</span>;i&gt;<span style="color: #0000dd;">0</span>;--i<span style="color: #000000;">&#41;</span>
        <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> j=<span style="color: #0000dd;">0</span>; j &lt; i;++j<span style="color: #000000;">&#41;</span> 
                <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>j<span style="color: #000000;">&#93;</span>&gt;data<span style="color: #000000;">&#91;</span>j<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>
                        swap<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>j<span style="color: #000000;">&#93;</span>,data<span style="color: #000000;">&#91;</span>j<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Powyższa funkcja sortuje tablicę zawierającą wartości typu <tt>double</tt>,
ale widać, że znów kod będzie identyczny, jeśli zamiast <tt>double</tt>
użyjemy dowolnego innego typu, którego wartości możemy porównywać za
pomocą funkcji <tt>operator>()</tt> i dla którego zdefiniowany jest
operator przypisania. Co więcej, kod nie zmieni się jeśli zamiast
tablicy użyjemy dowolnej innej struktury danych, umożliwiającej
indeksowany dostęp do swoich składowych, np. <tt>std::vector</tt> ze
Standardowej Biblioteki Szablonów STL. W tym przypadku kod jest już
bardziej skomplikowany i kłopoty związane z jego powielaniem będą
większe.  Przykłady takie można mnożyć, istnieje bowiem wiele takich
funkcji czy <i>algorytmów uogólnionych</i>. Ich kod może być znacznie
bardziej skomplikowany niż w podanych przykładach, a zależność od typu
argumentów nie musi ograniczać się do sygnatury, ale występować również
we wnętrzu funkcji, jak np. w przypadku zmiennej <tt>tmp</tt> w funkcji
<tt>swap</tt>.  Powielanie takiego kodu dla różnych typów parametrów może
łatwo prowadzić do błędów, utrudnia ich wykrywanie, a konieczność
edycji każdego egzemplarza kodu zniechęca do wprowadzania ulepszeń.
</p>

<h3>Funkcje uogólnione bez szablonów</h3>

<p>Jak radzili, a właściwie jak radzą sobie programiści bez możliwości
skorzystania z szablonów? 
Tradycyjne sposoby rozwiązywania tego typu problemów to między innymi
makra:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#define max(a,b) ( (a&gt;b)?a:b) )</span></pre></div>
<p>lub używanie wskaźników typów ogólnych, takich jak <tt>void *</tt>,
jak np. w funkcji <tt>qsort</tt> ze standardowej biblioteki C:  
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> <span style="color: #0000dd;">qsort</span> <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> *base, <span style="color: #0000ff;">size_t</span> nmemb, <span style="color: #0000ff;">size_t</span> size,
           <span style="color: #0000ff;">int</span><span style="color: #000000;">&#40;</span>*compar<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span> *, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span> *<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Mimo iż użyteczne, żadne z
tych rozwiązań nie może zostać uznane za wystarczająco ogólne i bezpieczne.
</p><p>Można się również pokusić o próbę rozwiązania tego problemu za pomocą
mechanizmów programowania obiektowego.  W sumie jest to bardziej
wyrafinowana odmiana rzutowania na <tt>void *</tt>.  Polega  na
zdefiniowaniu ogólnego typu dla obiektów, które mogą być porównywane:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> GreaterThanComparable <span style="color: #000000;">&#123;</span> 
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">bool</span> operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> GreaterThanComparable &amp;<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> = <span style="color: #0000dd;">0</span>; 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>następnie zdefiniowaniu funkcji <tt>max</tt> w postaci: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">const</span> GreaterThanComparable &amp;
max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> GreaterThanComparable &amp;a, 
    <span style="color: #0000ff;">const</span> GreaterThanComparable &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
      <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>? a:b; 
    <span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_oop.cpp)
</p><p>i używaniu jej np. w następujący sposób:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> <span style="color: #0000ff;">Int</span>:<span style="color: #0000ff;">public</span> GreaterThanComparable <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">int</span> val;
<span style="color: #0000ff;">public</span>: <span style="color: #0000ff;">Int</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i &lt;nowiki&gt;=&lt;/nowiki&gt; <span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>:val<span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>; 
  operator <span style="color: #0000ff;">int</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> val;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">bool</span> 
  operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> GreaterThanComparable &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> val &gt; static_cast&lt;const Int&amp;&gt;<span style="color: #000000;">&#40;</span>b<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span>;
  <span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">Int</span> a<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>,b<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">Int</span> c;
  c = <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">Int</span> &amp;<span style="color: #000000;">&#41;</span>::<span style="color: #00eeff;">max</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>;
  cout&lt;&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>c&lt;&lt;endl;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_oop.cpp)
</p><p>Widać więc wyraźnie, że to podejście wymaga sporego nakładu pracy, a
więc w szczególności w przypadku tak prostej funkcji jak <tt>max</tt> jest
wysoce niepraktyczne. Ogólnie rzecz biorąc ma ono następujące wady:
</p>

<ol><li> Wymaga dziedziczenia z abstrakcyjnej klasy bazowej <tt>GreaterThanComparable</tt>, czyli może być zastosowane tylko do typów zdefiniowanych przez nas.  Inne typy, w tym typy wbudowane, wymagają kopertowania w klasie opakowującej, takiej jak klasa <tt>Int</tt> w powyższym przykładzie.
</li><li> Ponieważ potrzebujemy polimorfizmu funkcja <tt>operator>()</tt> musi być funkcją wirtualną, a więc musi być funkcją składową klasy i nie może być typu <tt>inline</tt>. W przypadku tak prostych funkcji niemożność rozwinięcia ich w miejscu wywołania może prowadzić do dużych narzutów w czasie wykonania.
</li><li> Funkcja <tt>max</tt> zwraca zawsze referencje do <tt>GreaterThanComparable</tt>, więc konieczne jest rzutowanie na typ wynikowy (tu <tt>Int</tt>).
</li></ol>

<h3>Szablony funkcji</h3>
<br />

<p>Widać, że podejście obiektowe nie nadaje się najlepiej do rozwiązywania
tego szczególnego problemu powielania kodu. Dlatego w C++ wprowadzono
nowy mechanizm: szablony.  Szablony zezwalają na definiowanie całych
rodzin funkcji, które następnie mogą być używane dla różnych typów
argumentów.
</p><p>Definicja szablonu funkcji <tt>max</tt>, odpowiadającej definicji 1.1 wygląda następująco:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>;</pre></div>
<p>( Źródło: max_template.cpp)
</p><p>Przyjrzyjmy się jej z bliska. Wyrażenie <tt>template<typename T></typename></tt>
oznacza, że mamy do czynienia z szablonem, który posiada jeden parametr
formalny nazwany <tt>T</tt>. Słowo kluczowe <tt>typename</tt> oznacza, że
parametr ten jest typem (nazwą typu). Zamiast słowa <tt>typename</tt>
możmy użyć słowa kluczowego <tt>class</tt>.  Nazwa tego parametru może być
następnie wykorzystywana w definicji funkcji w miejscach, gdzie
spodziewamy się nazwy typu. I tak powyższe wyrażenie definiuje funkcję
<tt>max</tt>, która przyjmuje dwa argumenty typu <tt>T</tt> i zwraca wartość
typu <tt>T</tt>, będącą wartością większego z dwu argumentów. Typ <tt>T</tt>
jest na razie niewyspecyfikowany. W tym sensie szablon definiuje całą
rodzinę funkcji. Konkretną funkcję z tej rodziny wybieramy poprzez
podstawienie za formalny parametr <tt>T</tt> konkretnego typu będącego
argumentem szablonu. Takie podstawienie nazywamy konkretyzacją
szablonu. Argument szablonu umieszczamy w nawiasach ostrych za nazwą
szablonu (w praktyce można uniknąć konieczności jawnej specyfikacji
argumentów szablonu, opiszemy to w następnych częściach wykładu):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> i,j,k;
k=max&lt;int&gt;<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>;</pre></div>

<p>Takie użycie szablonu spowoduje wygenerowanie identycznej funkcji jak 1.1. W powyższym przypadku za <tt>T</tt> podstawiamy <tt>int</tt>. Oczywiście możemy podstawić za <tt>T</tt> dowolny typ i używając szablonów program 1.2 można zapisać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">7</span>,<span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.1415</span>,<span style="color: #0000dd;">2.71</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;string&gt;<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;Ania&quot;</span>,<span style="color: #666666;">&quot;Basia&quot;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_template.cpp)
</p><p>W powyższym kodzie użyliśmy konstrukcji <tt>::max(a,b)</tt>. Dwa dwukropki
oznaczają, że używamy funkcji <tt>max</tt> zdefiniowanej w ogólnej
przestrzeni nazw. Jest to konieczne aby kod się skompilował, ponieważ
szablon <tt>max</tt> istnieje już w standardowej przestrzeni nazw
<tt>std</tt>. W dalszej części wykładu będziemy te podwójne dwukropki pomijać.
</p><p>Oczywiście istnieją typy których podstawienie spowoduje błędy
kompilacji, np.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">complex&lt;double&gt; c1,c2;
max&lt;complex&lt;double&gt; &gt;<span style="color: #000000;">&#40;</span>c1,c2<span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//brak operatora &gt;</span></pre></div>

<p>( Źródło: max_template.cpp)
</p><p>lub
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> X <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:
  X<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> X &amp;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
X a,b;
max&lt;X&gt;<span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//prywatny (niewidoczny) konstruktor kopiujący</span></pre></div>
<p>( Źródło: max_template.cpp)
</p><p>Ogólnie rzecz biorąc, każdy szablon definiuje pewną klasę typów, które
mogą zostać podstawione jako jego argumenty.
</p>

<h3>Dedukcja argumentów szablonu</h3>

<p>Użyteczność szablonów funkcji zwiększa istotnie fakt, że argumenty szablonu nie muszą być podawane jawnie. Kompilator może je wydedukować z argumentów funkcji. Tak więc zamiast 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> i,j,k;
k=max&lt;int&gt;<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>;</pre></div>

<p>możemy napisać
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> i,j,k;
k=max<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>;</pre></div>

<p>i kompilator zauważy, że tylko podstawienie <tt>int</tt>-a za <tt>T</tt> umożliwi
dopasowanie sygnatury funkcji do parametrów jej wywołania i
automatycznie dokona odpowiedniej konkretyzacji.
</p><p>Może się zdarzyć, że podamy takie argumenty funkcji, że dopasowanie
argumentów wzorca będzie niemożliwe, otrzymamy wtedy błąd kompilacji.
Trzeba pamiętać, że mechanizm automatycznego dopasowywania argumentów
szablonu powoduje wyłączenie automatycznej konwersji argumentów
funkcji. Podanie jawnie argumentów szablonu (w nawiasach ostrych za
nazwą szablonu) jednoznacznie określa sygnaturę funkcji, a więc
umożliwia automatyczną konwersję typów.  Ilustruje to poniższy kod:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  cout&lt;&lt;::<span style="color: #00eeff;">max</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.14</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
  <span style="color: #ff0000;">// błąd: kompilator nie jest w stanie wydedukowac argumentu szablonu, bo typy </span>
  <span style="color: #ff0000;">// argumentów (double,int) nie pasują  do (T,T)</span>
&nbsp;
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.14</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
  <span style="color: #ff0000;">// podając argument jawnie wymuszamy sygnaturę int max(int,int), a co za tym </span>
  <span style="color: #ff0000;">// idzie automatyczną konwersję argumentu 1 do int-a</span>
&nbsp;
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.14</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
  <span style="color: #ff0000;">// podając argument szablonu jawnie wymuszamy sygnaturę </span>
  <span style="color: #ff0000;">// double max(double,double)</span>
  <span style="color: #ff0000;">// a co za tym idzie automatyczną konwersję argumentu 2 do double-a</span>
&nbsp;
  <span style="color: #0000ff;">int</span> i;
  cout&lt;&lt;::<span style="color: #00eeff;">max</span>&lt;int *&gt;<span style="color: #000000;">&#40;</span>&amp;i,i<span style="color: #000000;">&#41;</span>&lt;&lt;endl; 
  <span style="color: #ff0000;">//błąd: nie istnieje konwersja z typu int na int*</span></pre></div>

<p>( Źródło: max_template.cpp)
</p><p>Może warto zauważyć, że automatyczna dedukcja parametrów szablonu jest
możliwa tylko wtedy, jeśli parametry wywołania funkcji w jakiś sposób
zależą od parametrów szablonu. Jeśli tej zależności nie ma, z przyczyn
oczywistych dedukcja nie jest możliwa i trzeba parametry podawać
jawnie. Wtedy istotna jest kolejność parametrów na liście. Jeżeli
parametry, których nie da się wydedukować, umieścimy jako pierwsze,
wystarczy, że tylko je podamy jawnie, a kompilator wydedukuje resztę.
Ilustruje to poniższy kod:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> U&gt; T convert<span style="color: #000000;">&#40;</span>U u<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>T<span style="color: #000000;">&#41;</span>u;
<span style="color: #000000;">&#125;</span>;
template&lt;typename U,<span style="color: #0000ff;">typename</span> T&gt; T inv_convert<span style="color: #000000;">&#40;</span>U u<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>T<span style="color: #000000;">&#41;</span>u;
<span style="color: #000000;">&#125;</span>;
fukcje różnią się tylko kolejnością parametrów szablonu
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
cout&lt;&lt;convert<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">33</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
błąd: kompilator nie jest w stanie wydedukować pierwszego parametru 
szablonu,  bo  nie zależy on od parametru wywołania funkcji
&nbsp;
cout&lt;&lt;convert&lt;char&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">33</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
w porządku: podajemy jawnie argument T, kompilator sam dedukuje 
argument U z typu argumentu wywołania funkcji
&nbsp;
cout&lt;&lt;inv_convert&lt;char&gt;<span style="color: #000000;">&#40;</span><span style="color: #666666;">'a'</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl; 
błąd: podajemy jawnie argument odpowiadający parametrowi U. 
<span style="color: #00eeff;">Kompilator</span> nie jest w stanie wydedukować argumentu T, bo nie zależy on od argumentu 
wywołania funkcji
&nbsp;
cout&lt;&lt;inv_convert&lt;int,char&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">33</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
w porządku: podajemy jawnie oba argumenty szablonu
<span style="color: #000000;">&#125;</span></pre></div>



<p>( Źródło: convert.cpp)
</p>

<h3>Używanie szablonów</h3>

<p>Z użyciem szablonów wiąże się parę zagadnień niewidocznych w prostych
przykładach. W językach C i C++ zwykle rozdzielamy deklarację funkcji
od jej definicji i zwyczajowo umieszczamy deklarację w plikach
nagłówkowych <tt>*.h</tt>, a definicję w plikach źródłowych <tt>*.c</tt>,
<tt>*.cpp</tt> itp. Pliki nagłówkowe są w czasie kompilacji włączane do
plików, w których chcemy korzystać z danej funkcji, a pliki źródłowe są
pojedynczo kompilowane do plików “obiektowych” <tt>*.o</tt>. Następnie
pliki obiektowe są łączone w jeden plik wynikowy (zob. rysunek 1.1). W pliku
korzystającym z danej funkcji nie musimy więc znać jej definicji, a
tylko deklarację.  Na podstawie nazwy funkcji konsolidator powiąże
wywołanie funkcji z jej implementacją znajdującą się w innym pliku
obiektowym. W ten sposób tylko zmiana deklaracji funkcji wymaga
rekompilacji plików, w których z niej korzystamy, a zmiana definicji
wymaga jedynie rekompilacji pliku, w którym dana funkcja jest
zdefiniowana.
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-1-kod1_1.png" alt="Rysunek 1.1. Przykład organizacji kodu C++ w przypadku użycia zwykłych funkcji." title="Rysunek 1.1. Przykład organizacji kodu C++ w przypadku użycia zwykłych funkcji."  class="image image-_original " width="640" height="453" /><span class="caption"><strong>Rysunek 1.1. Przykład organizacji kodu C++ w przypadku użycia zwykłych funkcji.</strong></span></span>


<p>Taka organizacja umożliwia przestrzeganie "reguły jednej definicji"
(one definition rule), wymaganej przez C++. 
Osobom nieobeznanym z programowaniem w C/C++ zwracam uwagę na konstrukcję
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#ifndef _nazwa_pliku_</span>
<span style="color: #339900;">#define _nazwa_pliku_</span>
...
<span style="color: #339900;">#endif</span></pre></div>

<p>uniemożliwiajacą podwójne włączenie tego pliku do jednej jednostki
translacyjnej.
</p><p>Podobne podejście do kompilacje szablonów się nie powiedzie (zob. rysunek 1.2).
Powodem jest fakt, że w trakcie kompilacji pliku <tt>utils.cpp</tt>
kompilator nie wie jeszcze, że potrzebna będzie funkcja <tt>max<int></int></tt>,
wobec czego nie generuje kodu żadnej funkcji, a jedynie sprawdza
poprawność gramatyczną szablonu. Z kolei podczas kompilacji pliku
<tt>main.cpp</tt> kompilator już wie, że ma skonkretyzować szablon dla <tt>T = int</tt>,
ale nie ma dostępu do kodu szablonu.
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-1-kod2.png" alt="Rysunek 1.2. Przykład błędnej organizacji kodu w przypadku użycia szablonów." title="Rysunek 1.2. Przykład błędnej organizacji kodu w przypadku użycia szablonów."  class="image image-_original " width="640" height="416" /><span class="caption"><strong>Rysunek 1.2. Przykład błędnej organizacji kodu w przypadku użycia szablonów.</strong></span></span>


<p>Istnieją różne rozwiązania tego problemu. Najprościej chyba jest
zauważyć, że opisane zachowanie jest analogiczne do zachowania podczas
kompilacji funkcji rozwijanych w miejscu wywołania (<tt>inline</tt>),
których definicja również musi być dostępna w czasie kompilacji.
Podobnie więc jak w tym przypadku możemy zamieścić wszystkie
deklaracje i definicje szablonów w pliknu nagłówkowym, włączanym do
plików, w ktorych z tych szablonów korzystamy (zob. rysunek 1.3). Podobnie
jak w przypadku funkcji <tt>inline</tt> reguła jednej definicji zezwala na
powtarzanie definicji/deklaracji szablonów w różnych jednostkach
translacyjnych, pod warunkiem, że są  one identyczne. Stąd konieczność 
umieszczania ich w plikach nagłówkowych.  
</p>


<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-1-kod3.png" alt="Rysunek 1.3. Przykład organizacji kodu z szablonami, wykorzystującego strategię włączania." title="Rysunek 1.3. Przykład organizacji kodu z szablonami, wykorzystującego strategię włączania."  class="image image-_original " width="640" height="424" /><span class="caption"><strong>Rysunek 1.3. Przykład organizacji kodu z szablonami, wykorzystującego strategię włączania.</strong></span></span>


<p>Ten sposób organizacji pracy z szablonami, nazywany modelem włączenia,
jest  najbardziej uniwersalny. Jego główną wadą jestkonieczność
rekompilacji całego kodu korzystającego z szablonów przy każdej
zmianie definicji szablonu.  Również jeśli zmienimy coś w pliku, w
którym korzystamy z szablonu, to musimy rekompilować cały kod szablonu
włączony do tego pliku, nawet jeśli nie uległ on zmianie. Jeśli się
uwzględni fakt, że kompilacja szablonu jest bardziej skomplikowana od
kompilacji "zwykłego" kodu, to duży projekt intensywnie korzystający z
szablonów może wymagać bardzo długich czasów kompilacji.
</p><p>Możemy też w jakiś sposób dać znać kompilatorowi, że podczas kompilacji
pliku <tt>utils.cpp</tt> powinien wygenerować kod dla funkcji
<tt>max<int></int></tt>. Można to zrobić dodając jawne żądanie konkretyzacji
szablonu (zob. rysunek 1.4):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">template</span> <span style="color: #0000ff;">int</span> max&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> ,<span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>; &lt;i&gt;konkretyzacja jawna&lt;/i&gt;</pre></div>

<p>Używając konkretyzacji jawnej musimy pamiętać o dokonaniu
konkretyzacji każdej używanej funkcji, tak że to podejście nie
skaluje się zbyt dobrze.  Ponadto w przypadku szablonów klas (omawianych w
następnym module) konkretyzacja jawna pociąga za sobą konkretyzację
wszystkich metod danej klasy, a konkretyzacja “na żądanie” - jedynie
tych używanych w programie.
</p>


<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-1-kod4_1.png" alt="Rysunek 1.4. Przykład organizacji kodu z szablonami, wykorzystującego jawną konkretyzację." title="Rysunek 1.4. Przykład organizacji kodu z szablonami, wykorzystującego jawną konkretyzację."  class="image image-_original " width="640" height="444" /><span class="caption"><strong>Rysunek 1.4. Przykład organizacji kodu z szablonami, wykorzystującego jawną konkretyzację.</strong></span></span>
<br />

<h2>Pozatypowe parametry szablonów </h2>

<p>Poza parametrami określającymi typ, takimi jak parametr <tt>T</tt> w
dotychczasowych przykładach, szablony funkcji mogą przyjmować również
parametry innego rodzaju. Obecnie mogą to być inne szablony, co omówię w
następnym podrozdziale lub parametry określające nie typ, ale wartości.
Jak na razie (w obecnym standardzie) te wartości nie mogą być dowolne,
ale muszą mieć jeden z poniższych typów:
</p>

<ol><li> typ całkowitoliczbowy bądź typ wyliczeniowy
</li><li> typ wskaźnikowy 
</li><li> typ referencyjny.
</li></ol>

<p>Takie parametry  określające wartość nazywamy parametrami pozatypowymi.
W praktyce z parametrów pozatypowych najczęściej używa się
parametrów typu całkowitoliczbowego. Np.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;size_t N,<span style="color: #0000ff;">typename</span> T&gt; T dot_product<span style="color: #000000;">&#40;</span>T *a,T *b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
        T total=<span style="color: #0000dd;">0.0</span>;
        <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;N;++i<span style="color: #000000;">&#41;</span>
                total += a<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>*b<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span> ;
&nbsp;
<span style="color: #0000ff;">return</span> total;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: dot_product.cpp)
</p><p>Po raz drugi zwracam uwagę na kolejność parametrów szablonu na liście
parametrów. Dzięki temu, że niededukowalny parametr <tt>N</tt> jest na
pierwszym miejscu wystarczy podać jawnie tylko jego, drugi parametr
typu <tt>T</tt> zostanie sam automatycznie wydedukowany na podstawie
przekazanych argumentów wywołania funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#93;</span>,y<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#93;</span>;
dot_product&lt;<span style="color: #0000dd;">3</span>&gt;<span style="color: #000000;">&#40;</span>x,y<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: dot_product.cpp)
</p><p>Parametry pozatypowe są zresztą "ciężko dedukowalne". Właściwie
jedynym sposobem na przekazania wartości stałej poprzez typ argumentu
wywołania jest skorzystanie z parametrów będących szablonami
klas (zob. następny podrozdział). 
</p><p>Używając pozatypowych parametrów szablonów musimy pamiętać, że
odpowiadające im argumenty muszą być stałymi wyrażeniami czasu
kompilacji.  Stąd jeżeli używamy typów wskaźnikowych, muszą to być
wskaźniki do obiektów łączonych zewnętrznie, a nie lokalnych. Ponieważ
jednak jeszcze ani razu nie używałem pozatypowych parametrów szablonów
innych niż typy całkowite, to nie będę podawał żadnych przykładów
takich paremtrów na tym wykładzie.
</p>

<h3>Szablony parametrów szablonu</h3>

<p>Jak już wspomniałem w poprzednim podrozdziale, parametrami szablonu
funkcji mogą być również szablony klas (zob. następny podrozdział).
Szablony parametrów szablonu umożliwiają przekazanie nazwy szablonu
jako argumentu szablonu funkcji. Więcej o nich napiszę w drugiej
części wykładu. Tutaj tylko pokażę jako ciekawostkę w jaki sposób można
dedukować wartości pozatypowych argumentów szablonu.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt; template&lt;int N&gt; <span style="color: #0000ff;">class</span>  C,<span style="color: #0000ff;">int</span> K&gt;
&lt;i&gt;taka definicja oznacza, że parametr C określa szablon klasy 
posiadający jeden parametr typu &lt;tt&gt;int&lt;/tt&gt;. <span style="color: #00eeff;">Parametr</span> N służy tylko 
<span style="color: #0000ff;">do</span> definicji szablonu C i nie może być użyty nigdzie indziej&lt;/i&gt;
<span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span>C&lt;K&gt;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
  cout&lt;&lt;K&lt;&lt;endl;
<span style="color: #000000;">&#125;</span>;&lt;br /&gt;
template&lt;int N&gt; <span style="color: #0000ff;">struct</span> SomeClass <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;&lt;br /&gt;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  SomeClass&lt;<span style="color: #0000dd;">1</span>&gt;  c1;
  SomeClass&lt;<span style="color: #0000dd;">2</span>&gt;  c2;&lt;br /&gt;
  f<span style="color: #000000;">&#40;</span>c1<span style="color: #000000;">&#41;</span>; &lt;i&gt;C=SomeClass K=<span style="color: #0000dd;">1</span>&lt;/i&gt;
  f<span style="color: #000000;">&#40;</span>c2<span style="color: #000000;">&#41;</span>; &lt;i&gt;C=SomeClass K=<span style="color: #0000dd;">2</span>&lt;/i&gt;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: deduce_N.cpp)
</p>

<h3>Szablony metod</h3>

<p>Jak na razie definiowaliśmy szablony zwykłych funkcji. C++ umożliwia
również definiowanie szablonów metod klasy np.:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> Max <span style="color: #000000;">&#123;</span>
  template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  Max m;
  m.<span style="color: #00eeff;">max</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_method.cpp)
</p><p>Szablonów metod składowych dotyczą takie same reguły jak szablonów funkcji.
</p>

<h2>Szablony klas</h2>
<hr />
<br />
<h3>Typy uogólnione</h3>

<p>Uwagi na początku poprzedniego rozdziału odnoszą się w tej samej
mierze do klas, jak i do funkcji. I tutaj mamy do czynienia z kodem,
który w niezmienionej postaci musimy powielać dla różnych typów.
Sztandarowym przykładem takiego kodu są różnego rodzaju kontenery (pojemniki),
czyli obiekty służące do przechowywania innych obiektów. Jest
oczywiste, że kod kontenera jest w dużej mierze niezależny od typu
obiektów w nim przechowywanych. Jako przykład weźmy
sobie stos liczb całkowitych. Możliwa definicja klasy stos może
wyglądać następująco, choć nie polecam jej jako wzoru do naśladowania
w prawdziwych aplikacjach:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:
  <span style="color: #0000ff;">int</span> rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">size_t</span> top;
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">size_t</span> N=<span style="color: #0000dd;">100</span>;
  Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">int</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> rep<span style="color: #000000;">&#91;</span>--top<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>top==<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>


<p>Ewidentnie ten kod będzie identyczny dla stosu obiektów dowolnego
innego typu, pod warunkiem, że typ ten posiada zdefiniowany
<tt>operator=()</tt> i konstruktor kopiujący.
</p><p>W celu zaimplementowania kontenerów bez pomocy szablonów możemy
probować podobnych sztuczek jak te opisane w poprzednim rozdziale. W
językach takich jak Java czy Smalltalk, które posiadają uniwersalną
klasę <tt>Object</tt>, z której są dziedziczone wszystkie inne klasy, a nie
posiadają (Java już posiada) szablonów, uniwersalne kontenery są
implementowane właśnie poprzez rzutowanie na ten ogólny typ.  W
przypadku C++ nawet to rozwiązanie nie jest praktyczne, bo C++ nie
posiada pojedynczej hierarchii klas.
</p>

<h3>Szablony klas</h3>

<p>Rozwiązaniem są znów szablony, tym razem szablony klas. Podobnie jak w
przypadku szablonów funkcji, szablon klasy definiuje nam w
rzeczywistości całą rodzinę klas. Szablon klasy <tt>Stack</tt> możemy zapisać
następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">size_t</span> N=<span style="color: #0000dd;">100</span>;
<span style="color: #0000ff;">private</span>:
  T _rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">size_t</span> _top;&lt;br&gt;
<span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;<span style="color: #000000;">&#125;</span>
  T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>--_top<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>_top==<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span> 
 <span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: stack.cpp)
</p><p>Tak zdefiniowanego szablonu możemy używać podając jawnie jego argumenty.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;string&gt; st ;
st.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;ania&quot;</span><span style="color: #000000;">&#41;</span>;
st.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;asia&quot;</span><span style="color: #000000;">&#41;</span>;
st.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;basia&quot;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>!st.<span style="color: #00eeff;">is_empty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
  cout&lt;&lt;st.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: stack.cpp)
</p><p>Dla szablonów klas nie ma możliwości automatycznej dedukcji argumentów
szablonu, ponieważ klasy nie posiadają argumentów wywołania, które
mogłyby do tej dedukcji posłużyć. Jest natomiast możliwość podania
argumentów domyślnych, np.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = int&gt; Stack <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span></pre></div>



<p>( Źródło: stack.cpp)
</p><p>Wtedy możemy korzystać ze stosu bez podawania argumentów szablonu i
wyrażenie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack s;</pre></div>

<p>będzie równoważne wyrażeniu: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;int&gt; s;</pre></div>

<p>Dla domyślnych argmentów szablonów klas obowiązują te same reguły, co dla
domyślnych argumentów wywołania funkcji. 
</p><p>Należy pamiętać, że każda konkretyzacja szablonu klasy dla 
różniących się zestawów argumentów jest osobną klasą: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;int&gt; si;
Stack&lt;double&gt; sd;
sd=si; <span style="color: #ff0000;">//błąd: to są obiekty różnych klas a nie zdefiniowano przypisania</span></pre></div>

<p>( Źródło: stack.cpp)
</p><p>Okazuje się, że próba zdefiniowania operatora przypisania, który
np. przypisywałby do siebie stosy różnych typów, nie jest łatwa,
ponieważ  dwa takie stosy nie widzą swoich reprezentacji.
</p>

<h3>Pozatypowe parametry szablonów klas</h3>

<p>Zestaw możliwych parametrów szablonów klas jest taki sam jak dla
szablonów funkcji. Podobnie najczęściej wykorzystywane są wyrażenia
całkowitoliczbowe. W naszym przykładzie ze stosem możemy ich użyć do
przekazania rozmiaru stosu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:	
 T rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
 <span style="color: #0000ff;">size_t</span> top;
<span style="color: #0000ff;">public</span>:
 Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;&lt;br /&gt;
 <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;<span style="color: #000000;">&#125;</span>
 T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>          <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> rep<span style="color: #000000;">&#91;</span>--top<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">bool</span> is_empty    <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>top==<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: stack_N.cpp)
</p><p>Podkreślam jeszcze raz, że <tt>Stack<int,100></int,100></tt> i <tt>Stack<int,101></int,101></tt> to
dwie różne klasy.
</p>

<h3>Szablony parametrów szablonu</h3>

<p>Stos jest nie tyle strukturą danych, ile sposobem dostępu do nich.
Stos realizuje regułę LIFO czyli Last In First Out. W tym sensie nie
jest istotne w jaki sposób dane są na stosie przechowywane. Może to
być tablica, jak w powyższych przykładach, ale może to być praktycznie
dowolny inny kontener. Np. w Standardowej Bibliotece Szablonów C++
stos jest zaimplementowany jako
adapter do któregoś z istniejących już kontenerów. Ponieważ kontenery
STL są szablonami, szablon adaptera mógłby wyglądać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,
         template&lt;typename X &gt; <span style="color: #0000ff;">class</span> Sequence=std::<span style="color: #00eeff;">deque</span> &gt; 
<span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
  Sequence&lt;T&gt; _rep;
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep.<span style="color: #00eeff;">push_back</span><span style="color: #000000;">&#40;</span>e<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
  T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>T top=_rep.<span style="color: #00eeff;">top</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;_rep.<span style="color: #00eeff;">pop_back</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;return top;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep.<span style="color: #00eeff;">empty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Konkretyzując stos możemy wybrać kontener, w którym będą przechowywane
jego elementy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;double,std::<span style="color: #00eeff;">vector</span>&gt; sv;</pre></div>

<p>Można zamiast szablonu użyć zwykłego parametru typu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> C &gt; <span style="color: #0000ff;">class</span> stos <span style="color: #000000;">&#123;</span>
  C rep;
  <span style="color: #0000ff;">public</span>:
   ...
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: stack_adapter.cpp)
</p><p>i używać go w następujący sposób:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">stos&lt;double,std::<span style="color: #00eeff;">vector</span>&lt;double&gt; &gt; sv;</pre></div>


<p>W  przypadku użycia szablonu jako parametru szablonu 
zapewniamy konsystencję pomiędzy typem <tt>T</tt> i kontenerem <tt>C</tt>,
uniemożliwiając  pomyłkę podstawienia
niepasujących parametrów:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">stos&lt;double,std::<span style="color: #00eeff;">vector</span>&lt;int&gt; &gt; sv; &lt;i&gt;błąd: niezgodność typow&lt;/i&gt;</pre></div>


<p>Uczciwość nakazuje jednak w tym miejscu stwierdzić, że właśnie takie
rozwiązanie jest zastosowane w STL-u. Ma ono tę zaletę, że możemy
adaptować na stos dowolny kontener, niekoniecznie będący szablonem.
</p><p>Na koniec jeszcze jedna uwaga: szablony kontenerów z STL posiadają po
dwa parametry typów, z tym, że drugi posiada wartość domyślną (standard dopuszcza dowolną ilość argumentów w implemetacji kontenerów STL jak długo będą one posiadały wartości domyślne). Autorzy D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i> ostrzegają, że w tej sytuacji kompilator może nie zaakceptować wyrażenia:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">stos&lt;double,std::<span style="color: #00eeff;">vector</span>&gt; sv;</pre></div>

<p>ponieważ ignoruje fakt istnienia wartości domyślnej dla
drugiego parametru szablonu <tt>std::vector</tt>. 
Mamy wtedy  niezgodność pomiędzy przekazanym argumentem szablonu
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; 
std::<span style="color: #00eeff;">vector</span>&lt;T,<span style="color: #0000ff;">typename</span> A = std::<span style="color: #00eeff;">allocator</span>&lt;T&gt; &gt;;</pre></div>


<p>oraz deklaracją paremetru <tt>Sequence</tt> jako:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename X &gt; <span style="color: #0000ff;">class</span> Sequence ;</pre></div>

<p>która zakłada tylko jeden parametr szablonu.  Można wtedy zmienić
deklarację szablonu <tt>stos</tt> i podać domyślny argument dla szablony w
liście parametrów:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,template&lt;typename X ,<span style="color: #0000ff;">typename</span> A =
std::<span style="color: #00eeff;">allocator</span>&lt;X&gt; &gt; <span style="color: #0000ff;">class</span> C &gt; <span style="color: #0000ff;">class</span> stos <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span></pre></div>

<p>W praktyce używane przeze mnie kompilatory (g++ wersja >= 3.3) nie
wymagały takiej konstrukcji. Przyznaję, że nie udało mi się doczytać czy
jest to cecha kompilatora g++, czy nowego standardu C++ (autorzy D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i> opierali się na poprzednim wydaniu standardu).
</p>


<h3>Konkretyzacja na żądanie</h3>

<p>Jak już wspomniałem wcześniej, konkretyzacja szablonów może odbywać się
"na żądanie". W takim przypadku kompilator będzie konkretyzował
tylko funkcje napotkane w kodzie. I tak, jeśli np. nie użyjemy w naszym
kodzie funckji <tt>Stack<int>::pop()</int></tt>, to nie zostanie ona
wygenerowana. Można z tego skorzystać i konkretyzować klasy typami,
które nie spełniają wszystkich ograniczeń nałożonych na parametry
szablonu. Wszystko bedzię w porządku jak długo nie będziemy używać
funkcji łamiących te ograniczenia. Np. załóżmy, że do szablonu
<tt>Stack</tt> dodajemy możliwość jego sortowania (wiem, to nie jest zgodne z duchem programowania obiektowego, stos nie posiada operacji sortowania, puryści mogą zastąpić ten przykład kontenerem <tt>list</tt>):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N&gt; <span style="color: #0000ff;">void</span> Stack&lt;T,N&gt;::<span style="color: #00eeff;">sort</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
bubble_sort<span style="color: #000000;">&#40;</span>_rep,N<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Możemy teraz np. używać
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;std::<span style="color: #00eeff;">complex</span>&lt;double&gt;&gt; sc;
sc.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span> std::<span style="color: #00eeff;">complex</span>&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
sc.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>ale nie 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">sc.<span style="color: #00eeff;">sort</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>( Źródło: stack_sort.cpp)
</p><p>Natomiast konkretyzacja jawna
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> Stack&lt;std::<span style="color: #00eeff;">complex</span>&lt;double&gt;&gt;;</pre></div>

<p>( Źródło: stack_sort.cpp)
</p><p>nie powiedzie się, bo kompilator będzie się starał skonkretyzować
wszystkie składowe klasy <tt>Stack</tt>, w tym metodę <tt>sort()</tt>.
</p>

<h3>Typy stowarzyszone</h3>
<hr />
<br />

<p>W klasach poza metodami i polami możemy definiować również typy, które
będziemy nazywali stowarzyszonymi z daną klasą. Jest to szczególnie
przydatne w przypadku szablonów. Rozważmy następujący przykład:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
<span style="color: #0000ff;">typedef</span> T value_type;
...
<span style="color: #000000;">&#125;</span></pre></div>

<p>Możemy teraz używać tej definicji w innych szablonach
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename S&gt; <span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span>S s<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typename</span> S::<span style="color: #00eeff;">value_type</span> total; 
    słowo <span style="color: #0000ff;">typename</span> jest wymagane, inaczej kompilator założy, że 
    S::<span style="color: #00eeff;">value_type</span> odnosi się <span style="color: #0000ff;">do</span> statycznej składowej klasy
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>!s.<span style="color: #00eeff;">is_empty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    total+=s.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">return</span> total;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: stack_N.cpp)
</p><p>Bez takich możliwości musielibyśmy przekazać typ elementów stosu w
osobnym argumencie. Mechanizm typów stowarzyszonych jest 
bardzo czesto używany w uogólnionym kodzie.
</p>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_oop.cpp">Max_oop.cpp</a></td><td>620 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_template.cpp">Max_template.cpp</a></td><td>1.2 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Convert.cpp">Convert.cpp</a></td><td>767 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Dot_product.cpp">Dot_product.cpp</a></td><td>414 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Deduce_N.cpp">Deduce_N.cpp</a></td><td>283 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_method.cpp">Max_method.cpp</a></td><td>170 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack.cpp">Stack.cpp</a></td><td>573 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_N.cpp">Stack_N.cpp</a></td><td>842 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_adapter.cpp">Stack_adapter.cpp</a></td><td>501 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_sort.cpp">Stack_sort.cpp</a></td><td>806 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1238" class="section-2">
  <h1 class="book-heading">Programowanie uogólnione</h1>
  <h2>Wprowadzenie</h2>
<hr />
<br />

<p>W poprzednim wykładzie wprowadziłem pojęcia szablonów funkcji i klas.
Są to bardzo ważne konstrukcje języka C++ dające programistom
bezpośrednie, czyli z poziomu języka, wsparcie dla tworzenia
uogólnionych funkcji i typów (nazywanych też funkcjami lub typami
parametryzowanymi). Uogólnienie polega na tym, że za jednym zamachem
definiujemy całe rodziny klas lub funkcji.  Po podstawieniu za
parametry konkretnych argumentów szablonu dostajemy już egzemplarz
"zwykłego" typu (klasy) lub funkcji (nazywane również instancjami
szablonu). Argumenty szablonu mogą reprezentować typy i w ten sposób
dostajemy narzędzie umożliwiające pisanie ogólnego kodu
parametryzowanego typem używanych w nim zmiennych, typem argumentów
wywołania funkcji itp.
</p><p>Szablony okazały się bardzo silnym narzędziem, których zastosowanie
daleko przekracza implementację prostych kontenerów i można spokojnie
stwierdzić, że ich prawdziwy potencjał jest ciągle odkrywany.  Szablony
idealnie wspierają styl programowania nazywany programowaniem
uogólnionym. Polega on na generalizowaniu algorytmów i struktur danych
tak, aby były w dużej mierze niezależne od typów danych, na których
działają lub z których się składają.  Mam nadzieję, że po lekturze
poprzedniego wykładu Państwo już widzą, że to jest właśnie to, do czego
szablony zostały wymyślone. Nie oznacza to, że automatycznie każdy
program używajacy szablonów jest od razu programem uogólnionym. Tak
jak i w przypadku tworzenia zwykłych (bez szablonów) programów, trzeba
się sporo natrudzić, aby uzyskać uniwersalny, łatwy do ponownego
wykorzystania kod. Ten wykład ma właśnie za zadanie przekazać Państwu
podstawowe wiadomości na temat pisania dobrych programów uogólnionych.
</p><p>W programowaniu uogólnionym ważną rolę gra pojęcie konceptu.  Koncept
to asbtrakcyjna definicja rodziny typów. To pojęcie pełni podobną rolę
jak interfejs w programowaniu uogólnionym, ale przynależność do tej
rodziny jest określona proceduralnie: do konceptu należą typy, które
spełniają pewne wymagania. Czyli jeśli coś kwacze jak kaczka to
jest to kaczka, a nie: to jest kaczka jeśli należy do rodziny
"kaczowatych". Koncepty omówię w dalszej części tego wykładu. 
</p><p>Co to jest programowanie uogólnione łatwiej jest pokazać na
przykładach niż opisać.  Niewątpliwie najważniejszą i najbardziej
znaną aplikacją programowania ogólnego jest Standardowa Biblioteka
Szablonów (STL - Standard Template Library), będąca oficjalną częścią
standardu C++. W tych wykladach będę się bardzo często posługiwał
przykładami z STL-a, ale szczegółowe nauczenie posługiwania się tą
biblioteką <b>nie</b> jest celem tego wykładu. Powinni jednak Państwo
zrobić to sami. Dlatego zachęcam do analizy przykładów zamieszczonych
na wykładzie oraz wykonywanie podanych ćwiczeń. 
</p><p>Drugim znakomitycm źródłem przykladów uogólnionego kodu jest
repozytorium bibliotek boost. Stamtąd
też będę podawał przykłady i znów gorąco zachęcam Państwa do
zaglądania tam samemu.
</p><p>Programowanie uogólnione samo w sobie szczególnie obiektowe nie jest,
choć oczywiście wymaga możliwości definiowania własnych typów.  Oba
style programowania: uogólniony i obiektowy można oczywiście stosować
razem. Każdy ma swoje charakterystyczne cechy i aby je  podkreślić
jeszcze raz przypomnę podstawy programowania obiektowego rozumianego
jako programowanie z użyciem interfejsów(klas abstrakcyjnych) i
funkcji wirtulanych.
</p>

<h2>Polimorfizm dynamiczny</h2>
<hr />
<br />

<p>Sercem programowania obiektowego, oczywiście poza koncepcją klasy i
obiektu, jest polimorfizm dynamiczny, czyli możliwość decydowania o tym
jaka funkcja zostanie wywołana pod daną nazwą nie w momencie
kompilacji (czyli pisania kodu), ale w samym momecie wywołania.
Zilustrujemy to na przykładzie. W tym celu skorzystamy z "matki
wszystkich przykładów programowania obiektowego", czyli klasy
kształtów graficznych:).
</p><p>Problem jest następujący: nasz program w pewnym momencie musi
manipulować kształtami graficznym: rysować, przesuwać, obracać itp.
Jest w miarę oczywiste, że każdy kształt będzie posiadał swoją klasę.
Następnym krokiem jest ocena które operacje w naszym kodzie wymagają
szczególowej znajomości kształtu, a które tylko ogólnych jego
własności. Ewidentnie operacja rysowania obiektu należy do tych
pierwszych i musi być zdefiniowana w klasie danego kształtu. Mówimy, że
"obiekt wie jak się narysować". Często mówi się o tym również jako o
ustaleniu odpowiedzialności, czy o podziale obowiązków. Tak więc
ustaliliśmy, że do obowiązków obiektu należy umiejętność narysowania
się. Jeśli tak, to właściwie cała część kodu manipulującego kształtami
nie musi znać szczegółów ich implementacji.  Weźmy na przykład
fragment aplikacji odpowiedzialny za odświeżanie ekranu. Zakładamy, że
wskaźniki do wyświetlanych kształtów są przechowywane w tablicy
<tt>shape_table</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;n;++i<span style="color: #000000;">&#41;</span>
   shape_table<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>-&gt;draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p><font color="red">kod źródłowy</font>

</p><p>Programista piszący ten kod nie musi wiedziec jakiego typu kształt
jest przechowywany w danym elemencie tablicy <tt>shape_table</tt> i jak
jest zaimplementowana funkcja <tt>draw</tt>. Istotne jest by każdy obiekt,
którego wkaźnik przechowywany jest w tej tablicy posiadał metodę
<tt>draw</tt>.  Innymi słowy programista korzysta tu tylko ze znajomości i
dostępności interfejsu obiektów typu kształt, a resztę wykonuje
kompilator, który generuje kod zapewniający wywołanie odpowiedniej
funkcji.  Aby taki interfejs zdefiniować tworzymy abstrakcyjną klasę
obiektów typu kształt:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Shape <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">protected</span>:
  <span style="color: #0000ff;">long</span> <span style="color: #0000ff;">int</span> _x; 
  <span style="color: #0000ff;">long</span> <span style="color: #0000ff;">int</span> _y;
<span style="color: #0000ff;">public</span>:
  Shape<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">long</span> x,<span style="color: #0000ff;">long</span> y<span style="color: #000000;">&#41;</span>:_x<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>,_y<span style="color: #000000;">&#40;</span>y<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">long</span> get_x<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _x;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">long</span> get_y<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _y;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span> draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> = <span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">virtual</span> ~Shape<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło shape.h)
</p><p>Klasa ta stanowić będzie klasę bazową dla wszystkich klas opisujących
kształty. Klasa <tt>Shape</tt> jest klasą abstrakcyjną, ponieważ zawiera
niezaimplementowaną wirtualną  czystą fukcję <tt>void draw()</tt>.
Kod definiujący konkretne klasy kształtów może wyglądać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Rectangle: <span style="color: #0000ff;">public</span> Shape <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">protected</span>:
  <span style="color: #0000ff;">long</span> _ur_x;
  <span style="color: #0000ff;">long</span> _ur_y;
<span style="color: #0000ff;">public</span>:
  Rectangle<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">long</span> ll_x,<span style="color: #0000ff;">long</span> ll_y,<span style="color: #0000ff;">long</span>  ur_x,<span style="color: #0000ff;">long</span> ur_y<span style="color: #000000;">&#41;</span>:
    Shape<span style="color: #000000;">&#40;</span>ll_x,ll_y<span style="color: #000000;">&#41;</span>,_ur_x<span style="color: #000000;">&#40;</span>ur_x-ll_x<span style="color: #000000;">&#41;</span>,_ur_y<span style="color: #000000;">&#40;</span>ur_y-ll_y<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span> draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #666666;">&quot;rectangle : &quot;</span>&lt;&lt;_x&lt;&lt;<span style="color: #666666;">&quot; &quot;</span>&lt;&lt;_y&lt;&lt;<span style="color: #666666;">&quot; : &quot;</span>;
    std::<span style="color: #00eeff;">cerr</span>&lt;&lt;_ur_x+_x&lt;&lt;<span style="color: #666666;">&quot; &quot;</span>&lt;&lt;_ur_y+_y&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">long</span> get_ur_x<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _ur_x;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">long</span> get_ur_y<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _ur_y;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło rectangle.h)
</p><p>i
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Circle: <span style="color: #0000ff;">public</span> Shape <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">protected</span>: 
  <span style="color: #0000ff;">long</span> _r;
 <span style="color: #0000ff;">public</span>:
  Circle<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">long</span> x, <span style="color: #0000ff;">long</span> y,<span style="color: #0000ff;">long</span> r<span style="color: #000000;">&#41;</span> :Shape<span style="color: #000000;">&#40;</span>x,y<span style="color: #000000;">&#41;</span>, _r<span style="color: #000000;">&#40;</span>r<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span> draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #666666;">&quot;Circle : &quot;</span>&lt;&lt;_x&lt;&lt;<span style="color: #666666;">&quot; &quot;</span>&lt;&lt;_y&lt;&lt;<span style="color: #666666;">&quot; : &quot;</span>&lt;&lt;_r&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">long</span> get_r<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _r;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło circle.h)
</p><p>Teraz możemy zdefiniować już  funkcję odświeżającą ekran:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> draw_shapes<span style="color: #000000;">&#40;</span>Shape *table<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;n;++i<span style="color: #000000;">&#41;</span>
    table<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>-&gt;draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło draw.cpp)
</p><p>Funkcja <tt>draw_shapes</tt> wykorzystuje zachowanie polimorficzne: to
która funkcja <tt>draw</tt> zostanie wywołana zależy od tego jaki
konkretny kształt jest wskazywany przez element tablicy. 
Łatwo się o tym przekonać wykonując np. następujący kod
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  Shape *list<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">4</span><span style="color: #000000;">&#93;</span>;
  list<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">new</span> Circle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
  list<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">new</span> Rectangle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">20</span>,<span style="color: #0000dd;">20</span>,<span style="color: #0000dd;">80</span>,<span style="color: #0000dd;">80</span><span style="color: #000000;">&#41;</span>;
  list<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">new</span> Circle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span>,<span style="color: #0000dd;">10</span>,<span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
  list<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">new</span> Rectangle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">20</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">80</span>,<span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>;
  draw_shapes<span style="color: #000000;">&#40;</span>list,<span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p><font color="red">kod źródłowy</font>

</p><p>W ten sposób zaimplementowaliśmy podstawowy paradygmat programowania
obiektowego: rozdzielenie interfejsu od implementacji za pomocą
abstrakcyjnej klasy bazowej i wykorzystanie funkcji wirtualnych.
Ważną częścią tego procesu jest więc właśnie odpowiedni wybór
interfejsów (klas bazowych).
</p>

<h2>Polimorfizm statyczny</h2>
<hr />
<br />

<p>Patrząc na kod funkcji <tt>draw_shapes</tt> możemy zauważyć, że korzysta on
jedynie z własności posiadania przez wskazywane obiekty metody
<tt>draw()</tt>. To sygnatura, czyli typ parametru wywołania tej funkcji
określa, że musi to być wskaźnik na typ <tt>Shape</tt>.  Z poprzedniego
wykładu pamiętamy, że możemy zrezygnować z wymuszania typu argumentu
wywołania funkcji poprzez użycie szablonu funcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">void</span> draw_template<span style="color: #000000;">&#40;</span>T table<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;n;++i<span style="color: #000000;">&#41;</span>
    table<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>.<span style="color: #00eeff;">draw</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło draw_template.h)
</p><p>Taką funkcję możemy wywołać dla dowolnej tablicy, byle tylko
przechowywany typ posiadał metodę <tt>draw</tt>. Mogą to być obiekty typów
<tt>Circle</tt> i <tt>Rectangle</tt> (nie <tt>Shape</tt>, obiekty klasy <tt>Shape</tt>
nie istnieją!),  ale też inne zupełnie z nimi nie związane.
Ilustruje to poniższy przykład:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Drawable <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> draw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>cerr&lt;&lt;<span style="color: #666666;">&quot;hello world!&quot;</span>&lt;&lt;endl;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">int</span> main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  Drawable table_d<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span>=<span style="color: #000000;">&#123;</span>Drawable<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#125;</span>;
  Circle   table_c<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span>=<span style="color: #000000;">&#123;</span>Circle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span>,<span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>,Circle<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">50</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  draw_template<span style="color: #000000;">&#40;</span>table_d,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
  draw_template<span style="color: #000000;">&#40;</span>table_c,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p><font color="red">kod źródłowy</font>
</p>

<p>Korzystając z szablonów uzyskaliśmy więc również pewien efekt
zachowania polimorficznego. W przeciwieństwie do poprzedniego
przykładu jest to polimorfizm statyczny: to kompilator zadecyduje na
podstawie typu tablicy jaką funkcję <tt>draw</tt> wywołać. Oczywiście w
rozważanym przypadku to podejście jest całkowicie nieadekwatne, mamy
bowiem do czynienia z niejednorodną rodziną kształtów, a wybór
konkretnych kształtów dokunuje się podczas wykonywania programu.
Podając przykład z szablonami chciałem tylko podkreślić różnice
pomiędzy tymi dwoma technikami.  Przykłady kiedy to szablony okazują
się lepszym rozwiązaniem zostały podane w poprzednim wykładzie.
</p>

<h2>Polimorfizm statyczny vs. dynamiczny</h2>
<hr />
<br />

<p>Jak już wspomniałem każdy styl posiada swoje cechy, które w zależności
od okoliczności mogą być postrzegane jako wady lub zalety. Poniżej
podaję zebrane głowne właściwości każdego podejścia.
</p>

<ol><li> Dziedzieczenie i funkcje wirtualne
<ol><li> umożliwia pracę ze zbiorami niejednorodnych obiektów i korzysta z polimorfizmu dynamicznego
</li><li> wymaga wspólnej hierarchii dziedziczenia
</li><li> wymusza korzystanie ze wskaźników lub referencji i funkcji wirtualnych
</li><li> zazwyczaj generuje mniejszy kod.
</li></ol>
</li><li> Szablony
<ol><li> implementuje polimorfizm statyczny
</li><li> bezpiecznie obsługuje jednorodne zbiory obiektów
</li><li> nie trzeba korzystać ze wskaźników i referencji ani funkcji wirtualnych
</li><li> nie musimy korzystać ze wspólnej hierarchii dziedziczenia.
</li></ol>
</li></ol>

<h2>Koncepty</h2>
<hr />
<br />

<p>Przyjrzyjmy się jeszcze raz deklaracji funkcji <tt>draw_shapes</tt> i
<tt>draw_template</tt>. Kiedy programista widzi deklarację:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> draw_shapes<span style="color: #000000;">&#40;</span>Shape *table<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span></pre></div>

<p>wie, że interfejs wykorzystywany przez funkcję <tt>draw</tt> jest
zdefiniowany przez klasę <tt>Shape</tt>. Aby go poznać musi przeczytać kod
i dokumentację tej klasy. 
Natomiast kiedy programista widzi deklarację:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">void</span> draw_template<span style="color: #000000;">&#40;</span>T table<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span>;</pre></div>

<p>to musi prześledzić kod funkcji <tt>draw_templates</tt> aby poznać
ograniczenia nałożone na argument szablonu <tt>T</tt>. W tym przypadku nie
jest to trudne, ale ogólnie może to być nietrywialne zadanie.
</p>

<p>Zamiast jednak definiować ograniczenia i warunki dla każdego szablonu
osobno, możemy szukać wspólnych, powtarzających się zestawów warunków.
Taki zestaw nazwiemy konceptem i będziemy go traktować jako
abstrakcyjną definicję całej rodziny typów, niezależną od konkretnego
szablonu. Typ spełniający warunki konceptu nazywamy modelem konceptu
lub mówimy, że modeluje ten koncept.  Mając wybrany, dobrze
przygotowany zestaw konceptów dla danej dziedziny, możemy się nimi
posługiwać przy definiowaniu typów i algorytmów uogólnionych. 
</p>

<p>Koncepty mogą tworzyć hierachie analogiczne do hierarachii
dziedziecznia. Mówimy, że koncept <tt>A</tt> jest bardziej wyspecjalizowany
niż <tt>B</tt> (<tt>A</tt> is-refinement-of <tt>B</tt>), jeśli zestaw ograniczeń
konceptu <tt>B</tt> zawiera się w zestwie ograniczeń konceptu <tt>A</tt>.
Będę też używał określenia <tt>A</tt> jest "uszczegółowieniem" <tt>B</tt>.  
</p><p>Pojęcie konceptu pełni więc przy programowaniu za pomocą szablonów
podobną rolę jak pojęcie interfejsu przy programowaniu za pomocą
abstrakcyjnych klas bazowych i polimorfizmu dynamicznego. W
przeciwieństwie do interfejsu jest to jednak pojęcie bardziej
"ulotne", bo nie narzucamy go za pomocą formalnej definicji klasy
abstrakcyjnej. Koncepty definiujemy poprzez mniej lub bardziej
ścisłe  wypisanie nakładanych przez nie  ograniczeń. Ograniczenia te
mogą zawierać między  innymi:
</p>

<ol><li> Prawidłowe wyrażenia. Zestaw wyrażeń języka C++, które muszą się poprawnie kompilować.
</li><li> Typy stowarzyszone. Ewentualne dodatkowe typy występujące w prawidłowych wyrażeniach.
</li><li> Semantyka: zanczenie wyrażeń. Jednym ze sposobów określanie semantyki jest podawanie niezmienników, czyli wyrażeń, które dla danego konceptu są zawsze prawdziwe.
</li><li> Złożoność algorytmów. Gwarancje co do czasu i innych zasobów potrzebnych do wykonania danego wyrażenia.
</li></ol>

<p>Programowanie uogólnione polega więc na wyszukiwaniu konceptów na
tyle ogólnych, aby pasowały do dużej liczby typów i na tyle
szczegółowych, aby zezwalały na wydajną implementację. 
</p>

<h3>Definiowanie konceptów</h3>
<hr />
<br />


<p>Weźmy za przykład szablon funkcji <tt>max</tt> z poprzedniego wykładu
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>


<p>i zastanówmy się, jakie koncepty możemy odkryć w tak prostym
kodzie.
</p><p>Zacznijmy od gramatyki.  Jakie warunki musi spełniać typ <tt>T</tt>, aby
podstawienie go jako argument szablonu <tt>max</tt> dawało poprawne
wyrażenie? Oczywistym warunkiem jest, że dla tego typu musi być
zdefiniowany operator porównania <tt>bool operator>(...)</tt>. Specjalnie
nie wyspecyfikowałem sygnatury tego operatora. Nie ma np. znaczenia
jak parametry są przekazywane, co więcej <tt>operator>(...)</tt> może być
zdefiniowany jako składowa klasy i posiadać tylko jeden jawny argument. 
Ważne jest to, że jeśli <tt>x</tt> i <tt>y</tt> są obiektami typu <tt>T</tt>
to wyrażenie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">x&gt;y</pre></div>

<p>jest poprawne (skompiluje się). 
</p><p>Łatwiej jest przeoczyć fakt,
że ponieważ argumenty wywołania są zwracane i przekazywane przez
wartość, to typ <tt>T</tt> musi posiadać konstruktor kopiujący. Oznacza to, że 
jeśli <tt>x</tt> i <tt>y</tt> są obiektami typu <tt>T</tt> to wyrażenia:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
T x<span style="color: #000000;">&#40;</span>y<span style="color: #000000;">&#41;</span>;
T x = y;</pre></div>

<p>są poprawne.
</p><p>Przykład 2.1
</p>


<p>Spełnienie obydwu tych warunków zapewni nam poprawność gramatyczną
wywołania szablonu z danym typem, tzn. kod się skompiluje.
</p><p>A co z poprawnością semantyczną? Mogłoby sie wydawać, że jest bez znaczenia 
jak zdefiniujemy <tt>operator>(...)</tt>. 
Koncept  typu <tt>T</tt> jest jednak częścią kontraktu dla
funkcji <tt>max</tt>. Kontraktu zawieranego pomiędzy twórcą tego wielce
skomplikowanego kodu, a jego użytkownikiem. Kontrakt stanowi, że jeżeli
użytkownik dostarczy do funkcji argumenty o typach zgodnych z
konceptem i o wartościach spełniających być może inne warunki wstępne,
to twórca funkcji gwarantuje, że zwróci ona poprawny wynik.  
</p><p>Zastanówny się więc jak zdefiniować poprawność dla funkcji maksimum. Z
definicji maksimum żaden element argument funkcji <tt>max</tt> nie może być
większy od wyniku, czyli wyrażenie
</p>

<div style="text-align: center">\(!( a> max(a,b) ) \wedge!(b> max(a,b)) \quad\mbox{(2.1)}\)</div>
<p>musi być zawsze prawdziwe.  Jasne jest, że jeśli dla jakiegoś typu
<tt>X</tt> zdefiniujemy operator porównania tak, aby zwracał zawsze prawdę
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">bool</span> operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> X &amp;a,<span style="color: #0000ff;">const</span> X &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">1</span>;<span style="color: #000000;">&#125;</span></pre></div>


<p>lub aby był równoważny operatorowi równości:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">bool</span> operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> X &amp;a,<span style="color: #0000ff;">const</span> X &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> a==b;<span style="color: #000000;">&#125;</span></pre></div>

<p>to wyrażenie 2.1 nie może być prawdziwe dla żadnej
wartości <tt>a</tt> i <tt>b</tt>. Aby funkcja <tt>max</tt> mogła spełnić swój
warunek końcowy musimy narzucić pewne ograniczenia semantyczne na
<tt>operator>()</tt>. Te warunki to żądanie, aby relacja większości
definiowana przez ten operator byłą relacją porządku częściowego, a
więc aby spełnione było
</p>

<div style="text-align: center">\((x>x) = false\) i \((x>y) \wedge (y>z) => (x>z)\)</div>

<p>To rozumowanie możnaby ciągnąć dalej i zauważyć, że nawet z tym
ograniczeniem uzyskamy nieintuicyjne wyniki w przypadku, gdy obiekty
<tt>a</tt> i <tt>b</tt> będą nieporównywalne, tzn. \(!(a>b)\) i \(!(b>a)\).
</p><p>Poprawność semantyczną konstruktora kopiującego jest trudniej
zdefiniować, ograniczymy się więc tylko do stwierdzenia, że wykonanie
operacji 2.1 powoduje powstanie kopii obiektu <tt>x</tt>
(cokolwiek by to nie znaczyło).
</p>

<h3>Comparable i Assignable</h3>
<hr />
<br />

<p>Reasumując, dostajemy zbiór warunków, które musi
spełniać typ <tt>T</tt>, aby móc go podstawić do szablonu funkcji <tt>max</tt>.
Czy to oznacza, że zdefiniowaliśmy już poprawny koncept? Żeby się o tym
przekonać spróbujmy go nazwać. Narzuca się nazwa w stylu
<tt>Comparable</tt>, ale wtedy łatwo zauważyć, że istnienie konstruktora
kopiującego nie ma z tym nic wspólnego. Próbujemy upchnąc dwa
niezależne pojęcia do jednego worka. Co więcej bardzo łatwo jest
zrezygnować z konieczności posiadania konstruktora kopiujacego,
zmieniając deklarację <tt>max</tt> na:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">const</span> T&amp; max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T&amp;,<span style="color: #0000ff;">const</span> T&amp;<span style="color: #000000;">&#41;</span>;</pre></div>

<p>Teraz argumenty i wartość zwracana przekazywane są przez referencję i
nie ma potrzeby kopiowania obiektów. 
</p><p>Logiczne jest więc wydzielenie dwu konceptów: jednego definiującego
typy porównywalne, drugiego - typy "kopiowalne".  Dalej możemy
zauważyć, że istnienie operatora <tt>></tt> automatycznie pozwala na
zdefiniowanie operatora <tt>&lt;</tt> poprzez:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">bool</span> operator&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T&amp; a,<span style="color: #0000ff;">const</span> T&amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> b&gt;a;<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Podobnie istnienie konstruktora kopiującego jest blisko związane z
istnieniem operatora przypisania. 
</p><p>Tak więc dochodzimy do dwu konceptów: <tt>Comparable</tt> reprezentującego
typy, których obiekty można porównywać za pomocą operatorów <tt>&lt;</tt> i
<tt>></tt> oraz <tt>Assignable</tt> reprezentujacego typy, których
obiekty możemy kopiować i przypisywać do siebie.  Taką
zabawę można kontynuować, pytając np. co z operatorem porównania
<tt>operator==()</tt>?, co z konstruktorem defaultowym? itd. Widać więc, że
koncepty to sprawa subietywna, ale to żadna nowość. Wybór używanych
abstrakcji jest zawsze sprawą mniej lub bardziej subiektywną i silnie
zależną od rozpatrywanego problemu. O tym czy dwa pojęcia włączymy do
jednego konceptu czy nie decyduje np. odpowiedź na pytanie czy
prawdopodobne jest użycie kiedykolwiek któregoś z tych pojęć osobno? 
</p><p>Tak więc zanim zaczniemy defniować koncepty musimy ustalić w jakim
kontekście je rozpatrujemy. Na tym wykladzie kontekstem jest STL i oba
wprowadzone koncepty są wzorowane na koncetach z
STL-a.  Należy jednak nadmienić, że pojęcie
konceptu nie pojawia się wprost w definicji stadardu C++. Najlepiej
koncepty STL przedstawione są na stronach firmy SGI dokąd Państwa odsyłam.
</p>


<h2>STL</h2>
<hr />
<br />

<p>Standardowa Biblioteka Szablonów (STL) to doskonałe narzędzie
programistyczne zawarte w standardzie C++.  Stanowi ona również
znakomity, niejako sztandarowy, przykład programowania uogólnionego.
Na tę bibliotekę można patrzeć więc dwojako: jako rozszerzenie języka
C++ o dodatkowe funkcje lub jako na zbiór konceptów stanowiących
podstawę do projetowania programów uogólnionych. Ja chciałbym
podkreślić tutaj ten drugi aspekt, podkreślając jednak, że dobre poznanie
możliwości STL-a może bardzo ułatwić Państwu prace programistyczne.
</p><p>Biblioteka składa się zasadniczo z dwu części: uogólnionych kontenerów 
i uogólnionych algorytmów. Trzecią cześcią, niejako sklejającą te dwie, są 
iteratory. 
</p><p>Kontenery to obiekty służące do przechowywania innych obiektów.
Kontenery w STL są jednorodne, tzn. mogą przechowywać tylko zbiory
(kolekcje) obiektów tego samego typu. Kluczem do efektywnego
programowania uogólnionego jest jednak sprawa ujednolicenia dostępu do
zawartości kontenera. Rozważmy dla przykładu dwa typowe kontenery
<tt>vector</tt> i <tt>list</tt>, implementujące odpowiednio "inteligentną"
tablicę oraz listę dwukierunkową. Naturalnym sposobem dostępu do
tablicy jest indeksowanie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">vector</span>&lt;int&gt; v<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>;
v<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">8</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">1</span>;</pre></div>

<p>a listy przeglądamy po kolei, przesuwając się o jeden element w przód czy w tył
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Uwaga! To nie jest kod STL-owy !!!
lista&lt;int&gt; l;
l.<span style="color: #00eeff;">reset</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; ustawia element bieżacy na początek listy
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;<span style="color: #0000dd;">8</span>;i++<span style="color: #000000;">&#41;</span>
     l.<span style="color: #00eeff;">next</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; przesuwa element bieżący o jeden element <span style="color: #0000ff;">do</span> przodu
&nbsp;
l.<span style="color: #00eeff;">current</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>=<span style="color: #0000dd;">1</span>; zwraca referencję <span style="color: #0000ff;">do</span> elementu bieżącego</pre></div>

<p>Widać, że w takim sformułowaniu praktycznie nie jest możliwe napisanie
ogólnego kodu np. dodającego wszystkie elementy kontenera czy
wyszukującego jakiś element w kontenerze. Ponadto opisany sposób
dostępu do listy ogranicza nas do korzystania z jednego bieżącego
elementu na raz. 
</p><p>Rozwiązaniem tego problemu zastosowanym w STL jest koncept iteratora,
który definiuje abstrakcyjny interfejs dostępu do elementów kontenera.
W STL iterator posiada semantykę wskaźnika, w szczególności może być
zwykłym wskaźnikiem, choć normalnie jest to wskaźnik inteligentny.
Każdy kontener posiada zestaw funkcji zwracających iteratory do
swojego początku i na swój koniec.  Korzystając z nich można listę
przeglądać następująco
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">list</span>&lt;int&gt; l;
tu jakoś inicjalizujemy liste
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>list&lt;int&gt;::<span style="color: #00eeff;">iterator</span> it=l.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;it!=l.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;it++<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
     każdy kontener definiuje typ stowarzyszony nazwany iterator
  cout&lt;&lt;*it&lt;&lt;endl;
     korzystamy z iteratorów jak ze zwykłych wskaźników
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>

<p>Przykładowy ogólny algorytm oparty o iteratory może wyglądać w ten sposób:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator, <span style="color: #0000ff;">class</span> T&gt;
T accumulate<span style="color: #000000;">&#40;</span>InputIterator first, InputIterator last, T init<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
T total=init;
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>;; first;!= last;++first<span style="color: #000000;">&#41;</span> 
   total+= *first;
<span style="color: #0000ff;">return</span> total;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: accumulate.cpp)
</p><p>Oczywiście nie da się zignorować fundamentalnych różnic pomiędzy listą
a wektorem. Dlatego np. iterator wektora zezwala na konstrukcje
<tt>it[i]</tt>, a iterator listy już nie. Oznacza to, że algorytm, który
działa dla iteratorów wektora (np. <tt>sort</tt>), nie musi działać dla
iteratora listy. W języku konceptów oznacza to, że
<tt>std::vector<T>::iterator</t></tt> jest modelem konceptu bardziej
wyspecjalizowanego niż koncept, którego modelem jest
<tt>std::list<T>::iterator</t></tt>. Zobaczymy to w następnej części tego
wykładu.
</p>

<h3>Kontenery</h3>
<hr />
<br />

<p>Standard C++  definiuje dwa zestawy kontenerów wchodzące w skład STL:
</p>

<ol><li>Sekwencje czyli pojemniki, w których kolejność elementów jest ustalana przez korzystającego z pojemnika (klienta) są to: 
<ol><li> <tt>vector</tt>
</li><li> <tt>deque</tt>
</li><li> <tt>list</tt>
</li></ol>
</li><li> Kontenery asocjacyjne, czyli pojemniki, w których klient nie ma kontroli nad kolejnością elementów, są to:
<ol><li> <tt>set</tt>
</li><li> <tt>map</tt>
</li><li> <tt>multiset</tt>
</li><li> <tt>multimap</tt>
</li></ol>
</li></ol>

<p>Ponadto różni dostawcy oferują dodatkowe pojemniki. Na uwagę zasługuje
znakomita darmowa implementacja STL firmy Silicon Graphics, która
miedy innymi wchodzi w skład pakietu g++ i dostarcza dodatkowo takich
kontenerów jak: lista jednokierunkowa <tt>slist</tt> oraz tablice
haszujące <tt>hash_set</tt> czy <tt>hash_map</tt> (zob. STL). Hierachię
konceptów kontenerów typu sekwencji przedstawia rysunek 2.1, a kontenerów asocjacyjnych rysunek 2.2.
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-2-1.png" alt="Rysunek 2.1. Hierarchia konceptów dla pojemników typu sekwencyjnego." title="Rysunek 2.1. Hierarchia konceptów dla pojemników typu sekwencyjnego."  class="image image-_original " width="592" height="391" /><span class="caption"><strong>Rysunek 2.1. Hierarchia konceptów dla pojemników typu sekwencyjnego.</strong></span></span>
<br />


<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-2-2.png" alt="Rysunek 2.2. Hierarchia konceptów dla pojemników typu asocjacyjnego." title="Rysunek 2.2. Hierarchia konceptów dla pojemników typu asocjacyjnego."  class="image image-_original " width="599" height="395" /><span class="caption"><strong>Rysunek 2.2. Hierarchia konceptów dla pojemników typu asocjacyjnego.</strong></span></span>

<p>Nie będę tu omawiał tych wszystkich konceptów. Ich szczegółowe opisy
znajdują się na stronie <a href="http://www.sgi.com/tech/stl/" title="http://www.sgi.com/tech/stl/">http://www.sgi.com/tech/stl/</a>. Tutaj chciałbym tylko dodać parę luźnych
komentarzy.
</p><p>Po pierwsze, rodzi się pytanie czy taka skomplikowana taksonomia jest
potrzebna?  W końcu patrząc na rysunki widać, że konceptów jest dużo
więcej niż typów kontenerów. Rzeczywiście, do posługiwania się biblioteką
w zasadzie wystarczy zaznajomić się z opisami kontenerów i hierarchią
iteratorów (zob. rysunek 2.3).  Podane klasyfikacje przydają się dopiero kiedy dodajemy własne elementy do biblioteki.
Dobierając do implemetacji najbardziej ogólny koncept spełniający
nasze wymagania zwiększamy potencjał ponownego użycia naszego kodu z
innymi komponentami biblioteki, czy kodem innych developerów.
</p><p>Kontenery z STL są właścicielami swoich elementów, zniszczenie
kontenera powoduje zniszczenie jego elementów.  Wszytkie operacje
wkładania elementów do kontenera używają przekazywania przez wartość,
czyli kopiują wkładany obiekt. Jeżeli chcemy, aby czas życia elementów
kontenera był dłuższy od czasu życia kontenera, należy użyć wskaźników. 
</p><p>Kontenery różnią się nie tylko rodzajem iteratorów, jaki implementują,
ale również rodzajem operacji, które można wykonać bez unieważnienia
istniejących iteratorów. Pokażę to na przykładzie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">vector</span>&lt;int&gt;::<span style="color: #00eeff;">iterator</span> it;
<span style="color: #0000ff;">int</span> i;
&nbsp;
std::<span style="color: #00eeff;">vector</span>&lt;int&gt; v<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
std::<span style="color: #00eeff;">vector</span>&lt;int&gt; buff<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>; staramy się zająć pamięć za v
&nbsp;
v<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">0</span>;
it=v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
i=<span style="color: #000000;">&#40;</span>*it<span style="color: #000000;">&#41;</span>; OK, przypisuje i=<span style="color: #0000dd;">0</span>
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;<span style="color: #0000dd;">10</span>;++i<span style="color: #000000;">&#41;</span>
  v.<span style="color: #00eeff;">push_back</span><span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&#41;</span>;   
    ponieważ przekraczamy koniec wektora, kontener zaalokuje dodatkową pamięć. <span style="color: #00eeff;">Mo</span>że
    się to wiązać z koniecznośćią przeniesienia zawartości wektora v w inne miejsce 
    pamięci. <span style="color: #00eeff;">To</span> spowoduje, że wskaźnik it przestanie pokazywać na początek wektora v
&nbsp;
std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #000000;">&#40;</span>*it<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span> ;                  niezdefiniowane
&nbsp;
std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #666666;">&quot;iterator nieprawidlowy&quot;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>; 
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>;it != v.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; ++it<span style="color: #000000;">&#41;</span>  potencjalnie nieskończona pętla  
  std::<span style="color: #00eeff;">cerr</span>&lt;&lt;*it&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
;
&nbsp;
std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #666666;">&quot;iterator prawidlowy&quot;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>; 
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>it=v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;it != v.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; ++it<span style="color: #000000;">&#41;</span>  
std::<span style="color: #00eeff;">cerr</span>&lt;&lt;*it&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
;</pre></div>

<p>( Źródło: invalid.cpp)
</p><p>Bardzo Państwa na ten problem uczulam. Efekt działania powyższego kodu
jest gorzej niż zły: jest niezdefiniowany!, tzn. będzie zależał od
implementacji kompilatora, od zadeklarownych wcześniej zmiennych itp.
Proszę np. spróbować wykomentować linijkę
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">vector</span>&lt;int&gt; buff<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>; staramy się zająć pamięć za v</pre></div>


<p>i porównać wynik działania programu.  Może się również zdarzyć, że
program zadziała poprawnie (wbrew pozorom jest to najgorsza
możliwa sytuacja!).
</p><p>Ważne są gwarancje złożoności metod kontenera.  Ewidentnie każdy
rodzaj kontenera może dostarczyć każdego rodzaju operacji, różny
będzie jednak czas ich wykonywania. I tak rząd O(1) jest gwarantowany w operacji indeksowania
wektora. Natomiast operacja dodania
elementu w środku wektora jest rzędu O(N). Z listą jest odwrotnie i
dlatego listy w STL nie posiadają operacji indeksowania. 
</p><p>Nie wszystkie własności kontenerów są zdefiniowane w konceptach.
Każdy kontener może definiować dodatkowe metody właściwe tylko
dla niego.
</p>

<h3>Iteratory</h3>
<hr />
<br />


<p>Iteratory to koncept, który uogólnia pojęcie wskaźnika. 
Hierarchię konceptów iteratorów przedstawia rysunek 2.3. Zaznaczono na nim również które 
koncepty kontenerów wymagają danego modelu iteratora.
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-2-3.png" alt="Rysunek 2.3. Hierarchia konceptów dla iteratorów." title="Rysunek 2.3. Hierarchia konceptów dla iteratorów."  class="image image-_original " width="596" height="396" /><span class="caption"><strong>Rysunek 2.3. Hierarchia konceptów dla iteratorów.</strong></span></span>
<br />

<p>Najprostsze iteratory pojawiające sie w STL-u to iteratory wejściowe i
wyjściowe. Wprawdzie żaden kontener nie posiada iteratorów tego typu,
ale iteratory wejściowe, umożliwiające tylko jednoprzebiegowe
odczytanie wartości kontenera, są częstym wymaganiem dla argumentów
algorytmów nie zmieniających elementów kontenera (non mutable
algorithms).
</p><p>Należy pamiętać, że iterator nie wie na jaki kontener wskazuje, czyli
poprzez iterator nie ma dostępu do interfejsu kontenera.
</p><p>Iteratory pozwalają na określanie zakresu elementów w kontenerze poprzez
podanie iteratora wskazującego na początek i na pierwszy element poza
końcem zakresu.  Zakres oznaczamy poprzez (<tt>it1</tt>,<tt>it2</tt>) (zob. rysunek 2.4).  
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-2-4_1.png" alt="Rysunek 2.4. Zakres." title="Rysunek 2.4. Zakres."  class="image image-_original " width="498" height="195" /><span class="caption"><strong>Rysunek 2.4. Zakres.</strong></span></span><br />


<p>Z tego powodu dozwolona jest instrukcja
pobrania adresu pierwszego elementu poza końcem tablicy.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#93;</span>;
<span style="color: #0000ff;">double</span> *end=&amp;x<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#93;</span>;
<span style="color: #ff0000;">//zwykłe wskażniki mogą być użyte jako iteratory</span>
std::<span style="color: #00eeff;">cout</span>&lt;&lt;accumulate<span style="color: #000000;">&#40;</span>x,end,<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl; &lt;i&gt;suma elementów tablicy&lt;/i&gt;</pre></div>

<p>Każdy kontener posiada motody <tt>begin()</tt> i <tt>end()</tt>, zwracające
iterator na początek i "poza koniec". Typowa pętla obsługi kontenera
wygląda więc następująco:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">typedef</span> vector&lt;int&gt;::<span style="color: #00eeff;">iterator</span> iterator;
vector&lt;it&gt; v<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>iterator it=v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;it!=v.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;++it<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 ...
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: accumulate.cpp)
</p><p>Proszę zwrócić uwagę na wykorzystanie operatora <tt>!=</tt> do sprawdzenia
końca zakresu. Tylko iteratory o dostępie swobodnym mogą być
porównywane za pomocą operatora <tt>operator&lt;()</tt>. Reszta jest tylko
<tt>EqualityComparable</tt>.
</p>


<h3>Algorytmy</h3>
<hr />
<br />

<p>Algorytmy działają na zakresach elementów kontenera definiowanych
przez dwa iteratory, a nie na kontenerach. Umożliwia to jednolity
dostęp do różnych kontenerów.  Takie podejście ma też inne
konsekwencje, jak już pisałem iterator nie wie z jakiego kontenera
pochodzi, w szczególności oznacza to, że algorytmy ogólne nie mogą
usuwać elementów z kontenera. 
</p><p>Oczywiście część algorytmów, np.
<tt>sort</tt>, wymaga bardziej wyrafinowanych iteratorów, nie dostarczanych
przez każdy kontener.  Wiele jednak jednoprzebiegowych algorytmów
zadawala się iteratorami wejściowymi. 
</p><p>Poza iteratorami uogólnione algorytmy wykorzystują obiekty funkcyjne
czyli funktory. Obiekt funkcyjny to koncept będący uogólnieniem
pojęcia fukcji, czyli coś do czego można zastosować składnię
wywołania funkcji. W C++ mogą to być funkcje, wskaźniki do funkcji
oraz obiekty klas, w których zdefiniowano <tt>operator()(...)</tt> .
</p><p>Funktory w STL są podzielone ze względu na liczbę argumentów wywołania.
<tt>Generator</tt> nie przyjmuje żadnego argumentu, <tt>UnaryFunction</tt>
posiada jeden argument, a <tt>BinaryFunction</tt> - dwa argumenty wywołania.
Ważną podklasą są funkcje zwracające wartość typu <tt>bool</tt>, nazywane
predykatami. Rozróżniamy więc  <tt>UnaryPredicate</tt> i
<tt>BinaryPredicate</tt>.
</p><p>Żeby zilustrować użycie algorytmów i funktorów rozważmy następujący
przykład.  Najpierw definiujemy funktor, który posłuży nam do
generowania sekwencji obiektów:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> SequenceGen <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:
  T _start; 
  T _step;
<span style="color: #0000ff;">public</span>:
  SequenceGen<span style="color: #000000;">&#40;</span>T start = T<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,T step = <span style="color: #0000dd;">1</span> <span style="color: #000000;">&#41;</span>:
  _start<span style="color: #000000;">&#40;</span>start<span style="color: #000000;">&#41;</span>,_step<span style="color: #000000;">&#40;</span>step<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  T operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>T tmp=_start; _start+=_step; <span style="color: #0000ff;">return</span> tmp;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: bind.cpp)
</p><p>Za pomocą obiektu klasy <tt>SequenceGen</tt> możemy wypełnić wektor
sekwencją 20 pierwszych nieparzystych liczb całkowitych:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">size_t</span> n = <span style="color: #0000dd;">20</span> ;
vector&lt;int&gt; v<span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span>;
generate_n<span style="color: #000000;">&#40;</span>v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,n,SequenceGen&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>( Źródło: bind.cpp)
</p><p>Standardowy algorytm
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class OutputIterator, <span style="color: #0000ff;">class</span> Size, <span style="color: #0000ff;">class</span> Generator&gt;
OutputIterator generate_n<span style="color: #000000;">&#40;</span>OutputIterator first, 
                          Size n, Generator gen<span style="color: #000000;">&#41;</span>;</pre></div>


<p>służy właśnie do wypełniania kontenerów za pomocą <tt>n</tt> kolejnych
wyników wywołania funktora <tt>gen</tt>.  Powyższy kod ilustruje typowy
sposób opisu algorytmów w STL. Nazwy parametrów szablonu odpowiadają
nazwom konceptów, które muszą modelować.  
</p><p>W tak wypełnionym kontenerze
poszukamy pierwszego elementu większego od czterech (powinno to być
pięć). Służy do tego algorytm 
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;class InputIterator, <span style="color: #0000ff;">class</span> Predicate&gt;
InputIterator find_if<span style="color: #000000;">&#40;</span>InputIterator first, 
                      InputIterator last,
                      Predicate pred<span style="color: #000000;">&#41;</span>;</pre></div>


<p>Który przeszukuje zakres <tt>[first,last)</tt> do napotkania pierwszego
elementu, dla którego predykat <tt>pred</tt> jest prawdziwy i zwraca
iterator do tego elementu. Jeśli takiego elementu nie ma, to
<tt>find_if</tt> zwraca <tt>last</tt>. Do zakończenia programu potrzebujemy
jeszcze predykatu, który testuje czy dana wartość jest większa od
czterech. Zamiast go implementować skorzystamy z adaptera funkcji
<tt>bind2nd</tt>.  Ta funkcja przyjmuje funktor dwuargumentowy
(<tt>AdaptableBinaryFunction</tt>) <tt>F(T,U)</tt> i jakąś wartość <tt>x</tt> typu
<tt>U</tt> i zwraca funktor jednoparametrowy <tt>F(T,x)</tt>. Korzystając z
predefiniowanego predykatu <tt>greater</tt> możemy napisać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">vector&lt;int&gt;::<span style="color: #00eeff;">iterator</span> it= find_if<span style="color: #000000;">&#40;</span>v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,v.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,
                                  bind2nd<span style="color: #000000;">&#40;</span>greater&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>it!=v.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>
  cout&lt;&lt;*it&lt;&lt;endl;
<span style="color: #0000ff;">else</span>
  cout&lt;&lt;<span style="color: #666666;">&quot;nie znaleziono zadanego elementu&quot;</span>;
<span style="color: #000000;">&#125;</span></pre></div>



<p>( Źródło: bind.cpp)
</p><p>STL wprowadza więc do C++ elementy programowania funkcyjnego.
</p>

<h2>Debugowanie</h2>
<hr />
<br />

<h3>Sprawdzanie konceptów</h3>

<p>Programowanie uogólnione korzysta istotnie z pojęcia konceptu. Koncept
opisuje abstrakcyjne typy danych (czy funkcji), które mogą być użyte
jako argumenty danego szablonu. Definiowanie konceptu polega tylko na
jego opisie. C++ nie posiada żadnego mechanizmu pozwalającego na
bardziej formalną definicję. Co za tym idzie, nie  można
też automatycznie sprawdzać czy nasz typ modeluje żądany koncept.
</p><p>Oczywiście kompilator podczas konkretyzacji szablonu sprawdza
syntaktyczną zgodność przekazanego typu z wymaganiami szablonu. Nie
jest to jednak idealne narzędzie diagnostyczne. Po pierwsze, komunikat
o błedzie może być bardzo zawiły i na pewno nie będzie się odnosił do
nazwy konceptu. Po drugie, może się okazać, że szablon, który
konkretyzujemy nie wykorzystuje wszystkich możliwych wyrażeń konceptu.
Zresztą idea konceptu polega na rozdzieleniu definicji abstrakcyjnego
typu od definicji szablonu, którego ten typ może być argumentem.
Rozwiazaniem jest napisanie własnego zestawu szablonów, których
jedynem zadaniem jest sprawdzanie zgodności przekazanych argumentów
szablonu z definiowanym przez ten szablon konceptem. Niestety, można w
ten sposób sprawdzać tylko zgodność syntaktyczną. 
</p><p>Idea tworzenia takich szablonów jest prosta (zob. <a href="http://www.boost.org/libs/concept_check/concept_check.htm" title="http://www.boost.org/libs/concept_check/concept_check.htm">http://www.boost.org/libs/concept_check/concept_check.htm</a>): dla każdego
konceptu tworzymy szablon zawierający funkcję <tt>constraints()</tt>, która
zawiera wszystkie możliwe poprawne wyrażenia dla danego konceptu. Np.
dla konceptu <tt>Comparable</tt> możemy zdefiniować:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> ComparableConcept <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">void</span> constraints<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  require_boolean_expr<span style="color: #000000;">&#40;</span> a &gt; b<span style="color: #000000;">&#41;</span>;
  require_boolean_expr<span style="color: #000000;">&#40;</span> a &lt; b<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;
T a,b; 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: concept_check.cpp)
</p><p>Szablon <tt>require_boolean_expr</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class TT&gt;
 <span style="color: #0000ff;">void</span> require_boolean_expr<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> TT&amp; t<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   <span style="color: #0000ff;">bool</span> x = t;
   ignore_unused_variable_warning<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
   używa zmiennej x aby kompilator nie generował ostrzeżenia
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: concept_check.cpp)
</p><p>sprawdza czy jego argument, a więc wartość zwracana przez operatory,
może być konwertowana na <tt>bool</tt>.
</p><p>Zwracam uwagę, że nie możemy w kodzie szablonu <tt>Comparable</tt> użyć
defaultowego konstruktora, bo nie jest on wymagany.  Dlatego zmienne
<tt>a</tt> i <tt>b</tt> nie były zdefiniowane wewnątrz funkcji
<tt>constraints()</tt>, tylko jako pola składowe klasy. Ponieważ nie
tworzymy żadnej instancji tej klasy, to nie będą wywoływane
konstruktory, a więc kompilator nie będzie generował ich kodu. 
</p><p>Teraz potrzebujemy jeszcze sposobu, aby skompilować, ale nie wywołać,
funkcję <tt>ComparableConcept<T>::constraints()</t></tt>. Możemy
tego dokonać pobierając adres funkcji i przypisując go do wskaźnika.
Kompilator skompiluje kod funkcji, ale jej nie wykona. Dodatkowo
najprawdopodobniej kompilator optymalizujący usunie to przypisanie
jako nieużywany kod, ale dopiero po kompilacji (no chyba, że jest
bardzo, ale to bardzo inteligentny). Dla wygody opakujemy tę
konstrukcję w szablon funkcji:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class Concept&gt;
<span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">void</span> function_requires<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>Concept::<span style="color: #00eeff;">*x</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> = &amp;Concept::<span style="color: #00eeff;">constraints</span>;
  ignore_unused_variable_warning<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: concept_check.cpp)
</p><p>Możemy teraz używać szablonu <tt>Comparable</tt> w następujący sposób:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 function_requires&lt;ComparableConcept&lt;int&gt; &gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
 function_requires&lt;ComparableConcept&lt;std::<span style="color: #00eeff;">complex</span>&gt; &gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; błąd
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: concept_check.cpp)
</p><p>Bardziej skomplikowane koncepty możemy sprawdzać korzystając z 
klas sprawdzających dla innych konceptów, np:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class Container&gt;
<span style="color: #0000ff;">struct</span> Mutable_ContainerConcept
<span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Container::<span style="color: #00eeff;">value_type</span> value_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Container::<span style="color: #00eeff;">reference</span> reference;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Container::<span style="color: #00eeff;">iterator</span> iterator;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Container::<span style="color: #00eeff;">pointer</span> pointer;
&nbsp;
  <span style="color: #0000ff;">void</span> constraints<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    sprawdzamy czy spełnia wymagania konceptu Container
    function_requires&lt; ContainerConcept&lt;Container&gt; &gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    function_requires&lt; AssignableConcept&lt;value_type&gt; &gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    function_requires&lt; InputIteratorConcept&lt;iterator&gt; &gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
    i = c.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    i = c.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    c.<span style="color: #00eeff;">swap</span><span style="color: #000000;">&#40;</span>c2<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  iterator i;
  Container c, c2;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Biblioteka <tt>boost</tt>, skąd wzięty został ten przykład, posiada
implementację szablonów dla każdego konceptu z
STL (<a href="http://www.boost.org/libs/concept_check/concept_check.htm" title="http://www.boost.org/libs/concept_check/concept_check.htm">http://www.boost.org/libs/concept_check/concept_check.htm</a>). Hierachia, którą
można tam odczytać, różni się trochę od tej, którą wcześniej
zaprezentowałem i która jest opisana w <a href="http://www.sgi.com/tech/stl/" title="http://www.sgi.com/tech/stl/">http://www.sgi.com/tech/stl/</a>. Główna
różnica to wprowadzenie rozróżnienia pomiędzy kontenerami, które
umożliwiaja modyfikację swoich elementów (<tt>MutableContainer</tt>) i tych,
które na to nie pozwalają (<tt>Container</tt>).
</p>


<h3>Archeotypy</h3>
<hr />

<p>Klasy sprawdzające koncepty służą do pomocy w implementacji typów
będących modelami danego konceptu. Możemy jednak mieć sytuację
odwrotną: implementujemy jakiś algorytm ogólny i chcemy się dowiedzieć
jaki koncept jest wymagany dla parametrów szablonu? Chcemy wybrać jak
najogólniejszy koncept, który jeszcze pozwala na poprawne działanie
algorytmu. Pomóc mogą nam w tym archeotypy. Są to klasy, które
dokładnie implementują interfejs danego konceptu. Opierając się na
<a href="http://www.boost.org/libs/concept_check/concept_check.htm" title="http://www.boost.org/libs/concept_check/concept_check.htm">http://www.boost.org/libs/concept_check/concept_check.htm</a>, przedstawię teraz
implementację archeotypu dla konceptu <tt>Comparable</tt>.
</p><p>Koncept
<tt>Comparable</tt> nie wymaga posiadania konstruktora defaultowego,
konstruktora kopiujacego oraz operatora przypisania, dlatego w naszym
archeotypie zdefiniujemy je jako prywatne:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> comparable_archetype <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:
  comparable_archetype<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  comparable_archetype<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> comparable_archetype &amp;<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  comparable_archetype &amp;operator=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> comparable_archetype &amp;<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> *<span style="color: #0000dd;">this</span>;<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">public</span>:
  comparable_archetype<span style="color: #000000;">&#40;</span>dummy_argument<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: archeotype.cpp)
</p><p>Aby móc tworzyć obiekty typu <tt>comparable_archetype</tt> dodaliśmy
niestandardowy konstruktor z argumentem sztucznego typu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> dummy_argument <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>


<p>używanego tylko na tę okazję (jego nazwa powinna być unikatowa).
</p><p>Operator <tt>operator&lt;()</tt> nie musi zwracać wartości typu <tt>bool</tt>, a
jedynie wartość typu konwertowalnego na <tt>bool</tt>, dlatego tworzymy taki typ:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> boolean_archetype  <span style="color: #000000;">&#123;</span>
  operator <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>i podajemy go jako typ zwracany przez operatory porównania
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">boolean_archetype operator&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> comparable_archetype &amp;,
                            <span style="color: #0000ff;">const</span> comparable_archetype &amp;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> boolean_archetype<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;
boolean_archetype  operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> comparable_archetype &amp;,
                             <span style="color: #0000ff;">const</span> comparable_archetype &amp;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> boolean_archetype<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: archeotype.cpp)
</p><p>Teraz możemy już przetestować nasz szablon <tt>max</tt>.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; 
<span style="color: #0000ff;">const</span> T &amp;max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;a,<span style="color: #0000ff;">const</span> T &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
comparable_archetype ca<span style="color: #000000;">&#40;</span>dummy_argument<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; 
max<span style="color: #000000;">&#40;</span>ca,ca<span style="color: #000000;">&#41;</span>; 
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: archeotype.cpp)
</p><p>Poprawna kompilacja tego kodu przekonuje nas, że koncept
<tt>Comparable</tt> jest wystarczajacy, przynajmniej syntaktycznie. Proszę
zwrócić uwagę, że jeśli użyjemy orginalnego szablonu
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>



<p>( Źródło: archeotype.cpp)
</p><p>to kod się nie skompiluje, bo zabraknie konstruktora kopiujacego. 
</p><p>Większość konceptów jest uszczegółowieniem innych konceptów.
Implementacja archeotypów w biblitece boost zezwala na takie
konstrukcje i gorąco zachęcam do zapoznania się z nią.
</p>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Shape.h">Shape.h</a></td><td>463 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Rectangle.h">Rectangle.h</a></td><td>510 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Circle.h">Circle.h</a></td><td>374 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Draw.cpp">Draw.cpp</a></td><td>119 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Draw_template.h">Draw_template.h</a></td><td>310 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Accumulate.cpp">Accumulate.cpp</a></td><td>891 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Invalid.cpp">Invalid.cpp</a></td><td>974 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Bind.cpp">Bind.cpp</a></td><td>518 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Concept_check.cpp">Concept_check.cpp</a></td><td>742 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Archeotype.cpp">Archeotype.cpp</a></td><td>990 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1239" class="section-2">
  <h1 class="book-heading">Szablony II</h1>
  <h2>Wprowadzenie</h2>
<hr />
<br />

<p>Mechanizm szablonów jest bardzo użyteczny ale może się okazać, że kod
ogólny, który szablon implementuje, nie nadaje się do stosowania w
każdym przypadku. W tej sytuacji mamy do dyspozycji dodatkowe
własności implementacji szablonów w C++: przeciążanie i specjalizację.
W poniższym wykładzie omówię sposób stosowania tych mechanizmów i
różnice pomiędzy nimi.
</p>

<h2>Przeciążanie szablonów funkcji</h2>
<hr />
<br />

<p>Przeciążenie szablonu funkcji, podobnie jak przeciążenie zwykłych
funkcji, definiuje nam nowy szablon. Możemy za pomocą przeciążenia
zdefiniować np. funkcję służącą do znajdywania maksymalnego
elementu w tablicy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T *data,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  T _max = data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;n;i++<span style="color: #000000;">&#41;</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>&gt;_max<span style="color: #000000;">&#41;</span> _max=data<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">return</span> _max;
<span style="color: #000000;">&#125;</span></pre></div>


<p>Oba szablony: powyższy i wcześniej zdefiniowany
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Przykład 3.1
</p>


<p>mogą ze sobą współistnieć i kompilator automatycznie wybierze poprawną
definicję na podstawie argumentów wywołania funkcji. Oczywiście w obu
przypadkach zadziała mechanizm automatycznej dedukcji argumentu szablonu.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> i,j,k;
<span style="color: #0000ff;">double</span> x,t<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">20</span><span style="color: #000000;">&#93;</span>;
k=max<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//wywołanie max(int,int)</span>
x=max<span style="color: #000000;">&#40;</span>t,k<span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//wywołanie max&lt;double&gt;(double *,int)</span></pre></div>

<p>( Źródło: max_overload.cpp)
</p><p>Możemy jednak chcieć nie tyle zdefiniować nową funkcję, ile zmienić
kod już istniejącego szablonu,  tak aby dla pewnego podzbioru
parametrów  działał inaczej.  Np. działanie funkcji <tt>max</tt>
dla dwu wskaźników nie koniecznie jest tym, czego byśmy sobie życzyli.
Możemy się spodziewać, że w tej sytuacji funkcja powinna zwrócić
wskaźnik do większej wartości, a nie wskaźnik o wyższym adresie.
Definiujemy więc nowy przeciążony szablon funkcji <tt>max</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T* max<span style="color: #000000;">&#40;</span>T *a, T *b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #000000;">&#40;</span>*a<span style="color: #000000;">&#41;</span>&gt;<span style="color: #000000;">&#40;</span>*b<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span></pre></div>
<p>( Źródło: max_overload.cpp)
</p>

<p>Przykład 3.2
</p>

<p>Teraz sytuacja nie jest już jednoznaczna. Kompilator, napotykając wyrażenie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> i,j;
max<span style="color: #000000;">&#40;</span>&amp;i,&amp;j<span style="color: #000000;">&#41;</span>;</pre></div>


<p>może dopasować zarówno oryginalny szablon 3.1 z <tt>T = int*</tt>
lub szablon 3.2 z <tt>T = int</tt>. I choć wydaje się że,
otrzymamy błąd kompilacji, to do głosu dochodzi mechanizm rozstrzygania
przeciążenia i kompilator wybierze dopasowanie drugiego szablonu jako
“bardziej wyspecjalizowanego”, tzn. do którego pasuje mniejszy zbiór
argumentów.  Ewidentnie algorytm rozstrzygania przeciążenia szablonów
funkcji nie jest prosty, polega on na częściowym porządkowaniu
przeciążonych funkcji według stopnia ich specjalizacji. Dokładny opis
tego algorytmu można znaleźć w D. Vandervoorde, N. Josuttis <i>"C++ Szablony. Vademecum profesjonalisty"</i>, rozdz. 12. Z grubsza
rzecz biorąc szablon funkcji <tt>F</tt> jest bardziej wyspecjalizowany niż
szablon <tt>G</tt> jeśli każdy zestaw argumentów, który da się dopasować do
<tt>F</tt> da sie również dopasować do szablonu <tt>G</tt>, ale nie na odwrót.
W naszym przypadku do szablonu 3.2 da się dopasować
argumenty typu <tt>(T *,T *)</tt>, które ewidentnie można dopasować
również do szablonu 3.1. Na odwrót już nie:
<tt>(int,int)</tt> pasuje do 3.1, a do szablonu 3.2 nie.
</p>


<h2>Specjalizacja szablonów funkcji</h2>
<hr />
<br />
<p>Przy dotychczasowych definicjach szablonów <tt>max</tt>
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T  max<span style="color: #000000;">&#40;</span>T a, T b<span style="color: #000000;">&#41;</span>;         <span style="color: #ff0000;">//(1)</span>
template&lt;typename T&gt; T* max<span style="color: #000000;">&#40;</span>T *a, T *b<span style="color: #000000;">&#41;</span>;       <span style="color: #ff0000;">//(2)</span>
template&lt;typename T&gt; T  max<span style="color: #000000;">&#40;</span>T *data,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//(3)</span></pre></div>


<p>będziemy dalej mieli kłopoty z
funkcją <tt>max</tt> wywołaną dla argumentów typu <tt>char*</tt>. Takie
argumenty zwyczajowo oznaczają napisy. Zgodnie z tym, co napisałem wcześniej, 
wywołany zostanie dla nich przeciążony szablon (2) i  porówna 
tylko pierwsze litery napisów, co ewidentnie nie jest tym czego się
oczekuje. 
</p><p>Na szczęście można dokonać specjalizacji tego szablonu dla 
argumentów typu <tt>char *</tt> i <tt>const char *</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">char</span> *max&lt;char *&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span>
template&lt;&gt; <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* max&lt;const <span style="color: #0000ff;">char</span> *&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Jak zwykle możemy pominąć argumenty szablonu podane w nawiasach ostrych
za nazwą szablonu, jeśli mogą być one wydedukowane na podstawie
argumentów wywołania i najczęściej spotkamy się z następującym kodem:  
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">char</span> *max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span>
template&lt;&gt; <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_spec.cpp)
</p><p>Powyższe specjalizacje są pełne, tzn. określają
dokładnie wszystkie argumenty wywołania szablonu.  Dlatego lista
parametrów szablonu w tych szablonach jest pusta. Tylko takie
specjalizacje są dozwolone dla szablonów funkcji. Specjalizacja, w
przeciwieństwie do przeciążenia, musi dotyczyć już istniejącego
szablonu. Dlatego niedozwolona  jest specjalizacja:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* max&lt;char *&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_spec.cpp)
</p><p>Przykład 3.3
</p>

<p>ponieważ argumenty są typu <tt>char *</tt> i <tt>const char *</tt>, i jako
takie nie pasują do żadnego z istniejących szablonów (1-3).  Musimy
więc zdefiniować kolejne przeciążenie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">const</span> T* max<span style="color: #000000;">&#40;</span>T *a,<span style="color: #0000ff;">const</span> T*b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>*a<span style="color: #000000;">&#41;</span>&gt;<span style="color: #000000;">&#40;</span>*b<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>?a:b;
<span style="color: #000000;">&#125;</span></pre></div>


<p>i dopiero wtedy kompilacja kodu 3.3 jest możliwa.  
Sytuację podsumowuje rysunek 3.1. 
</p>


<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-3-1.png" alt="Rysunek 3.1." title="Rysunek 3.1."  class="image image-_original " width="598" height="345" /><span class="caption"><strong>Rysunek 3.1.</strong></span></span>


<p>Jawne podstawienie argumentów szablonu w miejsce parametru może
prowadzić, w przypadku istnienia szablonów przeciążonych, do powstanie
szeregu przeciążonych funkcji. Wtedy obowiązują "zwykłe" reguły
rozstrzygania przeciążenia, np. wyrażenie 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">max&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>spowoduje "wygenerowanie" trzech funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span>   max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">int</span>  *max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> *,<span style="color: #0000ff;">int</span>*<span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">int</span>   max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> *,<span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>( Źródło: max_over_explicit.cpp)
</p><p>Ponieważ zero lepiej pasuje do <tt>int</tt>-a niż do wskaźnika na
<tt>int</tt>, wybrana zostanie pierwsza z powyższych funkcji.
</p>

<h2>Funkcje zwykłe a szablony</h2>
<hr />
<br />

<p>Obok szablonów mogą istnieć zwykłe funkcje o tej samej nazwie.
Algorytm rozstrzygający przeciążenie preferuje dopasowanie zwykłych
funkcji nad szablonami, więc jeśli zdefiniujemy sobie funkcję
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j<span style="color: #000000;">&#41;</span>;</pre></div>

<p>to kompilator dokona następujących podstawień:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//zwykla funkcja int max(int,int)</span>
max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//zwykla funkcja int max(int,int) z rzutowaniem double na int</span>
max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,<span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000;">//szablon max&lt;double&gt;(double, double)</span></pre></div>

<p>( Źródło: max_func.cpp)
</p><p>Z pozoru specjalizacje pełne opisane w poprzedniej części zachowują
się jak zwykłe funkcje i moglibyśmy napisać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">char</span> *max<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>

<p>zamiast
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">char</span> *max&lt;char *&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">char</span> *a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>a,b<span style="color: #000000;">&#41;</span>&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>


<p>Jest tak jednak tylko, jeśli możliwa jest dedukcja argumentów szablonu. 
W przypadku szablonu
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> U&gt; T convert<span style="color: #000000;">&#40;</span>U u<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> static_cast&lt;T&gt;<span style="color: #000000;">&#40;</span>u<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>możemy zdefiniować np. specjalizacje:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">int</span>    convert&lt;int,double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> u<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;
template&lt;&gt; <span style="color: #0000ff;">double</span> convert&lt;double,double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> u<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;</pre></div>


<p>i używać ich podając jawnie pierwszy, niededukowalny argument szablonu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">convert&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.14</span><span style="color: #000000;">&#41;</span>;
convert&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2.71</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>natomiast zdefiniowanie dwóch funkcji o tej samej nazwie i argumentach
wywołania, różniących się tylko zwracanym typem, nie jest możliwe.
</p>

<h2>Nieudane podstawienie nie jest błędem</h2>
<hr />
<br />

<p>Jawne podstawienie wszystkich argumentów szablonu funkcji generuje nam
jedną lub więcej funkcji "zwykłych". Może się jednak zdażyć, że
niektóre podstawienia generują niepoprawny kod:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">typename</span> T::<span style="color: #00eeff;">value</span> t<span style="color: #000000;">&#40;</span>T x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
cerr&lt;&lt;<span style="color: #666666;">&quot;t1&quot;</span>&lt;&lt;endl;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Wywołanie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">t&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>( Źródło: sfinae.cpp)
</p><p>prowadzi do <tt>int::value</tt> i jest nieprawidłowe. Spowoduje to błąd
kompilacji, ale tylko wtedy, jeśli nie będzie innych przeciążonych
szablonów funkcji <tt>t</tt>. Jeśli dodamy przeciążenie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">void</span> t<span style="color: #000000;">&#40;</span>T x <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>cerr&lt;&lt;<span style="color: #666666;">&quot;t2&quot;</span>&lt;&lt;endl;<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: sfinae.cpp)
</p><p>to wyrażenie <tt>t<int>(0)</int></tt> zostanie do niego dopasowane. Innymi słowy,
algorytm dopasowania przeciążenia pomija błędne podstawienia, nie
generując błędów kompilacji.
</p>

<h2>Specjalizacje szablonów klas</h2>
<hr />
<br />

<p>Podobnie jak dla szablonów funkcji również dla szablonów klas istnieje
możliwość podania różnych implementacji dla różnych zestawów
argumentów szablonu. W przeciwieństwie jednak do szablonów funkcji,
szablony klas nie mogą być przeciążane, a jedynie specjalizowane.
Oznacza to, że w programie może istnieć tylko jeden szablon podstawowy o
danej nazwie. Szablon podstawowy to szablon, w którego definicji nie
występują nawiasy ostre po nazwie szablonu. Wszystkie szablony
prezentowane do tej pory były podstawowe. Z tej reguły wynika, że trzy
zdefiniowane do tej pory szablony stosu 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; Stack <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;
template&lt;typename T,<span style="color: #0000ff;">int</span> N = <span style="color: #0000dd;">100</span>&gt; Stack <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>; <span style="color: #ff0000;">//błąd szablon Stack już istnieje</span>
template&lt;typename T,template&lt;typename X&gt; C&gt; Stack <span style="color: #000000;">&#123;</span>
  C&lt;T&gt; _rep;
<span style="color: #000000;">&#125;</span> <span style="color: #ff0000;">//błąd szablon Stack już istnieje</span></pre></div>

<p>nie mogą istnieć razem!
Oczywiście w przypadku zastosowania domyślnych parametrów szablonu
pierwsza definicja jest niepotrzebna, ale również bardziej pożyteczny
trzeci szablon jest niedozwolony.
</p><p>To ograniczenie można po części obejść, dokonując specjalizacji
częściowej, która jest dozwolona tylko dla szablonów klas i daje
możliwość specjalizacji szablonu dla pewnego podzbioru jego argumentów,
a nie dla pojedynczego zestawu, jak specjalizacja pełna. Oczywiście
specjalizacja pełna też jest możliwa. Rozważmy następujący przykład,
definiując szablon podstawowy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N = <span style="color: #0000dd;">100</span>&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>możemy dokonać następujących specjalizacji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt;        <span style="color: #0000ff;">class</span> Stack&lt;T,<span style="color: #0000dd;">666</span>&gt;     <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>; 
template&lt;typename T,<span style="color: #0000ff;">int</span> N&gt;  <span style="color: #0000ff;">class</span> Stack&lt;T*,N&gt;      <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
template&lt;int N&gt;             <span style="color: #0000ff;">class</span> Stack&lt;double ,N&gt; <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
template&lt;int N&gt;             <span style="color: #0000ff;">class</span> Stack&lt;int *,N&gt;   <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
template&lt;&gt;                  <span style="color: #0000ff;">class</span> Stack&lt;double,<span style="color: #0000dd;">666</span>&gt;<span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
template&lt;&gt;                  <span style="color: #0000ff;">class</span> Stack&lt;double *,<span style="color: #0000dd;">44</span>&gt; <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: stack_spec.cpp)
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-3-2.png" alt="Rysunek 3.2. Symboliczne przedstawienie zbiorów argumentów dla różnych specjalizacji szablonu Stack." title="Rysunek 3.2. Symboliczne przedstawienie zbiorów argumentów dla różnych specjalizacji szablonu Stack."  class="image image-_original " width="497" height="345" /><span class="caption"><strong>Rysunek 3.2. Symboliczne przedstawienie zbiorów argumentów dla różnych specjalizacji szablonu Stack<T,N>.</t,n></strong></span></span>


<p>Każda z tych specjalizacji definiuje pewien podzbiór parametrów
szablonu podstawowego (zob. rysunek 3.2). Jeśli któryś z
podzbiorów zawiera się w drugim, to mówimy, że jedna specjalizacja jest
bardziej wyspecjalizowana od drugiej. Hierarchia specjalizacji dla
powyższego przykładu pokazana jest na rysunek 3.3.  Jeżeli
jakiś zestaw parametrów należy do dwóch (lub więcej) podzbiorów, które
się przecinaja, ale żeden nie zawiera się w drugim, to dla tych
parametrów kompilator nie bedzie w stanie wybrać specjalizacji.
</p>


<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-3-3.png" alt="Rysunek 3.3. Uporządkownie specjalizacji szablonu Stack." title="Rysunek 3.3. Uporządkownie specjalizacji szablonu Stack."  class="image image-_original " width="640" height="295" /><span class="caption"><strong>Rysunek 3.3. Uporządkownie specjalizacji szablonu Stack<T,N>.</t,n></strong></span></span>


<p>Oczywiście ten przykład jest bardzo sztuczny i trudno sobie wyobrazić
powód tworzenia takich specjalizacji. Rozważmy bardziej realistyczny
przypadek: deklarujemy szablon podstawowy, ale bez podawania jego
definicji; będziemy korzystać jedynie z jego specjalizacji:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N = <span style="color: #0000dd;">100</span>, <span style="color: #0000ff;">typename</span> R = T*&gt; <span style="color: #0000ff;">class</span> Stack;</pre></div>


<p>Następnie definiujemy dwie specjalizacje. Pierwszą dla stosów opartych
o zwykłe tablice:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N&gt; <span style="color: #0000ff;">class</span> Stack&lt;T,N,T*&gt; <span style="color: #000000;">&#123;</span>
  T _rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> _top;
<span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=e;<span style="color: #000000;">&#125;</span>
  T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>--_top<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>i drugą opartą o kontenery STL:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N,template&lt;typename E&gt; <span style="color: #0000ff;">class</span> Sequence&gt; 
  <span style="color: #0000ff;">class</span> Stack&lt;T,N,Sequence&lt;T&gt; &gt; <span style="color: #000000;">&#123;</span>
  Sequence&lt;T&gt; _rep;
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep.<span style="color: #00eeff;">push_back</span><span style="color: #000000;">&#40;</span>e<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
  T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>T top = _rep.<span style="color: #00eeff;">top</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;_rep.<span style="color: #00eeff;">pop_back</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;return top;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep.<span style="color: #00eeff;">empty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: Stack_2.cpp)
</p><p>Korzystając z tych specjalizacji możemy pisać następujący kod. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  Stack&lt;int,<span style="color: #0000dd;">100</span>,<span style="color: #0000ff;">int</span> *&gt;            s_table;
  Stack&lt;int,<span style="color: #0000dd;">100</span>&gt;                  s_default ;
  Stack&lt;int,<span style="color: #0000dd;">0</span>,std::<span style="color: #00eeff;">vector</span>&lt;int&gt; &gt;  s_container;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: Stack_2.cpp)
</p><p>W każdym przypadku kompilator wybierze implementację odpowiednią dla
podanych parametrów.
</p>
<h2>Szablony a dziedziczenie</h2>
<hr />
<br />

<p>Szablony klas mogą oczywiście dziedziczyć z innych klas. Deklaracja
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; Stack: <span style="color: #0000ff;">public</span> Container <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>oznacza, że każda instancja danego szablonu <tt>Stack<T></t></tt> dziedziczy z
klasy <tt>Container</tt>. Ponieważ konkretna instancja szablonu jest
klasą, to dowolna klasa czy szablon może dziedziczyć z instancji
szablonu:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> special Stack_int : <span style="color: #0000ff;">public</span> Stack&lt;int&gt; <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span></pre></div>

<p>Definiując specjalizację szablonu klasy możemy dziedziczyć z innych
specjalizacji tej samej klasy; nie może to jednak prowadzić do
rekurencji. Jeśli napiszemy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">int</span> N&gt; Stack <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;
template&lt;typename T&gt; 
Stack&lt;T*,N&gt;: <span style="color: #0000ff;">private</span> Stack&lt;void *,N&gt; <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: stack_void.cpp)
</p><p>to kompilator odmówi skompilowania tego kodu z powodu rekurencyjnej
definicji specjalizacji szablonu <tt>Stack</tt>. Wszystko będzie w
porządku  jeśli dodamy specjalizację  dla typu <tt>void *</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;int N&gt; <span style="color: #0000ff;">class</span> Stack&lt;void *,N&gt; <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: stack_void.cpp)
</p><p>Dlaczego mielibyśmy jednak dziedziczyć implementację klasy <tt>void*</tt>?
Powodem jest unikanie powielania kodu.  Ponieważ każda konkretyzacja
(instancja) szablonu jest osobną klasa, to dla każdej generowany jest
pełny kod potrzebnych funkcji. Jeśli te funkcje są proste, to
nie jest to kłopot. W praktyce implementacja stosu musi zwykle
uwzględniać dynamiczne zarządzanie pamięcią i może być  dużo bardziej
skomplikowana, a zatem generowany kod będzie odpowiednio większy.
Ogólnie jest to nie do uniknięcia, ale ponieważ wszystkie wskaźniki
mają ten sam rozmiar i można je rzutować na <tt>void *</tt> to możemy
wykorzystać implementację <tt>Stack<void *></void></tt> do implementacji
pozostałych typów wskaźnikowych:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">size_t</span> N&gt; 
Stack&lt;T*,N&gt;: <span style="color: #0000ff;">private</span> Stack&lt;void *,N&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  T* pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> static_cast&lt;T*&gt;<span style="color: #000000;">&#40;</span>Stack&lt;void *&gt;::<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T *e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    Stack&lt;void *&gt;::<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span>e<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> Stack&lt;void *&gt;::<span style="color: #00eeff;">is_empty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;</pre></div>
<p>( Źródło: stack_void.cpp)
</p><p>Korzystamy tu z automatycznej konwersji <tt>T*</tt> na <tt>void *</tt>.  W ten
sposób, np. kod funkcji <tt>Stack<int *>::push(int *)</int></tt>
będzie zawierał tylko parę instrukcji opakowujących wywołanie kodu
funkcji <tt>Stack<void *>::push(void *)</void></tt>. Proszę zwrócić uwagę na
zastosowanie dziedziczenia prywatnego.
</p>

<h3>Zależne klasy bazowe</h3>
<br />
<p>Szablon klasy może również dziedziczyć z innego szablonu klasy, którego
argumenty bedą zależały od jego parametrów:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;typename T&gt; <span style="color: #0000ff;">class</span> Base&lt;T&gt; <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;
template&lt;typename S&gt; 
<span style="color: #0000ff;">class</span> Derived: <span style="color: #0000ff;">public</span> Base&lt;S&gt; <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>Przy tych definicjach klasa <tt>Derived<double></double></tt> dziedziczy z
klasy <tt>Base<double></double></tt>. Taką klasę nazywamy zależną klasą bazową i
jest to bardzo częsta konstrukcja w programowaniu uogólnionym. 
</p><p>Z zależnymi klasami bazowymi wiąże się jednak pewna zasada, związana z
wyszukiwaniem nazw, która może być sporym zaskoczeniem.  Rozważmy
następujący przykład:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt;  <span style="color: #0000ff;">class</span> Base <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  Base<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:basefield<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">int</span> basefield;
<span style="color: #000000;">&#125;</span>;
template&lt;typename T&gt; <span style="color: #0000ff;">class</span> DD :<span style="color: #0000ff;">public</span> Base&lt;T&gt; <span style="color: #000000;">&#123;</span>       
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>std::<span style="color: #00eeff;">cerr</span>&lt;&lt;basefield&lt;&lt;std::<span style="color: #00eeff;">endl</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: base.cpp)
</p><p>Ten kod się nie skompiluje przy pomocy kompilatora C++ zgodnego ze
standardem. Np. nie skompiluje go kompilator
g++-3.4, a g++-3.3 tak. Powód tego faktu jest następujący: nazwa <tt>basefield</tt>, występująca w
klasie <tt>DD</tt> jest nazwą niezależną (od parametru szablonu). Klasa
bazowa, w której ta nazwa jest zdefiniowana jest klasą bazową zależną
(od parametru szablonu). Według standardu kompilator nie wyszukuje
nazw niezależnych w zależnych klasach bazowych.  Kompilator g++-3.4
jest bliżej stadardu niż g++-3.3 i stąd to całe zamieszanie. Aby kod się skompilował należy uczynić tę nazwę zależną, np. poprzez kwalifikowanie jej nazwą klasy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> DD :<span style="color: #0000ff;">public</span> Base&lt;T&gt; <span style="color: #000000;">&#123;</span>       
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>std::<span style="color: #00eeff;">cerr</span>&lt;&lt;DD::<span style="color: #00eeff;">basefield</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: base.cpp)
</p><p>lub przez 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> DD :<span style="color: #0000ff;">public</span> Base&lt;T&gt; <span style="color: #000000;">&#123;</span>       
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>std::<span style="color: #00eeff;">cerr</span>&lt;&lt;this-&gt;basefield&lt;&lt;std::<span style="color: #00eeff;">endl</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: base.cpp)
</p>
<h3>CRTP</h3>
<br />
<p>Dziedziczenie szablonów można też wykorzystać do przydatnej
"sztuczki", zwanej po angielsku <i>"couriously reccuring template
pattern"</i> (autorem tego idiomu jest James O. Coplien). Rozważmy następujący problem: chcemy
zaimplementować mechanizm automatycznego liczenia ilości obiektów
danej klasy. To standardowe zadanie na zastosowanie konstruktorów,
destruktorów i statycznych składowych klasy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Countable <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">protected</span>:
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">size_t</span> _counter;
<span style="color: #0000ff;">public</span>:
  Countable<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>++_counter;<span style="color: #000000;">&#125;</span>
  Countable<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Countable &amp;<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>++_counter;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">virtual</span> ~Countable <span style="color: #000000;">&#123;</span>--_counter<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">size_t</span> counter<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _counter;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">size_t</span> Countable::_counter = <span style="color: #0000dd;">0</span>;</pre></div>

<p>Oczywiście wpisywanie tego kodu do każdej klasy, której obiekty chcemy
zliczać jest nużące i łamie zasadę niepowielania kodu.  Postaramy się
więc wykorzystać kod klasy <tt>Countable</tt>, dziedzicząc go w innych klasach:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> MyClass1 : <span style="color: #0000ff;">public</span> Countable <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">class</span> MyClass2 : <span style="color: #0000ff;">public</span> Countable <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Niestety ponieważ obie klasy <tt>MyClass1</tt> i <tt>MyClass2</tt> dziedziczą
z tej samej klasy, dziedziczą również ten sam wspólny licznik. Tak
więc zliczaniu podlegać będą obiekty obu klas wspólnie. W rozwiązaniu
pomogą nam szablony. Wystarczy uczynić  klasę <tt>Countable</tt> szablonem
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> Countable <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">protected</span>:
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">size_t</span> _counter;
<span style="color: #0000ff;">public</span>:
  Countable<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>++_counter;<span style="color: #000000;">&#125;</span>
  Countable<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Countable &amp;<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>++_counter;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">virtual</span> ~Countable<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>--_counter<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">size_t</span> counter<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _counter;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;
template&lt;typename T&gt; <span style="color: #0000ff;">size_t</span> Countable&lt;T&gt;::_counter = <span style="color: #0000dd;">0</span>;</pre></div>

<p>( Źródło: countable.cpp)
</p><p>i używać go w następujący sposób:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> MyClass1 : <span style="color: #0000ff;">public</span> Countable&lt;MyClass1&gt; <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">class</span> MyClass2 : <span style="color: #0000ff;">public</span> Countable&lt;MyClass2&gt; <span style="color: #000000;">&#123;</span>
  ...
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: countable.cpp)
</p><p>Ponieważ każda konkretyzacja szablonu jest osobną klasą, klasy
<tt>MyClass1</tt> i <tt>MyClass2</tt> dziedziczą z różnych klas bazowych i
będą posiadać różne liczniki, ale ciągle wspólne w ramach każdej
klasy.  Parametryzowanie klasy bazowej typem klasy dziedziczącej
gwarantuje jej unikatowość.
</p>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/max_overload.cpp">max_overload.cpp</a></td><td>506 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_spec.cpp">Max_spec.cpp</a></td><td>953 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_over_explicit.cpp">Max_over_explicit.cpp</a></td><td>393 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sfinae.cpp">Sfinae.cpp</a></td><td>307 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_spec.cpp">Stack_spec.cpp</a></td><td>968 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_2.cpp">Stack_2.cpp</a></td><td>672 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_void.cpp">Stack_void.cpp</a></td><td>1010 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Base.cpp">Base.cpp</a></td><td>364 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Countable.cpp">Countable.cpp</a></td><td>661 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1240" class="section-2">
  <h1 class="book-heading">Testowanie</h1>
  <h2>Wstęp</h2>
<hr />
<br />
<p>Programowanie rozumiane jako pisanie kodu jest tylko częścią procesu
tworzenia oprogramowania. Analiza i opis tego procesu jest przedmiotem
inżynierii oprogramowania i znacznie wykracza poza ramy tego wykładu.
Niemniej chciałbym pokrótce w tym wykładzie poruszyć jedno zagadnienie
związane bezpośrednio z programowaniem - testowanie. 
Testowanie jest nieodłączną częścią programowania i
powinno być obowiązkiem każdego programisty. Jak będę się starał
Państwa przekonać, testowanie to może być coś więcej niż "tylko"
sprawdzenie poprawności kodu.
</p>

<h2>Testowanie</h2>
<br />
<p>Testowanie wydaje się oczywistą koniecznością w przypadku każdego
programu komputerowego (choć co rok zdarza mi się spotkać studentów
przekonanych o swojej nieomylności:)). Mniej oczywiste jest
stwierdzenie kto, gdzie, kiedy i co ma testować. To w ogólności bardzo
złożony problem, ale tu chciałbym się ograniczyć do tzw. testów
jednostkowych. Wyrażenie "test jednostkowy" należy interpretować
jako test jednej jednostki. Przez pojedynczą jednostkę będziemy
rozumieli: funkcję, metodę lub klasę. Zadaniem takiego testu jest
sprawdzenie czy dana jednostka działa poprawnie. 
</p><p>Dlaczego w ogóle pisać takie testy? Czy nie wystarczy przetestowanie
całego programu? Testować cały program też oczywiście trzeba. Służą
do tego liczne testy odbioru, integracyjne itp., wykonywane poprzez
dedykowane zespoły.  Ale im większą część kodu testujemy, tym
trudniejsze są testy i tym trudniej będzie znaleźć przyczynę wykrytej
nieprawidłowości działania programu. Testy jednostkowe wykrywają
błędy (a przynajmniej ich część) "u źródła", często w bardzo prostym
kodzie, a więc ich poprawianie  może być dużo szybsze. 
</p><p>Jak się zastanowić, to testowanie każdej wykonanej jednostki przed
użyciem jej w dalszym kodzie powinno być oczywistą koniecznością. No,
ale równie oczywiste jest, że należy uprawiać sporty, nie palić
papierosów, nie jeździć po pijanemu, itp. Statystyki dobitnie jednak
pokazują, że natura człowiecza grzeszną jest i łatwo ulegamy
słabościom, w tym wypadku pokusie nietestowania programów, a powodem
jest jeden z siedmiu grzechów głównych czyli lenistwo. Testy nie
piszą, ani nie wykonuja się same, w rzeczywistości wymagają całkiem
sporego nakładu pracy (czasami większego niż pisanie testowanego
kodu!). Część programistów traktuje ten wysiłek jako "czas
stracony", tzn. nie wykorzystany na pisanie kodu, za który im płacą.
</p><p>To wszystko jest prawdą, ale w rzeczywistości nie możemy uniknąć tej
straty czasu. Jest to tylko kwestia wyboru gdzie i ile tego czasu
stracimy: czy na pisanie testów w trakcie kodowania jednostek i
poprawianie prostych błędów, czy na szukanie błędów w dużo większych
fragmentach programu? Doświadczenie wykazuje, że czas potrzebny na
znalezienie i poprawienie błędu jest w tym drugim przypadku dużo
większy, w krańcowych przypadkach poprawienie programu może być wręcz
niemożliwe.  Testy jednostkowe skalują się liniowo z rozmiarem
pisanego kodu, a nie ekspotencjalnie jak np. testy integracyjne.
Oczywiście testy jednostkowe nie rozwiążą wszystkich problemów, jeśli mamy zły
projekt całości to nic nam nie pomogą idealnie działające jednostki,
ale przynajmniej będzie nam łatwiej się o tym przekonać.
</p><p>Jak już napisałem testy służą do sprawdzania poprawności działania
danej jednostki: <b>ciągłego</b> sprawdzanie działania tej jednostki.
Ponieważ kod się nieustannie zmienia, powinniśmy wykonywać testy cały
czas aby sprawdzić czy te zmiany wynikające, np. z poprawienia
wykrytych błędów, nie wprowadziły nowych usterek. Aby to było możliwe
testy musza być łatwe do wykonywania czyli zautomatyzowane. Nie mogą
polegać na tym, że puszczamy program, a następnie przeglądamy wydruk.
Musimy "nacisnąć guzik" a w odpowiedzi zapali  nam się szereg
"światełek": zielone wskażą testy zaliczone, a czerwone testy niezaliczone. Taki automatyczny proces testujący może być zintegrowany z
innymi narzędzimi programistycznymi, takimi jak np. <tt>make</tt>.
</p>
<br />
<h3>Refaktoryzacja</h3>
<hr />
<br />

<p>Wysiłek włożony w napisanie takich powtarzalnych testów nie jest
zaniedbywalny, ale korzyści są duże.  Możliwość przetestowania kodu w
dowolnym momencie to więcej niż tylko świadomość, że nasz obecny kod
przeszedł testy. Taka możliwość, w połączeniu z narzędziami
zarządzającymi kodem źródłowym, pozwala na bezpieczne dokonywanie
zmian według schematu: zmieniamy, testujemy, jeśli testy się nie
powiodą szukamy błedów, jeśli ich nie znajdujemy to cofamy zmiany.
Takie podejście jest szczególnie pomocne, a właściwie niezbędne,
podczas programowania przyrostowego i refaktoryzacji. 
</p><p>Programowanie przyrostowe to technika zalecana dla większości
projektów, która polega na programowaniu "malymi krokami", czyli na
kolejnym dodawaniu nowych funkcji do istniejącego działajacego kodu.
Testy umożliwiają sprawdzenie czy dodany kod nie wprowadził błędów do
starej części. Oczywiście każdy przyrost wymaga stworzenia nowego
zestawu testów. 
</p><p>Refaktoryzacja to zmiana kodu bez zmiany jego funkcjonalności w celu
poprawy jego jakości.
</p>

<h3>Projektowanie sterowane testami</h3>
<br />

<p>Pisanie testu sprawdza również nasze zrozumienie tego, co dana
jednostka ma robić. W tym sensie testy stanowią sformalizowany zapis
wymagań. To zaleta, którą trudno przecenić. Jeżeli nie wiemy jak
przestestować daną jednostkę, to najprawdopodobniej nie powinniśmy się
wcale brać za jej kodowanie.  Dlatego niektóre metodologie (np.
extreme programming) zalecają projektowanie sterowane testami, czyli
zaczęcie pisania programu od pisania testów do niego. Przebieg pracy
przy takim podejściu wygląda następująco:
</p>
<ol><li> Piszemy test
</li><li> Kompilujemy test
</li><li> Test się nie kompiluje
</li><li> Piszemy tyle kodu aby test sie skompilował
</li><li> Test się kompiluje
</li><li> Wykonujemy test
</li><li> Test najprawdpodobniej nie wykonuje się poprawnie
</li><li> Poprawiamy/dopisujemy  kod tak aby test się wykonał
</li><li> Test wykonuje się poprawnie 
</li></ol>
<p>Osobiście wydaje mi się, że zalety tego podejścia są ogromne. Nawet
jeśli brakuje czasu i ochoty na pisanie testów, to należy po prostu
zastanowić się nad sposobem przetestowania naszego kodu zanim
zaczniemy go pisać. To znakomicie zmusza do ścisłego określenia 
tego, co właściwie nasz program ma robić.
</p>

<h3>Testy</h3>
<br />

<p>Po tej całej propagandzie - czas na testowanie w praktyce. Przetestujemy
przykłady wprowadzone w poprzednich rozdziałach, zaczynając od funkcji
<tt>max</tt>: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T max<span style="color: #000000;">&#40;</span>T a,T b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>a&gt;b<span style="color: #000000;">&#41;</span>?a:b;<span style="color: #000000;">&#125;</span></pre></div>

<p>Być może część z Państwa oburzy się: jak to? testować
tę jedną linijkę? Gdyby chodziło o tę jedną linijkę to rzeczywiście
wystarczy na nią popatrzeć (i mieć wiarę w kompilator), ale
przypominam, że dodaliśmy do niej dwie przeciążone wersje i dwie 
specjalizacje. A to oznacza, że ta linijka nie działa poprawnie w
każdym przypadku.  Napiszemy więc testy, które to wyłapią. Jak już
pisałem będzie to jednoczesne zdefiniowanie tego jak funkcja <tt>max</tt>
ma działać. Po chwili zastanowienia ustalamy więc, że nasza funkcja
<tt>max</tt> zwraca: 
</p>
<ul><li> większą z dwu przekazanych wartości (większą w sensie porównania operatorem <tt>></tt>)
</li><li> jeśli argumentami są wskaźniki to <tt>max</tt> zwraca wskaźnik na większą wartość
</li><li> jeśli argumentami są wskaźniki na <tt>char</tt> to <tt>max</tt> traktuje je jako napisy i zwraca wskaźnik do napisu większego zgodnie z uporządkowaniem leksykalnym.
</li></ul>
<p>Testować funkcję <tt>max</tt> będziemy poprzez porównanie wartości
zwracanej do wartości poprawnej, którą sami wskażemy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Należy też sprawdzić przypadek symetryczny
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Testowanie szablonu jest trudne, bo w zasadzie musimy rozważyć
przekazanie argumentów dowolnego typu. Co więcej, ten typ wcale nie
musi posiadać operatora porównania <tt>==</tt>. Aby sprawdzić działanie <tt>max</tt> na jakimś typie niewbudowanym posłużymy się własną klasą:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> <span style="color: #0000ff;">Int</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:
 <span style="color: #0000ff;">int</span> _val;
<span style="color: #0000ff;">public</span>:
 <span style="color: #0000ff;">Int</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i<span style="color: #000000;">&#41;</span>:_val<span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
 <span style="color: #0000ff;">int</span> val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _val;<span style="color: #000000;">&#125;</span>;
 <span style="color: #0000ff;">friend</span> <span style="color: #0000ff;">bool</span> operator&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">Int</span> &amp;a,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">Int</span> &amp;b<span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">return</span> a._val&gt;b._val; 
 <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Kod testowy może teraz wyglądać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">Int</span> i<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">Int</span> j<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>j,i<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>j,j<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>i,i<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Następnie testujemy wersję wskaźnikową:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>&amp;i,&amp;j<span style="color: #000000;">&#41;</span>-&gt;val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>&amp;j,&amp;i<span style="color: #000000;">&#41;</span>-&gt;val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>&amp;j,&amp;j<span style="color: #000000;">&#41;</span>-&gt;val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>&amp;i,&amp;i<span style="color: #000000;">&#41;</span>-&gt;val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>i na koniec wersję dla napisów (<tt>const char *</tt>):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;abcd&quot;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;acde&quot;</span>,<span style="color: #666666;">&quot;abcd&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;abcd&quot;</span>,<span style="color: #666666;">&quot;abcd&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #666666;">&quot;abcd&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;acde&quot;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>oraz (<tt>char *</tt>):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">char</span> s1<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;abcde&quot;</span>;
<span style="color: #0000ff;">char</span> s2<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;ac&quot;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s1,s2<span style="color: #000000;">&#41;</span>,s2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s2,s1<span style="color: #000000;">&#41;</span>,s2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s1,s1<span style="color: #000000;">&#41;</span>,s1<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span>==<span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s2,s2<span style="color: #000000;">&#41;</span>,s2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Napisy zostały tak dobrane, żeby miały pierwszy znak identyczny,
ponieważ procedura ogólna dla wskaźników porównuje właśnie pierwsze
znaki. To pokazuje jak ważny jest wybór danych testowych. Testy
jednostkowe są testami "białej skrzynki", tzn. piszący testy ma wgląd
do implementacji testowanego kodu (powinien to być ten sam
programista), można więc przygotować dane testowe tak, aby pokrywały
możliwie wiele ścieżek wykonywania programu, warunków brzegowych itp. 
</p><p>Oczywiście bezbłędne przejście powyższych testów nie gwarantuje nam
jeszcze poprawności funkcji <tt>max</tt> (tego zresztą nie zagwarantuje
nam żaden test), ale bardzo zwiększa prawdopodobieństwo tego, że tak
jest.
</p><p>Pozostaje nam do wytestowanie procedura szukająca maksimum w tablicy.
To zadanie zostawiam jako ćwiczenie dla czytelników.
</p><p><br />
Powyższy przykład może budzić pewne obawy. Kod funkcji <tt>max</tt> liczy
około 20 linii, a kod testujący 40. No cóż, testowanie kosztuje, tylko
czy możemy sobie pozwolić na zrezygnowanie z niego? Rozważmy powyższy
przykład, te dwadzieścia  linii kodu definiującego szablon <tt>max</tt> jest dużo
bardziej skomplikowane niż te czterdzieści linii kodu testujacego, tak że jeśli
porównamy czas pisania, to nie wypada to już tak źle. Kod szablonu
<tt>max</tt> zawiera przeciążenia i specjalizację, czyli wykorzystany jest
algorytm rozstrzygania przeciążenia. Osobiście nie ufam swojej
znajomości tego algorytmu na tyle, aby nie sprawdzić kodu. Jeżeli i tak
wykonujemy jakieś testy to warto zainwestować trochę więcej pracy i
przygotować porządny zestaw testujący.  Może też się zdarzyć, że
będziemy chcieli dodać kolejne przeciążenia, które mogą wpłynąć w
niezamierzony sposób na przeciążenia już istniejące. Gotowy programik
testujący pozwoli nam to szybko wykryć.
</p><p>Pozostaje jeszcze sprawa poprawności samego programu testującego, w
końcu to też jest kod i może zawierać błędy. Czy więc musimy pisać kod
testujący program testujący, i tak dalej w nieskończoność? Na
szczęście nie, błędy w kodzie testującym mogą mieć dwa efekty.
Pierwszy to wykazanie błędu, który nie jest błędem, w tej sytuacji taki
błąd wykrywa się sam. Musimy tylko pamiętać podczas
szukania źródeł wykazanych przez program testujacy usterek, że mogą
one pochodzić z kodu testującego. Drugi rodzaj błędu to nie wykrycie
błędu w programie. Występowanie tego rodzaju błedów testujemy poprzez
wprowadzanie do programu zamierzonych błędów i sprawdzając czy nasze
testy je wykryją.
</p>

<h3>CppUnit</h3>
<br />

<p>Rysunek 4.1 przedstawia częściową hierachię klas w szkielecie <tt>CppUnit</tt>.
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-4-1.png" alt="Rysunek 4.1. Częściowa hierarchia klas w szkielecie CppUnit." title="Rysunek 4.1. Częściowa hierarchia klas w szkielecie CppUnit."  class="image image-_original " width="498" height="346" /><span class="caption"><strong>Rysunek 4.1. Częściowa hierarchia klas w szkielecie CppUnit.</strong></span></span>

<p>Jest to bardzo mała część, uwzględniająca
tylko te klasy, które zostaną użyte w naszym przykładzie. Proszę przede
wszystkim zwrócić uwagę na hierachię klasy <tt>Test</tt>. Jest to
klasyczny wzorzec <tt>Kompozyt</tt> (zob. E. Gamma, R. Helm, R. Johnson, J. Vlissides <i>"Wzorce projektowe. Elementy oprogramowania obiektowego wielokrotnego użytku"</i>), umożliwiający
dowolne składanie i zagnieżdżanie testów. Jest to możliwe dzieki temu,
że klasa <tt>TestSuite</tt> może zawierać inne testy, w tym też inne
<tt>TestSuite</tt>.
</p><p>Każda klas z tej hierarchii zawiera funkcję <tt>run(TestResult *result)</tt>, która wywołuje funkcję <tt>runTest()</tt>, którą musimy przeładować definiując nasz własny test. Klasa <tt>TestResult</tt>, a raczej jej obiekty, służą do zbierania wyników testów. 
</p><p>Nasz przykład z <tt>max</tt> możemy zapisać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include &lt;cppunit/TestResult.h&gt;</span>
<span style="color: #339900;">#include &lt;cppunit/TestCase.h&gt;</span>
&nbsp;
<span style="color: #0000ff;">class</span> Max_test : <span style="color: #0000ff;">public</span> CppUnit::<span style="color: #00eeff;">TestCase</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
&nbsp;
  <span style="color: #0000ff;">void</span> runTest<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>; &lt;i&gt;sztucznie wprowadzony błąd!&lt;/i&gt;
    <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
&nbsp;
    <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
&nbsp;
    .
    .
    .
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: max_test_case.cpp)
</p><p>Powyższy test możemy wywołać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
CppUnit::<span style="color: #00eeff;">TestResult</span> result;
Max_test max;
&nbsp;
max.<span style="color: #00eeff;">run</span><span style="color: #000000;">&#40;</span> &amp;result <span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>Jak na razie większym kosztem uzyskaliśmy ten sam efekt co programik z
poprzedniego podrozdziału :). Czas więc wykorzystać jakieś własności szkieletu. 
</p><p>Zaczniemy od wykorzystania, zamiast standardowego makra <tt>assert</tt>,
makr szkieletu <tt>CppUnit</tt>: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include &lt;cppunit/TestResult.h&gt;</span>
<span style="color: #339900;">#include &lt;cppunit/TestCase.h&gt;</span>
<span style="color: #339900;">#include &lt;cppunit/TestAssert.h&gt;</span>
&nbsp;
<span style="color: #0000ff;">class</span> Max_test : <span style="color: #0000ff;">public</span> CppUnit::<span style="color: #00eeff;">TestCase</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
&nbsp;
  <span style="color: #0000ff;">void</span> runTest<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; &lt;i&gt;sztucznie wproadzony bład!&lt;/i&gt;
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
    .
    .
    .
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: max_test_runner.cpp)
</p><p>Jednak wykonanie tego samego kodu <tt>main</tt> co poprzednio nie da
żadnych wyników! To dlatego, że makra <tt>CPPUNIT_ASSERT_...</tt> nie
powodują przerwania programu tylko zapisanie wyników do obiektu typu
<tt>TestResult</tt>. Najłatwiej odczytać te wyniki nie uruchamiając
testów samemu tylko za pośrednictwem  obiektu <tt>TextUi::TestRunner</tt>.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include &lt;cppunit/ui/text/TestRunner.h&gt;</span>
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
Max_test *max = <span style="color: #0000dd;">new</span> Max_test;
CppUnit::<span style="color: #00eeff;">TextUi</span>::<span style="color: #00eeff;">TestRunner</span> runner;
&nbsp;
runner.<span style="color: #00eeff;">addTest</span><span style="color: #000000;">&#40;</span> max <span style="color: #000000;">&#41;</span>; 
&lt;i&gt;max musi byc wskaźnikiem utworzynym za pomocą <span style="color: #0000dd;">new</span> bo runner
przejmuje go na własność i sam zwalnia przydzieloną dla niego pamięć&lt;/i&gt; 
runner.<span style="color: #00eeff;">run</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_test_runner.cpp)
</p><p>Teraz uruchomienie programu spowoduje wydrukowanie na <tt>std::cout</tt>
raportu z wykonania testu. Ciągle jednak jest to niewspółmierne do
włożonego wysiłku. Postaramy się więc teraz zacząć strukturyzować
nasze testy. Możemy oczywiście stworzyć kilka różnych klas 
testujących z inną funkcją <tt>runTest()</tt> każda, ale 
zamiast tego wykorzystamy klasę <tt>TestFixture</tt>. Rzut oka
na rysunek 4.1 pokazuje, że nie jest to <tt>Test</tt>, ale
przerobimy ją na test za pomocą <tt>TestCaller</tt>.
</p><p>Zaczynamy od zdefiniowanie szeregu testów w jednej klasie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include &lt;cppunit/TestFixture.h&gt;</span>
<span style="color: #339900;">#include &lt;cppunit/TestAssert.h&gt;</span>
&nbsp;
<span style="color: #0000ff;">class</span> Max_test : <span style="color: #0000ff;">public</span> CppUnit::<span style="color: #00eeff;">TestFixture</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">Int</span> i,j;
<span style="color: #0000ff;">public</span>:
 Max_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:i<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">5</span><span style="color: #000000;">&#41;</span>,j<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">6</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
 <span style="color: #0000ff;">void</span> int_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; &lt;i&gt;sztucznie wprowadzony bład!&lt;/i&gt;
    ...
    <span style="color: #00eeff;">CPPUNIT_ASSERT_EQUAL</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,max<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; &lt;i&gt;sztucznie wprowadzony bład!&lt;/i&gt;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> class_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">6</span>,max<span style="color: #000000;">&#40;</span>i,j<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">val</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
    ...
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> class_ptr_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">6</span>,max<span style="color: #000000;">&#40;</span>&amp;i,&amp;j<span style="color: #000000;">&#41;</span>-&gt;val<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
    ...
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> const_char_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;abcd&quot;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #666666;">&quot;acde&quot;</span><span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;
    ...
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> char_test<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">char</span> s1<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;abcde&quot;</span>;
    <span style="color: #0000ff;">char</span> s2<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;ac&quot;</span>;
    CPPUNIT_ASSERT_EQUAL<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s1,s2<span style="color: #000000;">&#41;</span>,s2<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;
    ...
    <span style="color: #00eeff;">CPPUNIT_ASSERT_EQUAL</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">strcmp</span><span style="color: #000000;">&#40;</span>max<span style="color: #000000;">&#40;</span>s2,s2<span style="color: #000000;">&#41;</span>,s2<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>; 
    &lt;i&gt;sztucznie wprowadzony bład!&lt;/i&gt;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: max_test_caller.cpp)
</p><p>Podzieliliśmy nasz test na kilka mniejszych, z których każdy testuje
zachowanie jednej klasy argumentów funkcji <tt>max</tt>. Zmienne używane
wspólnie zadeklarowalismy jako składowe klasy i inicjalizujemy w
konstruktorze. Potem pokażemy jak można wywoływać dodatkowy kod
inicjalizujący przed wykonaniem każdej metody, ale na razie ten
mechanizm nie jest nam potrzebny. 
</p><p>No, ale jak wywołać te testy? Klasa <tt>TestFixture</tt> nie jest testem i
nie posiada funkcji <tt>runTest</tt>. Aby móc jej użyć musimy skorzystać z
szablonu <tt>TestCaller</tt>. Szablon <tt>TestCaller</tt> przyjmuje jako swój
parametr klasę <tt>TextFixture</tt>, w naszym przypadku <tt>Max_test</tt>. W
konstruktorze obiektów tej klasy podajemy nazwę testu i adres metody
klasy <tt>Max_test</tt>, która ten test implementuje. Tak skonstruowany
obiekt jest już testem i możemy go przekazać do obiektu <tt>runner</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
CppUnit::<span style="color: #00eeff;">TextUi</span>::<span style="color: #00eeff;">TestRunner</span> runner;
&nbsp;
 runner.<span style="color: #00eeff;">addTest</span><span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;int_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">int_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
... &lt;i&gt;podobnie dla reszty metod klasy Maxtest&lt;/i&gt;
&nbsp;
runner.<span style="color: #00eeff;">run</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: max_test_caller.cpp)
</p><p>Teraz wykonanie programu spowoduje wywołanie 5 testów. Co ważne - 
niepowodzenie ktorejś z asercji w jednym teście przerywa wykonywanie
tego testu, ale nie ma wpływu na wykonywanie się innych testów. 
</p><p>Zamiast dodawać testy do "wykonywacza" pojedynczo, możemy je najpierw
pogrupować za pomocą obiektów <tt>TestSuite</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
CppUnit::<span style="color: #00eeff;">TextUi</span>::<span style="color: #00eeff;">TestRunner</span> runner;
 CppUnit::<span style="color: #00eeff;">TestSuite</span> *obj_suite = <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestSuite</span>;
 CppUnit::<span style="color: #00eeff;">TestSuite</span> *ptr_suite = <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestSuite</span>;
&nbsp;
 obj_suite-&gt;addTest<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;int_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">int_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>; 
 obj_suite-&gt;addTest<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;class_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">class_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
  ptr_suite-&gt;addTest<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;class_ptr_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">class_ptr_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
  ptr_suite-&gt;addTest<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;const_char_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">const_char_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
  ptr_suite-&gt;addTest<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestCaller</span>&lt;Max_test&gt;<span style="color: #000000;">&#40;</span>
                       <span style="color: #666666;">&quot;char_test&quot;</span>, 
                       &amp;Max_test::<span style="color: #00eeff;">char_test</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
  runner.<span style="color: #00eeff;">addTest</span><span style="color: #000000;">&#40;</span>obj_suite<span style="color: #000000;">&#41;</span>;
  runner.<span style="color: #00eeff;">addTest</span><span style="color: #000000;">&#40;</span>ptr_suite<span style="color: #000000;">&#41;</span>;
  runner.<span style="color: #00eeff;">run</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>Obiekty <tt>TestSuite</tt> są  testami i możemy je dalej grupować:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"> CppUnit::<span style="color: #00eeff;">TestSuite</span> *max_suite = <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">TestSuite</span>;
&nbsp;
 max_suite-&gt;addTest<span style="color: #000000;">&#40;</span>obj_suite<span style="color: #000000;">&#41;</span>;
 max_suite-&gt;addTest<span style="color: #000000;">&#40;</span>ptr_suite<span style="color: #000000;">&#41;</span>;
 runner.<span style="color: #00eeff;">addTest</span><span style="color: #000000;">&#40;</span>max_suite<span style="color: #000000;">&#41;</span>;
&nbsp;
runner.<span style="color: #00eeff;">run</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>Widać, że szkielet <tt>CppUnit</tt> daje nam sporo możliwości, ale ciągle
jest to niewspółmierne do włożonego wysiłku. Powodem tego jest prostota
użytego przykładu, który nie wymaga takich narzędzi. Pakiet
<tt>CppUnit</tt> posiada jednak o wiele więcej możliwości, między innymi:
</p>
<ul><li> W klasie <tt>TextFixture</tt> można przeładować funkcje <tt>void setUp()</tt> i <tt>void tearDown()</tt>, które będą wywoływane odpowiednio przed i po wykonaniu każdego testu. Mogą być użyte do konstrukcji środowiska testowego i jego rozmontowania. Nie używałem tej możliwości, bo nie była ona potrzebna w tak prostym przykładzie.
</li><li> Bardzo często chcemy wykonać razem wszystkie testy zdefiniowane w jednej klasie. <tt>CppUnit</tt> dostarcza makr ułatwiających grupowanie wszystkich metod danej klasy w jeden <tt>TestSuite</tt>.
</li><li> Szkielet <tt>CppUnit</tt> oferuje poza <tt>CPPUNIT_ASSERT_EQUAL</tt> szereg innych makr ulatwiających pisanie testów.
</li><li> Stosunkowo łatwo można zmienić format wyświetlania wyników testów np. dodanie 
</li></ul>

<div class="geshifilter"><pre class="geshifilter-cpp">      runner.<span style="color: #00eeff;">setOutputter</span><span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> CppUnit::<span style="color: #00eeff;">XmlOutputter</span><span style="color: #000000;">&#40;</span> 
                              &amp;runner.<span style="color: #00eeff;">result</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,
                              std::<span style="color: #0000dd;">cout</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;</pre></div>


<p>spowoduje wypisanie wyników testu w formacie XML.
</p>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_test_case.cpp">Max_test_case.cpp</a></td><td>1.54 KB</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_test_runner.cpp">Max_test_runner.cpp</a></td><td>1.84 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Max_test_caller.cpp">Max_test_caller.cpp</a></td><td>1.15 KB</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1241" class="section-2">
  <h1 class="book-heading">Klasy cech</h1>
  <h2>Wprowadzenie</h2>
<hr />
<br />

<p>Rozważmy próbę implementacji ogólnej funkcji sumowania elementów
tablicy (zob. D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i>, rozdz. 15).  Korzystając z wiadomości o
szablonach i konwencjach używanych w STL możemy napisać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  T total = T<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>;beg!&lt;nowiki&gt;=&lt;/nowiki&gt;end;++beg<span style="color: #000000;">&#41;</span>
    total +&lt;nowiki&gt;=&lt;/nowiki&gt; *beg;
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: sum1.cpp)
</p><p>
Przykład 5.1
</p>

<p>Ten prosty kod ma jednak co najmniej dwa problemy. Pierwszy związany
jest z linijką
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T total &lt;nowiki&gt;=&lt;/nowiki&gt; T<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>i wiąże się z ustaleniem zerowej wartości dla danego typu.  Powyższa
linijka oznacza, że zmienna <tt>total</tt> jest inicjalizowana
konstruktorem domyślnym klasy <tt>T</tt>. W przypadku typów wbudowanych
będzie to inicjalizacja wartością zerową, czyli tak jak tego
oczekujemy.  W przypadku innych typów możemy mieć tylko nadzieję, że
konstruktor defaultowy istnieje i robi to co trzeba :). Popatrzmy na
możliwe alternatywy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T total;</pre></div>

<p>W przypadku typów zdefiniowanych przez użytkownika wywoływany jest
defaultowy konstruktor (domyślny jeśli żaden inny nie jest zdefinowany). 
W przypadku typów wbudowanych wartość jest niekreślona!
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T total &lt;nowiki&gt;=&lt;/nowiki&gt; <span style="color: #0000dd;">0</span>;</pre></div>


<p>jest z kolei niepoprawne dla typów, na które nie ma rzutowania z liczb
całkowitych.
</p><p>Problem można ominąć jeżeli się zauważy, że dla niepustych zakresów
tzn. <tt>beg!=end</tt> nie potrzebujemy wcale wartości zerowej:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; T sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  T total= *beg;
  ++beg;
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
     total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>


<p>Jeśli jednak dopuszczamy podanie zakresu pustego, to funkcja powinna
zwrócić zero i problem powraca. 
</p><p>Drugi problem z przykładem 5.1 to typ zmiennej <tt>total</tt>. 
Popatrzmy na zastosowanie funkcji <tt>sum</tt>. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">char</span> name<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;@ @ @&quot;</span>;
<span style="color: #0000ff;">int</span> length=<span style="color: #0000dd;">strlen</span><span style="color: #000000;">&#40;</span>name<span style="color: #000000;">&#41;</span>;
cout&lt;&lt;sum<span style="color: #000000;">&#40;</span>name,&amp;name<span style="color: #000000;">&#91;</span>length<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>Programik powinien wypisać sumę wartości znaków w napisie
<tt>"name"</tt>. Łatwo sprawdzić że wypisuje znak o kodzie zero. Problem polega
na tym, że typ <tt>T</tt> niekoniecznie musi pomieścić wynik dodawania
elementów typu <tt>T</tt>. W tym przykładzie dodawanie znaków dało wynik
256 (co za niezwykły zbieg okoliczności), który już nie mieści się w
zakresie tego typu.
</p><p>Prostym rozwiązaniem jest dodanie dodatkowego parametru szablonu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename R,<span style="color: #0000ff;">typename</span> T&gt; R sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  R total = R<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: sum2.cpp)
</p><p>i wtedy zastosowanie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">cout&lt;&lt;sum&lt;int&gt;<span style="color: #000000;">&#40;</span>name,&amp;name<span style="color: #000000;">&#91;</span>length<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;</pre></div>

<p>da już oczekiwany wynik. Zaletą tego rozwiązania jest jego prostota i
duża elastyczność. Wadą - zwiększenie liczby parametrów szablonu, co
zawsze zwiększa złożoność kodu i możliwości popełnienia błędu, zwłaszcza, że typ <tt>R</tt> jest w większości przypadków określony przez
typ <tt>T</tt> i nie wnosi niezależnej informacji.
</p>

<h2>Klasy cech</h2>
<hr />
<br />

<p>Pomocą mogą służyć klasy cech: klasy, których funkcją jest dostarczanie
dodatkowych informacji o danym typie. W naszym przypadku możemy
zadeklarować szablon:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt;  <span style="color: #0000ff;">struct</span> sum_traits;</pre></div>

<p>i jego specjalizacje:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;char&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">int</span> sum_type; 
<span style="color: #000000;">&#125;</span>;
template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;int&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">long</span> <span style="color: #0000ff;">int</span> sum_type; 
<span style="color: #000000;">&#125;</span>;
template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;float&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">double</span> sum_type; 
<span style="color: #000000;">&#125;</span>;
template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;double&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">double</span> sum_type; 
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Szablon <tt>sum</tt> przerabiamy teraz na 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; 
<span style="color: #0000ff;">typename</span> sum_traits&lt;T&gt;::<span style="color: #00eeff;">sum_type</span> sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> sum_traits&lt;T&gt;::<span style="color: #00eeff;">sum_type</span> sum_type;
  sum_type total = sum_type<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: sum3.cpp)
</p><p>Wadą tego podejścia jest konieczność definiowania specjalizacji
szablonu <tt>sum_traits</tt> dla każdego typu, którego sumę będziemy
chcieli obliczyć. Można tego uniknąć definiując szablon ogólny
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt;  <span style="color: #0000ff;">struct</span> sum_traits <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> T sum_type;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>i możemy już wtedy użyć 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">complex&lt;double&gt; *c1,*c2;
sum<span style="color: #000000;">&#40;</span>c1,c2<span style="color: #000000;">&#41;</span>;</pre></div>

<p>bez dodatkowych definicji. To czy należy implementować uniwersalną
definicję klasy cech zależy od tego czy istnieje sensowna wartość
domyślna dla danej cechy. W naszym przypadku, definiując powyższy szablon,
zyskujemy na wygodzie ale tracimy na bezpieczeństwie, bo łatwiej jest teraz
wywołać funkcję <tt>sum</tt> z nieodpowiednim typem zmiennej <tt>total</tt>.
</p>

<h2>Cechy wartości</h2>
<hr />
<br />

<p>Możemy spróbować rozwiązać za pomocą klas cech również problem
inicjalizacji zmiennej <tt>total</tt>, definiując w każdej klasie
odpwiednią wartość zerową dla danego typu. Pytanie jak to zrobić?
Nasuwa się użycie stałych składowych statycznych:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;char&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">int</span>  sum_type;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> sum_type zero = <span style="color: #0000dd;">0</span>; 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Sęk w tym, że standard zezwala na incijalizowanie w klasie
statycznych stałych jedynie dla typów całkowitoliczbowych. Taka sama
konstrucja dla <tt>double</tt> już nie jest możliwa.
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;float&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">double</span>  sum_type;
<span style="color: #0000ff;">static</span>  <span style="color: #0000ff;">const</span> sum_type zero = <span style="color: #0000dd;">0.0</span>; niedozwolone
<span style="color: #000000;">&#125;</span>;</pre></div>



<p>Inicjalizator 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">typename</span> sum_traits&lt;float&gt;::<span style="color: #00eeff;">sum_type</span> 
sum_traits&lt;float&gt;::<span style="color: #00eeff;">zero</span> = <span style="color: #0000dd;">0.0</span>;</pre></div>

<p>musi być umieszczony w kodzie źródłówym. Po pierwsze nie bardzo wiadomo
gdzie go umieścić (nie może być w pliku nagłówkowym, bo łamało by to
zasadę jednokrotnej definicji). Po drugie kompilator najprawdopodobniej
nie umiałby powiązać nazwy stałej i jej wartości w czasie kompilacji. 
</p><p>Inną możliwością jest użycie funkcji statycznych rozwijanych w miejscu
wywołania:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;char&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">int</span>  sum_type;
<span style="color: #0000ff;">static</span>  sum_type zero<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">0</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;
template&lt;&gt;  <span style="color: #0000ff;">struct</span> sum_traits&lt;float&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">double</span>  sum_type;
<span style="color: #0000ff;">static</span>  sum_type zero<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">0.0</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Odpowiadający temu podejściu kod  funkcji <tt>sum</tt> bedzie wyglądał następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; 
<span style="color: #0000ff;">typename</span> sum_traits&lt;T&gt;::<span style="color: #00eeff;">sum_type</span> sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> sum_traits&lt;T&gt;::<span style="color: #00eeff;">sum_type</span> sum_type;
  sum_type total = sum_traits&lt;T&gt;::<span style="color: #00eeff;">zero</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>

<p>Dobry kompilator powinien bez trudu rozwinąć definicję funkcji
i podstawić odpowiednią wartość bezpośrednio w kodzie.
</p>

<h2>Parametryzacja klasami cech</h2>
<hr />
<br />

<p>Opisana powyżej implementacja funkcji <tt>sum</tt> i związanej z nią klasy
<tt>sum_traits</tt> jest mało elastyczna. Wybierając typ przekazanej
tablicy wybieramy typ zmiennej <tt>total</tt>. Może się jednak zdażyć, że
chcemy sumować <tt>int</tt> we <tt>float</tt>, a <tt>float</tt> we <tt>float</tt>. 
</p><p>Możemy dodać dodatkowy parametr do szablonu, który będzie definiował
wybraną klasę cech. Ale to jest powrót do rozwiązania odrzuconego na
początku. Rozwiązaniem może być uczynienie tego parametru parametrem
domyślnym, tak, aby nie trzeba było podawać go jawnie w typowych
przypadkach. Jest to bardzo dobre rozwiązanie w przypadku użycia klas
cech w szablonach klas. Problem w tym, że szablony funkcji nie
dopuszczają stosowania parametrów domyślnych.
Możemy to obejść za pomocą przeciążenia definiując:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename Traits,<span style="color: #0000ff;">typename</span> T &gt; 
<span style="color: #0000ff;">typename</span> Traits::<span style="color: #00eeff;">sum_type</span> sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Traits::<span style="color: #00eeff;">sum_type</span> sum_type;
  sum_type total = sum_type<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span>;
&nbsp;
template&lt;typename T &gt; 
<span style="color: #0000ff;">typename</span> sum_traits&lt;T&gt;::<span style="color: #00eeff;">sum_type</span> sum<span style="color: #000000;">&#40;</span>T *beg,T *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">return</span> sum&lt;sum_traits&lt;T&gt;, T&gt;<span style="color: #000000;">&#40;</span>beg,end<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>
&nbsp;
<span style="color: #0000ff;">struct</span> char_sum <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">char</span> sum_type;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: sum4.cpp)
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">char</span> name<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span>=<span style="color: #666666;">&quot;@ @ @&quot;</span>;
<span style="color: #0000ff;">int</span> length=<span style="color: #0000dd;">strlen</span><span style="color: #000000;">&#40;</span>name<span style="color: #000000;">&#41;</span>;
&nbsp;
 cout&lt;&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>sum<span style="color: #000000;">&#40;</span>name,&amp;name<span style="color: #000000;">&#91;</span>length<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
 cout&lt;&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>sum&lt;char_sum&gt;<span style="color: #000000;">&#40;</span>name,&amp;name<span style="color: #000000;">&#91;</span>length<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
 cout&lt;&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>sum&lt;char&gt;<span style="color: #000000;">&#40;</span>name,&amp;name<span style="color: #000000;">&#91;</span>length<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: sum4.cpp)
</p>

<h2>iterator_traits</h2>
<hr />
<br />


<p>Na koniec spróbujmy uogólnić funkcję <tt>sum</tt>, aby działała nie tylko
ze wskaźnikami, ale i iteratorami. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename IT&gt; sum<span style="color: #000000;">&#40;</span>IT *beg,IT *end<span style="color: #000000;">&#41;</span>;</pre></div>

<p>Widać, że tu użycie klas cech jest już niezbędne, musimy bowiem
dowiedzieć się na obiekty jakiego typu wskazuje iterator. Nie można do
tego celu użyć typów stowarzyszonych <tt>IT::value_type</tt>, bo jako
iterator może zostać podstawiony zwykły wskaźnik.  Dlatego w STL
istnieje klasa <tt>iterator_traits</tt>, definiująca podstawowe typy dla
każdego rodzaju iteratora. Korzystając z tej klasy można zdefiniować
ogólny szalon funkcji <tt>sum</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename II&gt; 
<span style="color: #0000ff;">typename</span> 
sum_traits&lt;typename iterator_traits&lt;II&gt;::<span style="color: #00eeff;">value_type</span>&gt;::<span style="color: #00eeff;">sum_type</span> 
sum<span style="color: #000000;">&#40;</span>II beg,II *end<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> iterator_traits&lt;IT&gt;::<span style="color: #00eeff;">value_type</span> value_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> sum_traits&lt;value_type&gt;::<span style="color: #00eeff;">sum_type</span> sum_type;
  sum_type total = sum_traits&lt;value_type&gt;::<span style="color: #00eeff;">zero</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>beg != end <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    total += *beg; beg++; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">return</span> total; 
<span style="color: #000000;">&#125;</span></pre></div>


<p>Zanim omówię klasę <tt>iterator_trais</tt> podam rozwiązanie zastosowane w
STL. Tam funkcja nazywa się <tt>accumulate</tt> i jest zaimplementowana
następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator, <span style="color: #0000ff;">class</span> T&gt;
T accumulate<span style="color: #000000;">&#40;</span>InputIterator first, InputIterator last, T init<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      <span style="color: #0000ff;">for</span> <span style="color: #000000;">&#40;</span>; first != last; ++first<span style="color: #000000;">&#41;</span>
        init = init + *first;
      <span style="color: #0000ff;">return</span> init;
    <span style="color: #000000;">&#125;</span></pre></div>


<p>Przykład 5.2
</p>

<p>Dodanie dodatkowego parametru wywołania funkcji rozwiązuje za jednym
zamachem oba nasze problemy: parametr ten dostarcza zarówno typu,
jak i wartości początkowej dla zmiennej sumującej.  Są jednak inne
algorytmy w STL, które wymagają więcej informacji o iteratorze i muszą
je pobrać za pomocą <tt>iterator_traits</tt>. 
</p><p>Dla iteratorów nie będących wskaźnikami <tt>iterator_traits</tt> po prostu
przepisują ich typy stowarzyszone: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class Iterator&gt;
  <span style="color: #0000ff;">struct</span> iterator_traits <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Iterator::<span style="color: #00eeff;">iterator_category</span> iterator_category;
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Iterator::<span style="color: #00eeff;">value_type</span>        value_type;
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Iterator::<span style="color: #00eeff;">difference_type</span>   difference_type;
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Iterator::<span style="color: #00eeff;">pointer</span>           pointer;
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Iterator::<span style="color: #00eeff;">reference</span>         reference;
  <span style="color: #000000;">&#125;</span>;</pre></div>


<p>Dla typów wskaźnikowych jest podana odpowiednia specjalizacja. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T&gt;
  <span style="color: #0000ff;">struct</span> iterator_traits&lt;T*&gt; <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">typedef</span> random_access_iterator_tag iterator_category;
    <span style="color: #0000ff;">typedef</span> T                          value_type;
    <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">ptrdiff_t</span>                  difference_type;
    <span style="color: #0000ff;">typedef</span> T*                         pointer;
    <span style="color: #0000ff;">typedef</span> T&amp;                         reference;
  <span style="color: #000000;">&#125;</span>;</pre></div>

<p>Widać więc, że każdy iterator nie będący wskaźnikiem musi mieć
zdefiniowane odpowiednie typy stowarzyszone. Ułatwia to szablon klasy
<tt>iterator</tt>, z którego można dziedziczyć:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span>
template&lt;class Category, <span style="color: #0000ff;">class</span> T, <span style="color: #0000ff;">class</span> Distance = <span style="color: #0000ff;">ptrdiff_t</span>,
<span style="color: #0000ff;">class</span> Pointer = T*, <span style="color: #0000ff;">class</span> Reference = T&amp;&gt;
<span style="color: #0000ff;">struct</span> iterator <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> T value_type;
<span style="color: #0000ff;">typedef</span> Distance difference_type;
<span style="color: #0000ff;">typedef</span> Pointer pointer;
<span style="color: #0000ff;">typedef</span> Reference reference;
<span style="color: #0000ff;">typedef</span> Category iterator_category;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Na uwagę zasługuje typ <tt>iterator_category</tt>. Ten typ służy do
automatycznego wyboru odpowiednich funkcji w oparciu o kategorię
iteratora. Kategorie odpowiadają konceptom iteratorów i są
reprezentowane przez puste klasy. W STL zdefiniowano pięć kategorii  
iteratorów:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">struct</span> input_iterator_tag <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">struct</span> output_iterator_tag <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">struct</span> forward_iterator_tag: <span style="color: #0000ff;">public</span> input_iterator_tag <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">struct</span> bidirectional_iterator_tag: <span style="color: #0000ff;">public</span> forward_iterator_tag <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">struct</span> random_access_iterator_tag: <span style="color: #0000ff;">public</span> bidirectional_iterator_tag <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Aby zilustrować zastosowanie typu <tt>iterator_category</tt> przedstawię
implementację funkcji <tt>distance()</tt>, która oblicza odległość pomiędzy
dwoma iteratorami. Potrzeba użycia <tt>iterator_category</tt> bierze się
stąd, że dla iteratorów o dostępie swobodnym możemy policzyć ją
bezpośrednio przez odejmowanie: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class _RandomAccessIterator&gt;
<span style="color: #0000ff;">inline</span> 
<span style="color: #0000ff;">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::<span style="color: #00eeff;">difference_type</span>
__distance<span style="color: #000000;">&#40;</span>_RandomAccessIterator __first, 
           _RandomAccessIterator __last,
             random_access_iterator_tag<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">return</span> __last - __first;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Dla reszty musimy po kolei zwiekszać
jeden iterator aż osiągniemy drugi: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class _InputIterator&gt;
<span style="color: #0000ff;">inline</span> 
<span style="color: #0000ff;">typename</span> iterator_traits&lt;_InputIterator&gt;::<span style="color: #00eeff;">difference_type</span>
__distance<span style="color: #000000;">&#40;</span>_InputIterator __first, 
           _InputIterator __last, 
             input_iterator_tag<span style="color: #000000;">&#41;</span>
<span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typename</span> iterator_traits&lt;_InputIterator&gt;::<span style="color: #00eeff;">difference_type</span> __n = <span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">while</span> <span style="color: #000000;">&#40;</span>__first != __last<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    ++__first; ++__n;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">return</span> __n;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Do wyboru pomiędzy tymi dwoma
implementacjami służy właśnie <tt>iterator_category</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class _InputIterator&gt;
<span style="color: #0000ff;">inline</span> 
<span style="color: #0000ff;">typename</span> iterator_traits&lt;_InputIterator&gt;::<span style="color: #00eeff;">difference_type</span>
distance<span style="color: #000000;">&#40;</span>_InputIterator __first, _InputIterator __last<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> 
     <span style="color: #0000ff;">typename</span> 
     iterator_traits&lt;_InputIterator&gt;::<span style="color: #00eeff;">iterator_category</span> 
    _Category;
&nbsp;
  <span style="color: #0000ff;">return</span> __distance<span style="color: #000000;">&#40;</span>__first, __last, _Category<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<h2>numeric_limits</h2>
<hr />
<br />

<p>Przykładem klasy cech zawartej w standardzie C++ jest szablon 
<tt>numeric_limits</tt>, który zastępuje używane w C makra, zdefiniowane
w pliku <tt>limits.h</tt>. Szablon <tt>numeric_limits</tt> posiada specjalizację dla 
każdego typu podstawowego wbudowanego (zob. tab. 5.1]) i zawiera informację na temat różnych cech ich implementacji (zob. tab. 5.2]).
Warto zwrócić uwagę na następującą konstrukcję: szablon
<tt>numeric_limits</tt> definiuje stałą logiczną <tt>is_specialised</tt>.
Domyślnie jest ona równa <tt>false</tt>. Każda specjalizacja szablonu
ustawia ją na <tt>true</tt>. W ten sposób stała
<tt>std::numeric_limits<T>::is_specialised</t></tt> mówi nam czy dany typ jest
opisany przez <tt>numeric_limits</tt> czy nie.
</p><p><span id="tab.5.1"></span>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span>
template&lt;class T&gt; <span style="color: #0000ff;">class</span> numeric_limits;
<span style="color: #0000ff;">enum</span> float_round_style;
<span style="color: #0000ff;">enum</span> float_denorm_style;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;bool&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;char&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;signed char&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;unsigned char&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;wchar_t&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;short&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;int&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;long&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;unsigned short&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;unsigned int&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;unsigned long&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;float&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;double&gt;;
template&lt;&gt; <span style="color: #0000ff;">class</span> numeric_limits&lt;long double&gt;;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Tablica 5.1. Specjalizacje szablonu <tt>numeric_limits</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span>
template&lt;class T&gt; <span style="color: #0000ff;">class</span> numeric_limits <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_specialized = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> T min<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T max<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> digits = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> digits10 = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_signed = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_integer = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_exact = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> radix = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> T epsilon<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T round_error<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> min_exponent = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> min_exponent10 = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> max_exponent = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> max_exponent10 = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> has_infinity = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> has_quiet_NaN = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> has_signaling_NaN = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> float_denorm_style has_denorm = denorm_absent;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> has_denorm_loss = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> T infinity<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T quiet_NaN<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T signaling_NaN<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T denorm_min<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_iec559 = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_bounded = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> is_modulo = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> traps = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> tinyness_before = <span style="color: #0000ff;">false</span>;
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> float_round_style round_style = round_toward_zero;
<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Tablica 5.2. Szablon <tt>numeric_limits</tt>
</p>
<table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sum1.cpp">Sum1.cpp</a></td><td>284 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sum2.cpp">Sum2.cpp</a></td><td>294 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sum3.cpp">Sum3.cpp</a></td><td>692 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sum4.cpp">Sum4.cpp</a></td><td>975 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1242" class="section-2">
  <h1 class="book-heading">Funkcje typów i inne sztuczki</h1>
  <h2>Wprowadzenie</h2>
<hr />

<p>Funkcja jest podstawowym pojęciem w większości języków programowania,
z którym wszyscy jesteśmy dobrze obeznani.  Funkcje przyjmują zestaw
argumentów i zwracają jakąś wartość. Szablony dają ciekawą możliwość
interpretowania ich jako funkcji typów: funkcje których argumentem są
typy, a wartością zwracaną typ lub jakaś wartość. Weźmy dla przykładu
szablon <tt>sum_traits</tt> z poprzedniego modułu. Można interpretować go
jako dwie funkcje przyjmujące typ poprzez  parametr szablonu i zwracające
albo wartość
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">sum_traits&lt;int&gt;::<span style="color: #00eeff;">zero</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>albo typ
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">sum_traits&lt;int&gt;::<span style="color: #00eeff;">sum_type</span></pre></div>

<p>Takie funkcje możemy definiować poprzez wypisanie wszystkich
specjalizacji pełnych jak w przypadku <tt>sum_traits</tt> albo przez
wykorzystanie specjalizacji częściowych, jak np. dla
<tt>iterator_traits</tt>. Najciekawsza możliwość to jednak pisanie
"obliczalnego kodu" takich funkcji, przy czym "obliczenia" dokonują
się w czasie kompilacji. Przykłady takich funkcji zostaną podane na
tym wykładzie. W realnych zastosowaniach wykorzystuje się kombinację
wszystkich powyższych możliwości.
</p><p>Korzystając z szablonów można również uogólnić pojęcie listy i
definiować listy typów. Umożliwiają one między innymi indeksowany
dostęp do swoich składowych, przekazywanie zmiennej liczby parametrów
typu do szablonów i automatyczną generację hierarchii klas opartych na
tych typach. Listy typów omówię w drugiej części tego wykładu.
</p>

<h2>Funkcje typów</h2>
<hr />
<br />

<h3>If-Then-Else</h3>

<p>Zacznę od przydatnej konstrukcji implementującej możliwość wyboru
jednego z dwu typów na podstawie stałej logicznej (typu <tt>bool</tt>).
Dokonujemy tego za pomocą szablonu podstawowego 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;bool flag,<span style="color: #0000ff;">typename</span> T1,<span style="color: #0000ff;">typename</span> T2&gt; <span style="color: #0000ff;">struct</span> If_then_else <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> T1 Result; 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>który będzie podstawiany dla wartości <tt>flag=true</tt> i jego
specjalizacji dla wartości <tt>flag=false</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T1,<span style="color: #0000ff;">typename</span> T2&gt; 
<span style="color: #0000ff;">struct</span> If_then_else&lt;false,T1,T2&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> T2 Result; 
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Teraz możemy go np. wykorzystać do wybrania większego z dwu typów:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T1,typenameT2&gt; <span style="color: #0000ff;">struct</span> Greater_then <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> If_then_else&lt;sizeof<span style="color: #000000;">&#40;</span>T1<span style="color: #000000;">&#41;</span>&gt;sizeof<span style="color: #000000;">&#40;</span>T2<span style="color: #000000;">&#41;</span>,T1,T2&gt;::<span style="color: #00eeff;">result</span>
 result;
<span style="color: #000000;">&#125;</span>;</pre></div>

<h3>Sprawdzanie czy dany typ jest klasą</h3>
<br />

<p>Następny przykład to szablon służący do sprawdzania czy dany typ jest
klasą. Wykorzystamy w tym celu operator <tt>sizeof()</tt> i przeciążane
szablony funkcji razem z zasadą "nieudane podstawienie nie jest
błędem" (zob. wykład 3.5). Potrzebujemy więc wyrażenia, które nie ma sensu
dla dla typów nie będacych klasami. Takim wyrażeniem będzie <tt>int
C::*</tt> oznaczające wskaźnik do pola składowego klasy <tt>C</tt> typu
<tt>int</tt>.  Cały szablon wygląda następująco.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> Is_class <span style="color: #000000;">&#123;</span>
  <span style="color: #ff0000;">//najpierw definiujemy dwa typy różniące sie rozmiarem</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">char</span> one;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">struct</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">char</span> c<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span> two;
  <span style="color: #ff0000;">//teraz potrzebne bedą dwa przeładowane szablony</span>
  template&lt;typename U&gt; <span style="color: #0000ff;">static</span> one test<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> U::<span style="color: #00eeff;">*</span><span style="color: #000000;">&#41;</span>; 
  template&lt;typename U&gt; <span style="color: #0000ff;">static</span> two test<span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span>;
  <span style="color: #ff0000;">//to który szablon został wybrany sprawdzamy poprzez sprawdzenie rozmiaru zwracanego typu</span>
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>yes = <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>test&lt;T&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>one<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: is_class.cpp)
</p><p>Operator <tt>sizeof(test<T>(0))</t></tt> musi rozpoznać typ zwracany przez
funkcję <tt>test<T>(0)</t></tt>. W tym celu uruchamiany jest mechanizm
rozstrzygania przeciążenia. Jeśli typ <tt>T</tt> nie jest klasą to próba
podstawienia pierwszej funkcji spowoduje powstanie niepoprawnej
konstrukcji <tt>T::*</tt> i podstawienie się nie powiedzie. Druga funkcja
ma argumenty pasujące do czegokolwiek więc jej podstawienie zawsze się
powiedzie.  Druga funkcja zwraca typ o rozmiarze większym od rozmiaru
typu <tt>one</tt> więc stała <tt>yes</tt> otrzyma wartość <tt>false</tt>.
</p><p>Jeśli typ <tt>T</tt> jest klasą to <tt>int T::*</tt> jest poprawne (na tym
etapie nie jest istotne czy klasa w ogóle posiada taką składową) i
mechanizm rozstrzygania będzie pracował dalej, sprawdzając czy argument
wywołania jest zgodny z <tt>int T::*</tt>. W tym przypadku jest to zero,
które może być użyte jako wskaźnik, więc podstawienie się powiedzie.
Oczywiście drugie podstawienie też by się powiodło
ale jest mniej specjalizowane. W wyniku zmienna <tt>yes</tt> otrzyma
wartość <tt>true</tt>.
Warto zauważyć, że gdybyśmy zamiast zera podstawili jako argument
funkcji <tt>test<T>(int T::*)</t></tt> jakąś inna liczbę całkowitą to podstawienie
się nie powiedzie i zawsze otrzymamy fałsz dla zmiennej <tt>yes</tt>.
</p>

<h3>Sprawdzanie możliwości rzutowania</h3>
<br />

<p>Kolejny przykład wykorzystuje tę samą technikę w celu stwierdzenia czy
jeden z typów można rzutować na drugi.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> U&gt; <span style="color: #0000ff;">class</span> Is_convertible <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">char</span> one;
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">struct</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">char</span> c<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span> two;
&lt;i&gt;tym razem korzystamy ze zwykłych przeciążonych funkcji&lt;/i&gt;
<span style="color: #0000ff;">static</span> one test<span style="color: #000000;">&#40;</span>U<span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> two test<span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">static</span> T makeT<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
<span style="color: #0000ff;">public</span>: <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>yes = <span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>test<span style="color: #000000;">&#40;</span>makeT<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>one<span style="color: #000000;">&#41;</span>,
  same_type=<span style="color: #0000ff;">false</span> <span style="color: #000000;">&#125;</span>; <span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: convertible.cpp)
</p><p>Teraz sprawdzane są dwie przeciążone funkcje.
<tt>makeT()</tt> zwraca obiekt typu <tt>T</tt> więc jeśli typ <tt>T</tt> może być
rzutowany na <tt>U</tt> to wybrane zostanie dopasowanie pierwszej funkcji
jako bardziej wyspecjalizowanej. Funkcja <tt>makeT()</tt> została użyta
zamiast np. <tt>T()</tt>, bo konstruktor defaultowy może dla tego typu nie
istnieć. Dodatkowa specjalizacja 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> Is_convertible&lt;T,T&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>yes = <span style="color: #0000ff;">true</span>,
      same_type=<span style="color: #0000ff;">true</span> <span style="color: #000000;">&#125;</span>; 
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: convertible.cpp)
</p><p>pozwala nam  użyć tej klasy do identyfikacji identycznych typów.
</p>

<h3>Zdejmowanie kwalifikatorów</h3>
<br />

<p>Każdy typ w C++ może być opatrzony dodatkowymi kwalifikatorami, takimi
jak <tt>const</tt> czy <tt>&</tt> (referencja). Mając dany typ <tt>T</tt> dodanie
do niego kwalifikatora jest proste. Z pozoru jednak może się to wiązać
z możliwością wygenerowania niepoprawnych podwójnych kwalifikatorów
np. <tt>const const T</tt>. Okazuje się jednak, że o ile 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> i =<span style="color: #0000dd;">0</span>;</pre></div>

<p>jest konstrukcją nieprawdłową, to w przypadku argumentów szablonu
nadmiarowe kwalifikatory zostaną zignorowane. Wyrażenie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> const_const <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">const</span> T t = T<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;
const_const&lt;const int&gt; a;</pre></div>

<p>jest poprawne i pole <tt>t</tt> będzie typu <tt>const int</tt>. To samo tyczy
się referencji. Pomimo tych udogodnień może być konieczna operacja
usunięcia jednego lub obydwu kwalifikatorów i uzyskanie gołego typu
podstawowego. W tym celu możemy zdefiniować szablon (zob. D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i>, rozdz. 17)
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Strip <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> T arg_t;
  <span style="color: #0000ff;">typedef</span> T striped_t;
  <span style="color: #0000ff;">typedef</span> T base_t;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">const</span> T   const_type;
&nbsp;
  <span style="color: #0000ff;">typedef</span> T&amp;        ref_type;
  <span style="color: #0000ff;">typedef</span> T&amp;        ref_base_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">const</span> T &amp; const_ref_type;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>i jego specjalizację dla typów z kwalifikatorem <tt>const</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Strip&lt; T const&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">const</span> T arg_t;
  <span style="color: #0000ff;">typedef</span>       T striped_t;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Strip&lt;T&gt;::<span style="color: #00eeff;">base_t</span>  base_t;
  <span style="color: #0000ff;">typedef</span> T <span style="color: #0000ff;">const</span>   const_type;
&nbsp;
  <span style="color: #0000ff;">typedef</span> T <span style="color: #0000ff;">const</span> &amp; ref_type;
  <span style="color: #0000ff;">typedef</span> T &amp;       ref_base_type;
  <span style="color: #0000ff;">typedef</span> T <span style="color: #0000ff;">const</span> &amp; const_ref_type;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>i dla  referencji
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Strip&lt;T&amp;&gt; <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">typedef</span> T&amp; arg_t;
  <span style="color: #0000ff;">typedef</span> T  striped_t;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Strip&lt;T&gt;::<span style="color: #00eeff;">base_t</span>  base_t;
  <span style="color: #0000ff;">typedef</span> base_t <span style="color: #0000ff;">const</span>    const_type;
&nbsp;
  <span style="color: #0000ff;">typedef</span> T               ref_type;
  <span style="color: #0000ff;">typedef</span> base_t &amp;        ref_base_type;
  <span style="color: #0000ff;">typedef</span> base_t <span style="color: #0000ff;">const</span> &amp;  const_ref_type;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: strip.cpp)
</p><p>Proszę zwrócić uwagę na  konstrukcję 
</p>


<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Strip&lt;T&gt;::<span style="color: #00eeff;">base_t</span>  base_t;</pre></div>

<p>Ponieważ typ <tt>T</tt> może oznaczać typ kwalifikowany za pomocą
<tt>const</tt>, wykorzystujemy rekurencyjne odwołanie aby uzyskać typ
podstawowy. Jest to przykład techniki metaprogramowania, która 
bardziej szczegółowo będzie omówiona w wykładzie 8.
</p>

<h3>Cechy typów</h3>
<br />

<p>Jednym z rodzajów klas cech (omawianych w poprzednim wykładzie) są cechy typów. Nie są one specjalizowane do jednego konkretnego celu, ale służą do dostarczania ogólnych informacji na temat dowolnych typów. Wymieniamy je w tym wykładzie, ponieważ do ich implementacji często stosowane są różne techniki opisane powyżej. Bardzo dobry szczegółowy opis implementacji cech typów znajduje się w D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i>. Gotową implementację typu <tt>boost::type_traits</tt> można znaleźć w repozytorium <tt>boost</tt>. Inna - to biblioteka <tt>Loki</tt> opisana w A. Alexandrescu <i>"Nowoczesne projektowanie w C++"</i>.
</p>

<h3>Cechy promocji</h3>
<br />

<p>Załóżmy, że postanowiliśmy zaimplementować możliwość 
dodawania wektorów: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; std::<span style="color: #00eeff;">vector</span>&lt;T&gt; 
operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> std::<span style="color: #00eeff;">vector</span>&lt;T&gt;  &amp;a,
           <span style="color: #0000ff;">const</span> std::<span style="color: #00eeff;">vector</span>&lt;T&gt;  &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>a.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==b.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
  std::<span style="color: #00eeff;">vector</span>&lt;T&gt; res<span style="color: #000000;">&#40;</span>a<span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;a.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;++i<span style="color: #000000;">&#41;</span>
    res<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>+=b<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;
&nbsp;
  <span style="color: #0000ff;">return</span> res;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: promote.cpp)
</p><p>Teraz polecenia 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">vector</span>&lt;double&gt; x<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>;
std::<span style="color: #00eeff;">vector</span>&lt;double&gt; y<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>;
&nbsp;
x+y;</pre></div>

<p>( Źródło: promote.cpp)
</p><p>skompilują  się, ale 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">vector</span>&lt;int&gt;    l<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>;
&nbsp;
x+l;</pre></div>
<p>już nie. Ponieważ dodawanie <tt>double</tt> do <tt>int</tt> jest dozwolone, to
rozsądne by było aby nasza implemenatacja też na to zezwalała. Przerabiamy 
więc nasz <tt>operator+()</tt> (lub dodajemy przeciążenie):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> U&gt; std::<span style="color: #00eeff;">vector</span>&lt;T&gt; 
operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> std::<span style="color: #00eeff;">vector</span>&lt;T&gt;  &amp;a,
           <span style="color: #0000ff;">const</span> std::<span style="color: #00eeff;">vector</span>&lt;U&gt;  &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span>a.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==b.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
  std::<span style="color: #00eeff;">vector</span>&lt;T&gt; res<span style="color: #000000;">&#40;</span>a<span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;a.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;++i<span style="color: #000000;">&#41;</span>
    res<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>+=b<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;
&nbsp;
  <span style="color: #0000ff;">return</span> res;
<span style="color: #000000;">&#125;</span></pre></div>


<p>Kłopot z tą definicją to typ zwracany, który zależy teraz od
kolejności składników dodawania, a nie od ich typu. Abu rozwiązać ten
problem zdefiniujemy sobie klasę cech, która będzie określała typ
wyniku na podstawie typu składników. Wybierzemy następującą strategię:
jeśli typy mają różny rozmiar to wybieramy typ większy, jeżeli mają
ten sam rozmiar to liczymy na specjalizacje:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T1,<span style="color: #0000ff;">typename</span> T2&gt; <span style="color: #0000ff;">struct</span> Promote <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> 
        If_then_else&lt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>T1<span style="color: #000000;">&#41;</span> &gt; <span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>T2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>,
                     T1,
                     <span style="color: #0000ff;">typename</span> If_then_else&lt; <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>T1<span style="color: #000000;">&#41;</span>&lt; <span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>T2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>,
                                           T2,
                                           void&gt;::<span style="color: #00eeff;">Result</span> &gt;::<span style="color: #00eeff;">Result</span> Result;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: promote.cpp)
</p><p>Dla identycznych typów wynik jest jasny (choć jak przekonuje nas
przykład 5.1 typ sumy nie musi być typem składników),
ale niemniej musimy go zdefiniować:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Promote&lt;T,T&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> T Result;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: promote.cpp)
</p><p>Resztę musimy definiować ręcznie korzystając ze specjalizacji pełnych.
Można to sobie uprościć definiując makro
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#define MK_PROMOTE(T1,T2,Tr)               \</span>
    template&lt;&gt; <span style="color: #0000ff;">class</span> Promotion&lt;T1, T2&gt; <span style="color: #000000;">&#123;</span>   \
      <span style="color: #0000ff;">public</span>:                              \
        <span style="color: #0000ff;">typedef</span> Tr Result;                 \
    <span style="color: #000000;">&#125;</span>;                                     \
                                           \
    template&lt;&gt; <span style="color: #0000ff;">class</span> Promotion&lt;T2, T1&gt; <span style="color: #000000;">&#123;</span>   \
      <span style="color: #0000ff;">public</span>:                              \
        <span style="color: #0000ff;">typedef</span> Tr Result;                 \
    <span style="color: #000000;">&#125;</span>;
&nbsp;
MK_PROMOTE<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">bool</span>, <span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>
MK_PROMOTE<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">bool</span>, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>
MK_PROMOTE<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">bool</span>, <span style="color: #0000ff;">signed</span> <span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span></pre></div>


<p>( Źródło: promote.cpp)
</p>
<h2>Listy typów</h2>
<hr />
<br />

<h3>Definicja</h3>
<br />

<p>Listy typów są ciekawą konstrukcją zaproponowaną przez Alexandrescu.
Ich szczegółowy opis i zastosowania można znaleźć w A. Alexandrescu <i>"Nowoczesne projektowanie w C++"</i>. Definicja listy typów opiera się na
rekurencyjnej implementacji listy znanej miedzy innymi z <tt>Lisp-a</tt>: lista
składa się z pierwszego elementu (głowy) i reszty (ogona), co możemy
zapisać jako:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename H,<span style="color: #0000ff;">typename</span> T&gt; <span style="color: #0000ff;">struct</span> Type_list <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> H head;
<span style="color: #0000ff;">typedef</span> T tail;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: typelist.h)
</p><p>Do tego potrzebna nam jest jeszcze definicja pustego typu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Null_type <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>jako znacznika końca listy. I tak:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Type_list&lt;int,Null_type&gt;</pre></div>

<p>oznacza jednoelementową listę <tt>(int)</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Type_list&lt;double,Type_list&lt;int,Null_type&gt; &gt;</pre></div>

<p>listę dwuelemntową <tt>(double,int)</tt> i tak dalej.
</p>

<h3>Length</h3>
<br />

<p>Ta prosta struktura daje zadziwiająco wiele możliwości. Na początek
napiszemy funkcję zwracającą długość listy. W tym celu skorzystamy z
rekurencyjnej definicji: długość listy to jeden plus długość ogona,
długość listy pustej wynosi zero. Tę definicję implementujemy następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Length;
template&lt;&gt; <span style="color: #0000ff;">struct</span> Length&lt;Null_type&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>value = <span style="color: #0000dd;">0</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
&nbsp;
template&lt;typename H,<span style="color: #0000ff;">typename</span> T&gt; <span style="color: #0000ff;">struct</span> Length&lt;Type_list&lt;H,T&gt; &gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>value = <span style="color: #0000dd;">1</span> + Length&lt;T&gt;::<span style="color: #00eeff;">value</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: typelist.h)
</p>

<h3>Indeksowanie</h3>
<hr />

<p>Tą samą techniką możemy zaimplementować indeksowany dostęp do
elementów listy.  Znów korzystamy z rekurencji: element o indeksie
<tt>i</tt> to albo głowa (jeśli <tt>i==0</tt>), albo element o indeksie <tt>i-1</tt> w jej ogonie.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">size_t</span> I&gt; <span style="color: #0000ff;">struct</span> At;
&nbsp;
template&lt;typename T,<span style="color: #0000ff;">typename</span> H&gt; <span style="color: #0000ff;">struct</span> At&lt;T,<span style="color: #0000dd;">0</span>&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> T result;
<span style="color: #000000;">&#125;</span>;
&nbsp;
template&lt;typename T,<span style="color: #0000ff;">typename</span> H&gt; <span style="color: #0000ff;">struct</span> At&lt;T,I&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> At&lt;H,I<span style="color: #0000dd;">-1</span>&gt;::<span style="color: #00eeff;">result</span> result;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: typelist.h)
</p>

<h3>Generowanie switch-a</h3>
<br />

<p>W bibliotece <tt>boost</tt> jest zaimplementowana klasa <tt>any</tt>, której obiekty
mogą reprezentować dowolną wartość (zob. boost). Żeby taką wartość odczytać musimy użyć odpowiedniej konkretyzacji szablonu  funkcji <tt>any_cast</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">boost::<span style="color: #00eeff;">any</span> val;
cout&lt;&lt;any_cast&lt;int&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;endl;</pre></div>

<p>Jeśli w szablonie podstawimy nie ten typ co trzeba, to otrzymamy
wyjątek. Chcemy teraz napisać funkcję, która drukuje wartości typu
<tt>any</tt>, przy czym wiemy, że przechowywane są w nich wartości tylko
kilku wybranych typów (np. <tt>int</tt>, <tt>double</tt>, <tt>string</tt>).
Ponieważ <tt>any</tt> udostępnia informację o typie przechowywanej w niej
wartości moglibyśmy taką funkcję <tt>print_any()</tt> zaimplementować
następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">print_any<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">ostream</span> &amp;of,boost::<span style="color: #00eeff;">any</span> val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>val.<span style="color: #00eeff;">type</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000ff;">typeid</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>
       of&lt;&lt;any_cast&lt;int&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
     <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> val.<span style="color: #00eeff;">type</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000ff;">typeid</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>
       of&lt;&lt;any_cast&lt;double&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
     <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> val.<span style="color: #00eeff;">type</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000ff;">typeid</span><span style="color: #000000;">&#40;</span>string<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>
       of&lt;&lt;any_cast&lt;string&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
     <span style="color: #0000ff;">else</span> 
       of&lt;&lt;<span style="color: #666666;">&quot;unsuported type&quot;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;       
<span style="color: #000000;">&#125;</span></pre></div>

<p>Sprobujemy teraz zaimplementować to samo za pomocą list typów, dodatkowo
zażądamy aby móc drukować również wartości typu <tt>vector<T></t></tt>, gdzie
<tt>T</tt> jest typem z listy.
</p><p>Jak zwykle musimy sformułować problem rekurencyjnie: 
sprawdzamy czy typ <tt>val</tt> jest typem głowy listy; jeśli tak to drukujemy,
jeśli nie to próbujemy drukować <tt>val</tt> używając ogona listy. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">void</span> print_val<span style="color: #000000;">&#40;</span>std:ostream &amp;of,boost::<span style="color: #00eeff;">any</span> val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> T::<span style="color: #00eeff;">Head</span> Head;
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> T::<span style="color: #00eeff;">Tail</span> Tail;
&nbsp;
<span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>val.<span style="color: #00eeff;">type</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000ff;">typeid</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
           of&lt;&lt;any_cast&lt;Head&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>; 
         <span style="color: #000000;">&#125;</span>
   <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>val.<span style="color: #00eeff;">type</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>==typeif<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">vector</span>&lt;Head&gt;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>
      <span style="color: #000000;">&#123;</span>
        of&lt;&lt;any_cast&lt;std::<span style="color: #00eeff;">vector</span>&lt;Head&gt; &gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>; 
      <span style="color: #000000;">&#125;</span>
      <span style="color: #0000ff;">else</span>
      print_val&lt;Tail&gt;<span style="color: #000000;">&#40;</span>of,val<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: any_print.h)
</p><p>Potrzebujemy jeszcze warunku kończącego rekurencję
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">void</span> print_val&lt;Null_type&gt;<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">ostream</span> &amp;of,boost::<span style="color: #00eeff;">any</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
of&lt;&lt;<span style="color: #666666;">&quot;don't know how to print this&quot;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>i możemy już używać naszego szablonu: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">typedef</span> 
TypeList&lt;double,
        Type_list&lt;int,
                  Type_list&lt;string,
                            Null_type&gt; &gt; &gt; my_list;
&nbsp;
print_val&lt;my_list&gt;<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span>;</pre></div>

<p>( Źródło: typelist.cpp)
</p>
<table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Is_class.cpp">Is_class.cpp</a></td><td>675 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Convertible.cpp">Convertible.cpp</a></td><td>887 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Strip.cpp">Strip.cpp</a></td><td>1.43 KB</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Promote.cpp">Promote.cpp</a></td><td>1.77 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Typelist.h">Typelist.h</a></td><td>886 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Any_print.h">Any_print.h</a></td><td>780 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Typelist.cpp">Typelist.cpp</a></td><td>656 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1243" class="section-2">
  <h1 class="book-heading">Klasy wytycznych</h1>
  <h2>Wprowadzenie</h2>
<hr />
<br />
<p>Klasy wytycznych, nazywane również klasami reguł (policy classes)
służą do parametryzowania zachowania innych klas. Rozważmy przykład
funkcji <tt>accumulate</tt>. Posiada ona również przeciążoną wersję
umożliwiającą postawienie dowolnej operacji zamiast dodawania:
</p> 

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator, <span style="color: #0000ff;">class</span> T, <span style="color: #0000ff;">class</span> BinaryFunction&gt;
T accumulate<span style="color: #000000;">&#40;</span>InputIterator first, InputIterator last, T init,
             BinaryFunction binary_op<span style="color: #000000;">&#41;</span>;</pre></div>

<p>Jedyna zmiana w implementacji klasy w stosunku do przykładu 5.2 to zmiania operacji sumowania na:
</p>

<pre>        init = binary_op(init, *first);
</pre>

<p>Pomimo, że pojawił się dodatkowy szablon klasy, to nie jest to typowa
klasa wytycznych. Zachowanie jest określone nie tyle przez ten
parametr, co przez funktor przekazany jako argument wywołania.
</p><p>Możemy jednak zmienić trochę implementację:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class Operation, <span style="color: #0000ff;">class</span> InputIterator, <span style="color: #0000ff;">class</span> T &gt;
T accumulate<span style="color: #000000;">&#40;</span>InputIterator first, InputIterator last, T init<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      <span style="color: #0000ff;">for</span> <span style="color: #000000;">&#40;</span>; first != last; ++first<span style="color: #000000;">&#41;</span>
        init = Operation::<span style="color: #00eeff;">op</span><span style="color: #000000;">&#40;</span>init,*first<span style="color: #000000;">&#41;</span>
      <span style="color: #0000ff;">return</span> init;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Takiego szablonu możemy używać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; Sumation <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">static</span> op<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;a,<span style="color: #0000ff;">const</span> T &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
         <span style="color: #0000ff;">return</span> a+b;
       <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
&nbsp;
accumulate&lt;Summation&lt;double&gt; &gt;accumulate<span style="color: #000000;">&#40;</span>first,last,<span style="color: #0000dd;">0.0</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Klasa (szablon) <tt>Summation</tt> jest właśnie klasą wytycznych.  W
zasadzie nie ma powodów aby implementować funkcję <tt>accumulate</tt> za
pomocą klas wytycznych, poza być może nadzieją na trochę bardziej
efektywny kod.
</p><p>W następnej części przedstawię bardziej realistyczny, ale i bardziej
skomplikowany przykład.
</p>

<h2>Projektowanie za pomocą klas wytycznych</h2>
<hr />
<br />

<p>Problemem w uniwersalnych bibliotekach jest duża ilość możliwych
implementacji pojedynczego komponentu. Dzieje się tak kiedy
implementując komponent możemy podjąć kilka prawie niezależnych od
siebie decyzji. Projektując kontener mamy np. do wyboru różne sposoby
alokacji pamięci i różne strategie obsługi błędów. Te zagadanienia są
w dużej mierze ortogonalne do siebie. Jeśli więc mamy trzy strategie
przydziału pamięci i trzy strategie obsługi błędu, to w sumie
dostajemy dziewięć możliwych kombinacji. Decyzja o możliwości pracy w
środowisku wielowątkowym zwiększą tę liczę dwukrotnie.
</p><p>Klasy wytycznych mogą pomóc opanować ten kombinatoryczny wzrost ilości
możliwości. Idea polega na tym, aby za każdą decyzję odpwiedzialną
zrobić jedną klasę wytyczną, przekazywaną jako parametr szablonu.  W
przytoczonym przykładzie szablon kontenera mógłby posiadać dwa
parametry wytycznych
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,
         <span style="color: #0000ff;">typename</span> Allocator_policy,
         <span style="color: #0000ff;">typename</span> Checking_policy&gt;
 Kontener;</pre></div>


<p>i potrzebowalibyśmy 6 (3 <tt>Allocator_policy</tt> i 3 <tt>Checking_policy</tt>) różnych
klas wytycznych. Sześć może się wydawać niewiele mniejsze od
dziewięciu, ale takie podejście  skaluje się liniowo z liczbą
wytycznych: dodanie nowej strategii alokacji pamięci wymaga jednej
dodatkowej klasy, a liczba kombinacji zwieksza się do 12.
W praktyce wszystkie wytyczne miałyby wartości domyślne.
</p>

<h2>Stack</h2>
<hr />
br>

<p>Pokażę teraz jak to działa w praktyce na przykładzie znanego już nam
szablonu klasy <tt>Stack</tt>, w którym na początek dokonam  drobnych zmian:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:	
 T rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
 <span style="color: #0000ff;">size_t</span> _top;
<span style="color: #0000ff;">public</span>:
 Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;<span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">void</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>              <span style="color: #000000;">&#123;</span>--_top;<span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">const</span> T&amp; top<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #0000ff;">const</span>   <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">bool</span> is_empty           <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> !_top;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span></pre></div>

<p>Zmiany polegają na rozdzieniu operacji odczytywania wierzchołka stosu
i zdejmowania elementu ze stosu. Umożliwia to między innymi
przekazywanie wartości zwracanej ze stosu przez referencje, poza tym
jest to bardziej bezpieczne. 
</p><p>Ten kod jest, delikatnie rzecz ujmując, bardzo prościutki. Możemy
rozbudowywać go w co najmniej dwu kierunkach. Po pierwsze można użyć
dynamicznej alokacji pamięci, po drugie możemy zaimplementować
sprawdzanie zakresu aby wykryć próbę włożenia elementu na pełny stos,
lub zdjęcia/odczytania elementu ze stosu pustego.  W tym przypadku
mamy różne możliwości reakcji na te błędy.
</p><p>Żeby zaimplementować sprawdzanie zakresu dodajemy nowy parametr do 
szablonu <tt>Stack</tt>, który będzie określał klasę wytyczną dla tej strategii:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>,
         <span style="color: #0000ff;">typename</span> Checking_policy = No_checking_policy &gt; 
<span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:	
  T _rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">size_t</span> _top;
<span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
    Checking_policy::<span style="color: #00eeff;">check_push</span><span style="color: #000000;">&#40;</span>_top,N<span style="color: #000000;">&#41;</span>;
    _rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">void</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>              <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_pop</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    --_top;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">const</span> T&amp; top<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #0000ff;">const</span>   <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_top</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>         <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> !_top;
  <span style="color: #000000;">&#125;</span>
&nbsp;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: stack1.h)
</p><p>Klasa 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> No_checking_policy <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> check_push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span>,<span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> check_pop<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> check_top<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: checking_policy.h)
</p><p>implementuje najprostszą strategię sprawdzania zakresu: brak
sprawdzania. Proszę zauważyć, że w tym wypadku najprawdopodobniej
żaden kod nie zostanie dodany: kompilator "wyoptymalizuje" puste
funckje. 
</p><p>Inne możliwe strategie to np. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Abort_on_error_policy <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> check_push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> top,<span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>top &gt;= size<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #666666;">&quot;trying to push elemnt on full stack: aborting&quot;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
      <span style="color: #0000dd;">abort</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #000000;">&#125;</span>
  <span style="color: #000000;">&#125;</span>;
&nbsp;
  i podobnie dla pozostałych funkcji sprawdzających
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: checking_policy.h)
</p><p>Programując w C++ wstyd by było nie użyć wyjątków:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> Std_exception_on_error_policy <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> check_push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> top,<span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>top &gt;= size<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      throw std::<span style="color: #00eeff;">range_error</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;over the top&quot;</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #000000;">&#125;</span>
  <span style="color: #000000;">&#125;</span>;
&nbsp;
  i podobnie dla pozostałych funkcji sprawdzających
&nbsp;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: checking_policy.h)
</p><p>Teraz możemy prosto konfigurować szablon <tt>Stack</tt> podając mu
odpowiednie argumenty:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;int,<span style="color: #0000dd;">10</span>&gt;                                  s_no_check;
Stack&lt;double ,<span style="color: #0000dd;">100</span>,Abort_on_error_policy&gt;       s_abort;
Stack&lt;int *,<span style="color: #0000dd;">25</span>,Std_exception_on_error_policy&gt;  s_except;</pre></div>

<p>( Źródło: policy1.cpp)
</p><p>W celu zaimplementowania różnych strategii przydziału pamięci  dodajemy
dodatkowy parametr szablonu, który sam będzie szablonem:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>,
         <span style="color: #0000ff;">typename</span> Checking_policy = No_checking_policy,  
         template&lt;typename U,<span style="color: #0000ff;">size_t</span> M&gt;  <span style="color: #0000ff;">class</span> Allocator_policy 
         = Static_table_allocator &gt; <span style="color: #0000ff;">class</span> Stack;</pre></div>

<p>Szablon typu <tt>Allocator_policy</tt> posiada jeden typ stowarzyszony i
szereg funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">0</span>&gt; <span style="color: #0000ff;">struct</span> Static_table_allocator <span style="color: #000000;">&#123;</span>
         <span style="color: #0000ff;">typedef</span> T rep_type<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
         <span style="color: #0000ff;">void</span> init<span style="color: #000000;">&#40;</span>rep_type &amp;,<span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
         <span style="color: #0000ff;">void</span> expand_if_needed<span style="color: #000000;">&#40;</span>rep_type &amp;,<span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
         <span style="color: #0000ff;">void</span> shrink_if_needed<span style="color: #000000;">&#40;</span>rep_type &amp;size_t<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
         <span style="color: #0000ff;">void</span> dealocate<span style="color: #000000;">&#40;</span>rep_type &amp;<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> N;<span style="color: #000000;">&#125;</span>;
&nbsp;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: allocator2.h)
</p><p>Szablon <tt>Stack</tt> implementujemy teraz następująco:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;...&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Allocator_policy&lt;T,N&gt;::<span style="color: #00eeff;">rep_type</span> rep_type;
  rep_type  _rep;
  <span style="color: #0000ff;">size_t</span> _top;
  Allocator_policy&lt;T,N&gt; alloc;
<span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n = N<span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    alloc.<span style="color: #00eeff;">init</span><span style="color: #000000;">&#40;</span>_rep,n<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    alloc.<span style="color: #00eeff;">expand_if_needed</span><span style="color: #000000;">&#40;</span>_rep,_top<span style="color: #000000;">&#41;</span>;
    Checking_policy::<span style="color: #00eeff;">check_push</span><span style="color: #000000;">&#40;</span>_top,alloc.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
    _rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">void</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>              <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_pop</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    --_top;
    alloc.<span style="color: #00eeff;">shrink_if_needed</span><span style="color: #000000;">&#40;</span>_rep,_top<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">const</span> T&amp; top<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #0000ff;">const</span>   <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_top</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>         <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> !_top;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  ~Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>alloc.<span style="color: #00eeff;">dealocate</span><span style="color: #000000;">&#40;</span>_rep<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
&nbsp;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: stack2.h)
</p><p>Szablon 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">size_t</span> N &gt; <span style="color: #0000ff;">struct</span> Expandable_new_allocator <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> T * rep_type;
  <span style="color: #0000ff;">size_t</span> _size;
  <span style="color: #0000ff;">void</span> init<span style="color: #000000;">&#40;</span>rep_type &amp;rep,<span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_size=n;rep = <span style="color: #0000dd;">new</span> T <span style="color: #000000;">&#91;</span>_size<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> expand_if_needed<span style="color: #000000;">&#40;</span>rep_type &amp; rep,<span style="color: #0000ff;">size_t</span> top<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>top == _size<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      _size=<span style="color: #0000dd;">2</span>*_size;
      T *tmp= <span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>_size<span style="color: #000000;">&#93;</span>;
      std::<span style="color: #00eeff;">copy</span><span style="color: #000000;">&#40;</span>rep,&amp;rep<span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span>,tmp<span style="color: #000000;">&#41;</span>;
      <span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> rep;
      rep = tmp;
    <span style="color: #000000;">&#125;</span>
  <span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> shrink_if_needed<span style="color: #000000;">&#40;</span>rep_type &amp;size_t<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> dealocate<span style="color: #000000;">&#40;</span>rep_type &amp;rep<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> rep;<span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _size;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: allocator2.h)
</p><p>definiuje strategię dynamicznego przydziału pamięci "na żądanie". 
Możemy teraz dowolnie składać nasze strategie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> n=<span style="color: #0000dd;">10</span>;
  Stack&lt;int,<span style="color: #0000dd;">0</span>,Std_exception_on_error_policy,Expandable_new_allocator &gt; s1<span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span>;
  Stack&lt;int,<span style="color: #0000dd;">10</span>,Abort_on_error_policy,Static_table_allocator &gt; s2<span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span>;</pre></div>


<p>( Źródło: policy2.cpp)
</p><p>Widać, że takie podejście jest bardzo elastyczne, użytkownik może
praktycznie dowolnie konfigurować sobie zachowanie klasy <tt>Stack</tt>,
zwłaszcza, że ma możliwość tworzenia własnych klas wytycznych.
</p><p>Oczywiście powyższy przykład nie jest do końca dopracowany. Przede
wszystkim strategie przydziału pamięci i strategie sprawdzenia zakresu
nie są całkowicie niezależne. Np. w funkcji <tt>push</tt> jeśli powiedzie
się wywołanie funkcji <tt>expand_if_needed()</tt> to nie ma potrzeby
wywoływania funkcji <tt>check_push()</tt>. Po drugie - całkowicie
pominęliśmy kwestię diagnostyki funkcji alokujących pamięć. Możliwe
rozwiązanie to przekazanie <tt>Checkin_policy</tt> jako argumentu szablonu
do <tt>allocator_policy</tt>. Można też rozważyć posiadanie dwu różnych
klas wytycznych, jednej dla obsługi błędów przekroczenia zakresu,
drugiej do obsługi błędów przydziału pamięci.
</p>

<h2>Dziedziczenie wytycznych</h2>
<hr />
<br />

<p>Stosowanie wytycznej <tt>Checking_policy</tt> sprowadzało się do używania
funkcji statycznych. W przypadku wytycznej <tt>Allocator_policy</tt>
musieliśmy utworzyć obiekt tej klasy, ponieważ niektóre implementacje
tej wytycznej posiadają stan (w tym przypadku jest to zmienna
<tt>_size</tt>). Alternatywnym sposobem użycia takiej wytycznej 
jest wykorzystanie dziedziczenia:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>,
         <span style="color: #0000ff;">typename</span> Checking_policy = No_checking_policy,  
         template&lt;typename U,<span style="color: #0000ff;">size_t</span> M&gt;  <span style="color: #0000ff;">class</span> Allocator_policy 
         = Static_table_allocator &gt; 
<span style="color: #0000ff;">class</span> Stack: <span style="color: #0000ff;">private</span> Checking_policy, <span style="color: #0000ff;">private</span> Allocator_policy&lt;T,N&gt; <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> Allocator_policy&lt;T,N&gt;::<span style="color: #00eeff;">rep_type</span> rep_type;
  rep_type  _rep;
  <span style="color: #0000ff;">size_t</span> _top;
<span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n = N<span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    init<span style="color: #000000;">&#40;</span>_rep,n<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    expand_if_needed<span style="color: #000000;">&#40;</span>_rep,_top<span style="color: #000000;">&#41;</span>;
    Checking_policy::<span style="color: #00eeff;">check_push</span><span style="color: #000000;">&#40;</span>_top,this-&gt;size<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
    _rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>              <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_pop</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    --_top;
    this-&gt;shrink_if_needed<span style="color: #000000;">&#40;</span>_rep,_top<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">const</span> T&amp; top<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #0000ff;">const</span>   <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_top</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>;
  <span style="color: #000000;">&#125;</span>  
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>         <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> !_top;
  <span style="color: #000000;">&#125;</span> 
  ~Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>this-&gt;dealocate<span style="color: #000000;">&#40;</span>_rep<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: stack3.h)
</p><p>Główna zmiana to konieczność kwalifikowania nazw niektórych funkcji
przez <tt>this-></tt> tak, aby stały się nazwami zależnymi (zob. wykład 3.7.1). 
Skorzystałem z dziedziczenia prywatnego aby zaznaczyć, że dziedziczę
implementację a nie interfejs (<tt>Stack</tt> <b>nie jest</b>
<tt>Allocator_policy</tt>). Jednak odziedziczenie również interfejsu
klasy <tt>Allocator_policy</tt> poprzez dziedziczenie publiczne może być użyteczne. Aby się o tym przekonać
rozważymy kolejną modyfikację naszego przykładu: przeniesiemy zmienną
<tt>_rep</tt> z klasy <tt>Stack</tt> do klasy wytycznej np.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">size_t</span> N &gt; <span style="color: #0000ff;">class</span> Dynamic_table_allocator <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">protected</span>:
  <span style="color: #0000ff;">typedef</span> T * rep_type;
  rep_type _rep;
  <span style="color: #0000ff;">size_t</span> _size;
  <span style="color: #0000ff;">void</span> init<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_size=n;_rep = <span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>_size<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> expand_if_needed<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> shrink_if_needed<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> dealocate<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> _rep;<span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _size;<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">void</span> resize<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      T *tmp= <span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>n<span style="color: #000000;">&#93;</span>;
      std::<span style="color: #00eeff;">copy</span><span style="color: #000000;">&#40;</span>_rep,&amp;_rep<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#40;</span>_size&lt;n<span style="color: #000000;">&#41;</span>?_size:n<span style="color: #000000;">&#93;</span>,tmp<span style="color: #000000;">&#41;</span>;
      <span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> _rep;
      _rep = tmp;
      _size=n;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: allocator3_1.h)
</p><p>Pociąga to za sobą zmiany w klasie <tt>Stack</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>,
         <span style="color: #0000ff;">typename</span> Checking_policy = No_checking_policy,  
         template&lt;typename U,<span style="color: #0000ff;">size_t</span> M&gt;  <span style="color: #0000ff;">class</span> Allocator_policy 
         = Static_table_allocator &gt; 
<span style="color: #0000ff;">class</span> Stack: <span style="color: #0000ff;">private</span> Checking_policy, <span style="color: #0000ff;">public</span> Allocator_policy&lt;T,N&gt; <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">size_t</span> _top;
&nbsp;
  <span style="color: #0000ff;">public</span>: Stack<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n = N<span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> Stack::<span style="color: #00eeff;">init</span><span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span>; <span style="color: #0000ff;">void</span>
  push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    Stack::<span style="color: #00eeff;">expand_if_needed</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>;
    Checking_policy::<span style="color: #00eeff;">check_push</span><span style="color: #000000;">&#40;</span>_top,this-&gt;size<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
    Stack::_rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">void</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_pop</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>; --_top;
    Stack::<span style="color: #00eeff;">shrink_if_needed</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>; 
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">const</span> T&amp; top<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span>
    Checking_policy::<span style="color: #00eeff;">check_top</span><span style="color: #000000;">&#40;</span>_top<span style="color: #000000;">&#41;</span>; 
    <span style="color: #0000ff;">return</span> Stack::_rep<span style="color: #000000;">&#91;</span>top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>; <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> <span style="color: #0000ff;">return</span> !_top; <span style="color: #000000;">&#125;</span>  Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    Stack::<span style="color: #00eeff;">dealocate</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: stack3_1.h)
</p><p>Zmieniłem również sposób uzależniania nazw niezależnych na
kwalifikację ich nazwą klasy <tt>Stack</tt>. Teraz możemy korzystać z
interfejsu klasu <tt>Dynamic_table_allocator</tt> w klasie <tt>Stack</tt>.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">  Stack&lt;int,n,Std_exception_on_error_policy,Dynamic_table_allocator &gt; s<span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span>;
  s.<span style="color: #00eeff;">resize</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">20</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>( Źródło: policy3_1.cpp)
</p>
<table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack1.h">Stack1.h</a></td><td>812 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Checking_policy.h">Checking_policy.h</a></td><td>1.17 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Policy1.cpp">Policy1.cpp</a></td><td>257 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Allocator2.h">Allocator2.h</a></td><td>1.25 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack2.h">Stack2.h</a></td><td>1.16 KB</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Policy2.cpp">Policy2.cpp</a></td><td>242 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack3.h">Stack3.h</a></td><td>1.11 KB</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Allocator3_1.h">Allocator3_1.h</a></td><td>1.37 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack3_1.h">Stack3_1.h</a></td><td>1.08 KB</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Policy3_1.cpp">Policy3_1.cpp</a></td><td>315 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1244" class="section-2">
  <h1 class="book-heading">Metaprogramowanie</h1>
  <h2>Metaprogramowanie</h2>
<hr />
<br />

<p>Ogólnie rzecz biorąc metaprogramowanie oznacza pisanie programów, które
piszą programy lub pisania programu, który pisze się sam. W naszym
kontekście będzie to oznaczało wykonywanie obliczeń za pomocą
szablonów, przy czym obliczenia te są wykonywane podczas kompilacji.
Podstawą do tych obliczeń jest rekurencyjna konkretyzacja szablonów.
Taką metodą można generować w czasie kompilacji całkiem skomplikowane
fragmenty kodu, stąd określenie metaprogramowanie.  Przykłady takich
"metaszablonów" poznaliśmy już na wykładzie o funkcjach typów. W
szczególności działanie na listach typów to właśnie przykłady
metaprogramowania.  W tym wykładzie przyjrzymy się dokładniej temu
zagadnieniu i przeanalizujemy kolejne przykłady.
</p>

<h2>Potęgi</h2>
<hr />
<br />
<p>Zaczniemy od bardzo prostego przykładu (zob. D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i>, rozdz. 17).
Napiszemy szablon który ma za zadanie obliczać potęgi liczby 3.
Ponieważ w programowaniu za pomocą szablonów musimy posługiwać się
rekurencją to zaczynamy od sformułowania problemu w sposób
rekurencyjny. To akurat jest bardzo proste:
</p><p>Przykład 8.1
</p>

<p><center>\(3^N=3*3^{N-1},\quad 3^0 = 1\)
</center>
</p><p><br />
Za pomocą szablonów implementujemy to tak ( Źródło: Pow.cpp):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;int  N&gt; <span style="color: #0000ff;">struct</span> Pow3 <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>val=<span style="color: #0000dd;">3</span>*Pow3&lt;N<span style="color: #0000dd;">-1</span>&gt;::<span style="color: #00eeff;">val</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
template&lt;&gt; <span style="color: #0000ff;">struct</span> Pow3&lt;<span style="color: #0000dd;">0</span>&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>val=<span style="color: #0000dd;">1</span><span style="color: #000000;">&#125;</span>; 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>teraz możemy już użyć w programie np. wyrażenie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">i=Pow3&lt;<span style="color: #0000dd;">4</span>&gt;::<span style="color: #00eeff;">val</span>;</pre></div>

<p>Podstawową zaletą metaprogramowania i głównym powodem jego używania
jest fakt, że to wyrażenie jest obliczane w czasie kompilacji i efekt
jest taki sam jak podstawienia:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">i=<span style="color: #0000dd;">81</span>;</pre></div>

<p>Można też zastosować szablon funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;int N&gt; <span style="color: #0000ff;">int</span> pow3<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #0000dd;">3</span>*pow3&lt;N<span style="color: #0000dd;">-1</span>&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;
template&lt;&gt; <span style="color: #0000ff;">int</span> pow3&lt;<span style="color: #0000dd;">0</span>&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">1</span>;<span style="color: #000000;">&#125;</span>
cout&lt;&lt;pow3&lt;<span style="color: #0000dd;">4</span>&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl;</pre></div>


<p>( Źródło: Powf.cpp)
</p><p>Nietrudno jest uogólnić powyższy kod tak aby wyliczał potęgi dowolnej
liczby:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;int K,<span style="color: #0000ff;">int</span> N&gt; <span style="color: #0000ff;">struct</span> <span style="color: #0000dd;">Pow</span> <span style="color: #000000;">&#123;</span> <span style="color: #0000ff;">enum</span> 
 <span style="color: #000000;">&#123;</span>val=K*Pow&lt;K,N<span style="color: #0000dd;">-1</span>&gt;::<span style="color: #00eeff;">val</span><span style="color: #000000;">&#125;</span>; <span style="color: #000000;">&#125;</span>;
template&lt;int K&gt; <span style="color: #0000ff;">struct</span> Pow&lt;K,<span style="color: #0000dd;">0</span>&gt; <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>val=<span style="color: #0000dd;">1</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: Pow.cpp)
</p><p>Tutaj już nie można wykorzystać szablonu funkcji, bo nie zezwala on na
specjalizację częściową.<br />
Ograniczeniem dla takich obliczeń jest implementacja kompilatora,
przede wszystkim założony limit głebokości rekurencyjnego
konkretyzowania szablonów. Dla kompilatora g++ jest on ustawiany za
pomocą opcji i defaultowo wynosi 500, dlatego już konkretyzacja <tt>Pow&lt;1,500>::val</tt> się nie powiedzie.  
Konkretyzacja szablonów wymaga też pamięci i może się zdarzyć, że
kompilator wyczerpie limit pamięci lub czasu. <br /> Kolejne ograniczenie to konieczność rachunków na liczbach całkowitych.
Wiąże się to z faktem, że tylko stałe całkowitoliczbowe mogą być
parametrami szablonów.
</p>

<h2>Ciąg Fibonacciego</h2>
<hr />
<br />

<p>Po opanowaniu powyższych przykładów obliczanie wyrazów ciągu
Fibonacciego jest prostym zadaniem. Przytoczymy je jednak tutaj, aby
zaprezentować pewną bardzo sympatyczną cechę metaprogramowania za
pomocą szablonów. Ciąg Fibonacciego jest definiowany rekurencyjnie:
</p><p>Przykład 8.2
</p>


<p><center>\(f_n=f_{n-1}+f_{n-2},\quad f_1=f_2=1\)
</center>

</p><p>więc jego implementacja jest natychmiastowa:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;int N&gt; <span style="color: #0000ff;">struct</span> Fibonacci <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>val = Fibonacci&lt;N<span style="color: #0000dd;">-1</span>&gt;::<span style="color: #00eeff;">val</span>+Fibonacci&lt;N<span style="color: #0000dd;">-2</span>&gt;::<span style="color: #00eeff;">val</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
template&lt;&gt; <span style="color: #0000ff;">struct</span> Fibonacci&lt;<span style="color: #0000dd;">1</span>&gt; <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>val = <span style="color: #0000dd;">1</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
template&lt;&gt; <span style="color: #0000ff;">struct</span> Fibonacci&lt;<span style="color: #0000dd;">2</span>&gt; <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>val = <span style="color: #0000dd;">1</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: fibonacci_template.cpp)
</p><p>Przykład ten nie wart byłby może i wspomnienia gdyby nie fakt, że
rekurencyjna implementacja ciągu Fibonacciego jest bardzo nieefektywna. 
Jeśli zaimplementujemy ją w zwykłym kodzie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> fibonacci<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>n==<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">return</span> <span style="color: #0000dd;">1</span>;
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>n==<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">return</span> <span style="color: #0000dd;">1</span>;
 <span style="color: #0000ff;">return</span> fibonacci<span style="color: #000000;">&#40;</span>n<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#41;</span>+fibonacci<span style="color: #000000;">&#40;</span>n<span style="color: #0000dd;">-2</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: fibonacci.cpp)
</p><p>to obliczanie <tt>fibonacci(45)</tt> zajmie np.na moim komputerze ok. 8
sekund.  Tymczasem szablon kompiluje sie poniżej jednej sekundy!  Skąd
taka różnica? Czyżby kompilator był bardziej wydajny niż generowany
przez niego kod? W przypadku zwykłego kodu długi czas wykonania bierze
się z ogromnej liczby wywołań funkcji <tt>fibonacci</tt>. Liczba ta rośnie
wykładniczo z <tt>n</tt> i większość czasu jest marnowana na wielokrotne
wywoływanie funkcji z tymi samymi argumentami.
</p><p>&nbsp;W przypadku użycia metaprogramu szablony konkretyzowane są tylko raz.
Więc jeśli już raz policzymy np. <tt>Fibonacci&lt;25>::val</tt> to kolejne
żądanie nie spowoduje już rozwinięcia rekurencyjnego, a tylko
podstawienie istniejącej wartości. Jak widzieliśmy zysk jest ogromny.
Takie pamiętanie wyników raz wywołanych funkcji nazywane jest też
programowaniem dynamicznym. Jedynym znanym mi językiem, który
bezpośrednio wspiera taki mechanizm jest <tt>Mathematica</tt>.
</p>

<h2>Pierwiastek kwadratowy</h2>
<hr />
<br />

<p>Rozważymy teraz trudniejszy przykład szablonu obliczającego
pierwiastek kwadratowy (zob. D. Vandervoorde, N. Josuttis: <i>"C++ Szablony, Vademecum profesjonalisty"</i>, rozd. 17), choć tak naprawdę
ten kod jest bardziej uniwersalny i, jak zobaczymy, łatwo za jego pomocą
zaimplementować inne funkcje. Ponieważ jesteśmy ograniczeni do
arytmetyki liczb całkowitych, tak naprawdę nie liczymy pierwiastka z
<tt>n</tt> ale jego przybliżenie: największą liczbę całkowitą <tt>k</tt>, taką że <tt>k*k&lt;=n</tt>. 
W tym celu zastosujemy algorytm przeszukiwania binarnego:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> <span style="color: #0000dd;">sqrt</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> n,<span style="color: #0000ff;">int</span> low, <span style="color: #0000ff;">int</span> high<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>low==high<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">return</span> low;
 <span style="color: #0000ff;">int</span> mid=<span style="color: #000000;">&#40;</span>low+high<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#41;</span>/<span style="color: #0000dd;">2</span>;
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>mid*mid &gt; n <span style="color: #000000;">&#41;</span> 
   <span style="color: #0000ff;">return</span> <span style="color: #0000dd;">sqrt</span><span style="color: #000000;">&#40;</span>n,low,mid<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#41;</span>;
 <span style="color: #0000ff;">else</span>
   <span style="color: #0000ff;">return</span> <span style="color: #0000dd;">sqrt</span><span style="color: #000000;">&#40;</span>n,mid,high<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>co już łatwo przetłumaczyć na szablon:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;int N,<span style="color: #0000ff;">int</span> L=<span style="color: #0000dd;">1</span>,<span style="color: #0000ff;">int</span> H=N&gt; <span style="color: #0000ff;">struct</span> <span style="color: #0000dd;">Sqrt</span><span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">enum</span>  <span style="color: #000000;">&#123;</span>mid=<span style="color: #000000;">&#40;</span>L+H<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#41;</span>/<span style="color: #0000dd;">2</span><span style="color: #000000;">&#125;</span>;
 <span style="color: #0000ff;">enum</span>  <span style="color: #000000;">&#123;</span>res= <span style="color: #000000;">&#40;</span>mid*mid&gt; N<span style="color: #000000;">&#41;</span>? <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>Sqrt&lt;N,L,mid<span style="color: #0000dd;">-1</span>&gt;::<span style="color: #00eeff;">res</span> :
  <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>Sqrt&lt;N,mid,H&gt;::<span style="color: #00eeff;">res</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
template&lt;int N,<span style="color: #0000ff;">int</span> L&gt; <span style="color: #0000ff;">struct</span> Sqrt&lt;N,L,L&gt; <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>res=L<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: sqrt.cpp)
</p><p>Łatwo sprawdzić, że kod ten działa poprawnie. Niestety posiada on
istotną wadę.  W trakcie konkretyzacji szablonu konkretyzowane są oba
szablony występujące w wyrażeniu warunkowym, nawet ten, który nie będzie
potem używany.  Tak więc wykonywana jest duża liczba konkretyzacji, z
których tylko ułamek jest potrzebny (zob. rysunek). Jakie to obciążenie dla
kompilatora to łatwo sprawdzić kompilując kod, w którym wywołujemy
<tt>Sqrt&lt;10000></tt>.  Ja nie doczekałem się na koniec kompilacji.
</p><p>Na szczęście istnieje rozwiązanie - należy użyć szablonu <tt>If_then_else</tt> 
(zob. wykład 6.2.1):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;int N,<span style="color: #0000ff;">int</span> L=<span style="color: #0000dd;">1</span>,<span style="color: #0000ff;">int</span> H=N&gt; <span style="color: #0000ff;">struct</span> <span style="color: #0000dd;">Sqrt</span><span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">enum</span>  <span style="color: #000000;">&#123;</span>mid=<span style="color: #000000;">&#40;</span>L+H<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#41;</span>/<span style="color: #0000dd;">2</span><span style="color: #000000;">&#125;</span>;
 <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> If_then_else&lt;
  <span style="color: #000000;">&#40;</span>mid*mid&gt; N<span style="color: #000000;">&#41;</span>,
  Sqrt&lt;N,L,mid<span style="color: #0000dd;">-1</span>&gt;,
  Sqrt&lt;N,mid,H&gt; &gt;::<span style="color: #00eeff;">Result</span> tmp;
 <span style="color: #0000ff;">enum</span>  <span style="color: #000000;">&#123;</span>res= tmp::<span style="color: #00eeff;">res</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
template&lt;int N,<span style="color: #0000ff;">int</span> L&gt; <span style="color: #0000ff;">struct</span> Sqrt&lt;N,L,L&gt; <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>res=L<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: sqrt_ifte.cpp)
</p><p>Ten kod powoduje już tylko konkretyzację rzeczywiście wymaganych
szablonów, a tych jest dużo mniej: rzędu \(O(\log N)\).  Tym razem
kompilacja wyrażenia <tt>Sqrt&lt;10000></tt> powiedzie się bez trudu.
</p>
<h2>Pow(x)</h2>
<hr />
<br />

<p>Jak dotąd używaliśmy metaprogramowania do wyliczania wartości stałych.
Teraz postaramy się wygenerować funkcje. Zacznijmy od pytania: po co?
Pomijając syndrom Mount Everestu (wchodzę na niego bo jest), to
głównym powodem jest nadzieja uzyskania bardziej wydajnego kodu.
Weźmy dalej za przykład liczenie potęgi, tym razem dowolnej liczby
zmiennoprzecinkowej:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">double</span> pow_int<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x,<span style="color: #0000ff;">int</span> n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">double</span> res=<span style="color: #0000dd;">1.0</span>;
<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;n;++i<span style="color: #000000;">&#41;</span>
 res*=x;
<span style="color: #0000ff;">return</span> res;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: powx.cpp)
</p><p>Patrząc na ten kod widzimy, że w pętli wykonywana jest bardzo prosta
instrukcja. Możemy więc się obawiać, że instrukcje związane z obsługą
pętli mogą stanowić spory narzut. 
Co więcej, ich obecność utrudnia kompilatorowi optymalizację kodu oraz   
może uniemożliwić rozwinięcie funkcji w miejscu wywołania. 
Najlepiej by było zaimplementować tę funkcję w ten sposób:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000dd;">pow</span><span style="color: #000000;">&#40;</span>x,n<span style="color: #000000;">&#41;</span>= x*...<span style="color: #00eeff;">*x</span>; <span style="color: #ff0000; font-style: italic;">/*n razy*/</span></pre></div>

<p>np.: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">double</span> pow2<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> x*x;<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">double</span> pow3<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> x*x*x;<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">double</span> pow4<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> x*x*x*x;<span style="color: #000000;">&#125;</span>
...</pre></div>


<p>Wymaga to jednak kodowania ręcznego dla każdej potęgi, której
potrzebujemy.  Ten sam efekt możemy osiągnąc za pomocą następującego
szablonu funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;int N&gt; <span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">double</span> <span style="color: #0000dd;">pow</span><span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> x*pow&lt;N<span style="color: #0000dd;">-1</span>&gt;<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
template&lt;&gt;  <span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">double</span> pow&lt;<span style="color: #0000dd;">0</span>&gt;<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">1.0</span>;<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: powx.cpp)
</p><p>pod warunkiem, że kompilator rozwinie wszystkie wywołania.
</p><p>Poniżej zamieszczam wyniki pomiarów wykonania 100 milionów wywołań
każdej funkcji ( Źródło: powx.cpp). Czas jest
podany w sekundach. Zamieściłem wyniki dla różnych ustawień
optymalizacji.
</p>

<div align="center">
<table border="1">

<tr>
<td>
</td><td> pow_int(x,5)
</td><td>  pow&lt;5>(x)
</td></tr>
<tr>
<td align="center">-O0
</td><td align="center">  7.22
</td><td align="center">  14.78
</td></tr>
<tr>
<td align="center">-O1
</td><td align="center">  0.37
</td><td align="center">  0.04
</td></tr>
<tr>
<td align="center">-O2
</td><td align="center">  0.42
</td><td align="center">  0.05
</td></tr>
<tr>
<td align="center">-O3
</td><td align="center">  0.42
</td><td align="center">  0.05
</td></tr></table>
</div>

<p>Widać dramatyczną różnicę po włączeniu optymalizacji. Wiąże się to
prawdopodobnie z umożliwieniem rozwijania funkcji <tt>inline</tt>.  Potem
wyniki już się nie zmieniają ale widać, że szablon <tt>pow</tt> wygenerował
funkcję 10 razy szybszą od pozostałych. Pokazuje to dobitnie, że
optymalizacja ręczna ciągle ma sens.
</p>

<h2>Sortowanie bąbelkowe</h2>
<hr />
<br />

<p>Zakończymy ten wykład bardziej skomplikowanym przykładem pokazującym,
że metaprogramowanie można stosować nie tylko do obliczeń
numerycznych. Popatrzmy na kod implementujący sortowanie bąbelkowe:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">void</span> swap <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> &amp;a,<span style="color: #0000ff;">int</span> &amp;b<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">int</span>       tmp=a;a=b;b=tmp;<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">void</span> bubble_sort_function <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span>* data, <span style="color: #0000ff;">int</span> N<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i = N<span style="color: #0000dd;">-1</span>; i&gt;<span style="color: #0000dd;">0</span>; --i<span style="color: #000000;">&#41;</span>
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> j=<span style="color: #0000dd;">0</span>;j&lt;i;++j<span style="color: #000000;">&#41;</span>
   <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>j<span style="color: #000000;">&#93;</span>&gt;data<span style="color: #000000;">&#91;</span>j<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span> 
    swap<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>j<span style="color: #000000;">&#93;</span>,data<span style="color: #000000;">&#91;</span>j<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: bubble_template.cpp)
</p><p>Znów widzimy tu dwie pętle i wszystkie uwagi dotyczące funkcji
<tt>pow_int</tt> tu też się stosują. Postaramy się więc zdefiniować szablon, 
który dokona rozwinięcia tych obu pętli. Np. dla <tt>N=3</tt> chcielibyśmy otrzymać następujący kod:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #ff0000;">//i=2 j=0</span>
<span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>&gt;data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span> swap<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>,data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #ff0000;">//i=2 j=1</span>
<span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span>&gt;data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span> swap<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span>,data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #ff0000;">//i=1 j=0</span>
<span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>&gt;data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span> swap<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>,data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>Jeśli Państwo śledzili wykład (przynajmniej ten), to już Państwo wiedzą, że
pierwszym krokiem musi być przepisanie kodu sortowania na postać rekurencyjną:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> bubble_sort_function <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span>* data, <span style="color: #0000ff;">int</span> N<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> j=<span style="color: #0000dd;">0</span>;j&lt;N<span style="color: #0000dd;">-1</span>;++j<span style="color: #000000;">&#41;</span>
  <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>j<span style="color: #000000;">&#93;</span>&gt;data<span style="color: #000000;">&#91;</span>j<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span> 
   swap<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>j<span style="color: #000000;">&#93;</span>,data<span style="color: #000000;">&#91;</span>j<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>N&gt;<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>
  bubble_sort_function<span style="color: #000000;">&#40;</span>data,N<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>



<p>To jeszcze nie to co trzeba, bo musimy zapisać pętle w postaci
rekurencyjnej. Jeśli oznaczymy sobie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> loop<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> * data,<span style="color: #0000ff;">int</span> N<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> j=<span style="color: #0000dd;">0</span>;j&lt;N<span style="color: #0000dd;">-1</span>;++j<span style="color: #000000;">&#41;</span>
  <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>j<span style="color: #000000;">&#93;</span>&gt;data<span style="color: #000000;">&#91;</span>j<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>
   swap<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span>j<span style="color: #000000;">&#93;</span>,data<span style="color: #000000;">&#91;</span>j<span style="color: #0000dd;">+1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>to łatwo zauważyć, że <tt>loop</tt> można zdefiniować następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">loop<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> *data,<span style="color: #0000ff;">int</span> N<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>N&gt;<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>&gt;data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span> swap<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>,data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;
  loop<span style="color: #000000;">&#40;</span>++data,N<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#41;</span>;
 <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>


<p>co natychmiast tłumaczy się na szablony:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;int N&gt; <span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">void</span> loop<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> *data<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>&gt;data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span> std::<span style="color: #00eeff;">swap</span><span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>,data<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;
 loop&lt;N<span style="color: #0000dd;">-1</span>&gt;<span style="color: #000000;">&#40;</span>++data<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>
template&lt;&gt; <span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">void</span> loop&lt;<span style="color: #0000dd;">0</span>&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> *data<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>


<p>Szablon funkcji <tt>bubble_sort_template</tt> ma więc postać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;int N&gt;  <span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">void</span> bubble_sort_template<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> * data<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 loop&lt;N<span style="color: #0000dd;">-1</span>&gt;<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#41;</span>;
 bubble_sort_template&lt;N<span style="color: #0000dd;">-1</span>&gt;<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>
template&lt;&gt;  <span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">void</span> bubble_sort_template&lt;<span style="color: #0000dd;">2</span>&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> * data<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 loop&lt;<span style="color: #0000dd;">1</span>&gt;<span style="color: #000000;">&#40;</span>data<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>



<p>( Źródło: bubble_template.cpp)
</p><p>Poniżej znów podaję porównanie czasu wykonywania się 100 milionów 
wywołań funkcji <tt>bubble_sort_function</tt> i <tt>bubble_sort_template</tt> dla tablicy zawierającej 12 liczb całkowitych w kolejności malejącej.  
</p>
<div align="center">
<table border="1">

<tr>
<th>
</th><td> bubblesortfunction(a,12)
</td><td> bubblesorttemplate&lt;12>(a)
</td></tr>
<tr>
<td align="center">-O0
</td><td align="center">43.3
</td><td align="center">42.2
</td></tr>
<tr>
<td align="center">-O1
</td><td align="center">21.0
</td><td align="center">4.8
</td></tr>
<tr>
<td align="center">-O2
</td><td align="center">20.0
</td><td align="center">3.5
</td></tr>
<tr>
<td align="center">-O3
</td><td align="center">20.0
</td><td align="center">3.6
</td></tr></table>
</div>
<p>Widać, że wersja na szablonach jest ok. 4-5 razy szybsza. Zachęcam do
własnych eksperymentów.<br />
Zaprojektowany szablon działa tylko dla tablic liczb całkowitych. Jest
to ewidentne ograniczenie, które powinniśmy zlikwidować poprzez dodanie
doatkowego parametru szablonu. Niestety, prowadzi to do konieczności
dokonania specjalizacji częściowej, która nie jest dozwolona dla
szablonów funkcji. Na szczeście nie jest trudno przepisać naszą
implementację używając szablonów klas. Pozostawiam to jako ćwiczenie
dla czytelników&nbsp;:).
</p>

<h2>Rozmiar kodu</h2>
<hr />
<br />

<p>Jak pokazałem, kod generowany przez szablon <tt>bubble_sort_template</tt> jest
bardziej efektywny. Dzieje się to jednak kosztem jego rozmiaru. Są ku
temu dwa powody. Po pierwsze podwójna pętla wewnątrz procedury
<tt>bubble_sort_function</tt> wykonuje \((N-1)*(N-2)/2\) iteracji i tyle
linijek powinien mieć w pełni rozwinięty kod w szablonie
<tt>bubble_sort_template</tt>. Po drugie każda instancja szablonu jest
osobną funkcją, stąd <tt>bubble_sort_template&lt;50></tt> i
<tt>bubble_sort_template&lt;51></tt> generują osobny kod każda. W celu
sprawdzenia tych przewidywań przedstawiam poniżej rozmiar wynikowego
kodu w bajtach dla programu, który kompilował funkcję
<tt>bubble_sort_template<N></n></tt>.
</p>
<div align="center">
<table border="1">

<tr>
<td align="center">N
</td><td align="center">size
</td></tr>
<tr>
<td align="center">10
</td><td align="center">9333
</td></tr>
<tr>
<td align="center">30
</td><td align="center">17846
</td></tr>
<tr>
<td align="center">50
</td><td align="center">21847
</td></tr>
<tr>
<td align="center">70
</td><td align="center">40399
</td></tr>
<tr>
<td align="center">90
</td><td align="center">33296
</td></tr>
<tr>
<td align="center">100
</td><td align="center">53606
</td></tr></table>
</div>
<p>Widać, że choć rozmiar w zasadzie rośnie z \(N\), to ta zależność nie jest
nawet monotoniczna. Wynika to pewnie z tego, że dla większych \(N\)
kompilator nie dokonuje całkowitego rozwiniecią kodu.
</p>
<table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Powf.cpp">Powf.cpp</a></td><td>184 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Pow.cpp">Pow.cpp</a></td><td>412 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Fibonacci_template.cpp">Fibonacci_template.cpp</a></td><td>315 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Fibonacci.cpp">Fibonacci.cpp</a></td><td>211 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sqrt.cpp">Sqrt.cpp</a></td><td>821 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sqrt_ifte.cpp">Sqrt_ifte.cpp</a></td><td>1.04 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Powx.cpp">Powx.cpp</a></td><td>1.21 KB</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Bubble_template.cpp">Bubble_template.cpp</a></td><td>1.86 KB</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1245" class="section-2">
  <h1 class="book-heading">Szablony wyrażeń</h1>
  <h2>Wprowadzenie</h2>
<hr />
<br />

<p>Rozważmy implementację funkcji całkującej inne funkcje:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">double</span> integrate<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> <span style="color: #000000;">&#40;</span>*f<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> <span style="color: #000000;">&#41;</span>,<span style="color: #0000ff;">double</span>  min,<span style="color: #0000ff;">double</span> max,<span style="color: #0000ff;">double</span> ds<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">double</span> integral=.<span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x=min;x&lt;max;x+=ds<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    integral+=f<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">return</span> integral*ds;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: integrate.cpp)
</p><p>Pomijając prostotę zaimplementowanego algorytmu numerycznego, możemy
jej używać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">cout</span>&lt;&lt;  ::<span style="color: #00eeff;">integrate</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sin</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">3.1415926</span>,<span style="color: #0000dd;">0.01</span><span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;</pre></div>

<p>Jest to standardowy sposób implementowania takich zagadnień w C czy w
Fortranie.  W C++ szablony dają nam większe możliwości. Funkcja
<tt>integrate</tt> przyjmuje jako swój pierwszy argument wskaźnik do
jednoargumentowej funkcji zwracającej <tt>double</tt>, ale to co jest
naprawdę istotne to to, że można użyć w stosunku do niego notacji
wywołania funkcji: <tt>f(x)</tt>.  W C++ możemy wyposażyć w tę możliwość
każdą klasę poprzez zdefiniowanie w niej metody <tt>operator()</tt>.  Jeśli
zdefiniujemy funkcję <tt>integrate</tt> jako szablon, to  będziemy mieli
możliwość przekazywania również takich obiektów nazywanych
obiektami funkcyjnymi lub funktorami.
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename  F&gt; <span style="color: #0000ff;">double</span> integrate<span style="color: #000000;">&#40;</span>F f,<span style="color: #0000ff;">double</span>  min,<span style="color: #0000ff;">double</span> max,<span style="color: #0000ff;">double</span> ds<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">double</span> integral=.<span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x=min;x&lt;max;x+=ds<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    integral+=f<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">return</span> integral*ds;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: integrate_temp.cpp)
</p><p>Wywołanie 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">cout</span>&lt;&lt;  ::<span style="color: #00eeff;">integrate</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sin</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">3.1415926</span>,<span style="color: #0000dd;">0.01</span><span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;</pre></div>

<p>dalej zadziała, ale można używać również:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> sina <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">double</span> _a;
<span style="color: #0000ff;">public</span>:
  sina<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> a<span style="color: #000000;">&#41;</span>: _a<span style="color: #000000;">&#40;</span>a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">sin</span><span style="color: #000000;">&#40;</span>_a*x<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
  std::<span style="color: #00eeff;">cout</span>&lt;&lt;  ::<span style="color: #00eeff;">integrate</span><span style="color: #000000;">&#40;</span>sina<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">3.1415926</span>,<span style="color: #0000dd;">0.01</span><span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
  std::<span style="color: #00eeff;">cout</span>&lt;&lt;  ::<span style="color: #00eeff;">integrate</span><span style="color: #000000;">&#40;</span>sina<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">3.1415926</span>,<span style="color: #0000dd;">0.01</span><span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
  std::<span style="color: #00eeff;">cout</span>&lt;&lt;  ::<span style="color: #00eeff;">integrate</span><span style="color: #000000;">&#40;</span>sina<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">3.1415926</span>,<span style="color: #0000dd;">0.01</span><span style="color: #000000;">&#41;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;</pre></div>


<p>( Źródło: integrate_temp.cpp)
</p><p>Widać tu już pierwszą zaletę funktorów: jako obiekty mogą one posiadać
stan. W przypadku funkcji do takich celów musielibyśmy używać
zmiennych globalnych. Ale żeby móc funktora używać musimy go najpierw
zdefiniować. Pytanie na które bedę się starał odpowiedzieć na tym
wykładzie brzmi: czy możemy definicję funktora uprościć? Np. czy nie
moglibyśmy pisać
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">integrate<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sin</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span>*x<span style="color: #000000;">&#41;</span>,...<span style="color: #000000;">&#41;</span></pre></div>


<p>lub 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">integrate<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>/<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>+x<span style="color: #000000;">&#41;</span>,...<span style="color: #000000;">&#41;</span></pre></div>

<p>Okazuje się, że można i technika, która to umożliwia, nosi nazwę
"szablonów wyrażeń". Z pozoru wydaje się to być tylko ciekawostką,
ale w następnej części tego wykładu pokażemy jak za pomocą tej
techniki można istotnie przyspieszyć program.
</p><p><br />
Naszym celem jest napisane kodu, który będzie generował funktory
automatycznie z "normalnych" wyrażeń typu \(\displaystyle 1/(1+x)\) i umożliwi pisanie wyrażeń  w rodzaju:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">integrate<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>/<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>+x<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">0.01</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>\(\displaystyle x\) oznacza tu zmienną, po której całkujemy. Oznacza to, że kompilator musi wyrażenie \(\displaystyle 1/(1+x)\) przekształcić na funktor
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> _some_functor_ <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
<span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#123;</span><span style="color: #0000dd;">1</span>/<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>+x<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>


<h3>Zmienne</h3>
<hr />


<p>Chińczycy mówią, że podróż stumilową zaczyna się od pierwszego kroku.
Zróbmy więc pierwszy krok i spróbujmy doprowadzić do prawidłowej
kompilacji i wykonania wyrażenie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">integrate<span style="color: #000000;">&#40;</span>x,...<span style="color: #000000;">&#41;</span>;</pre></div>


<p>Żeby to działało prawidłowo, <tt>x</tt> musi być funktorem który zwraca
własny argument:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Variable <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> x;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: expr_templates.h)
</p><p>Możemy więc już wykonać całkę  \(\displaystyle \int_0^1x\;\) d \(\displaystyle  x\)
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Variable x;
integrate<span style="color: #000000;">&#40;</span>x,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">0.001</span><span style="color: #000000;">&#41;</span>;</pre></div>



<p>co nie jest jakimś porywającym wyczynem:). 
Żeby się posunąć dalej potrzebujemy kolejnych elementów.
</p>

<h3>Stałe</h3>
<br />

<p>Ewidentnie potrzebujemy stałych (literałów). Stała to funktor, który
zwraca wartość niezależną od swojego argumentu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Constant <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">double</span> _c;
<span style="color: #0000ff;">public</span>:
  Constant<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> c<span style="color: #000000;">&#41;</span> :_c<span style="color: #000000;">&#40;</span>c<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _c;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: expr_templates.h)
</p><p>Niestety literałów nie możemy używać bezpośrednio w naszym wyrażeniu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">integrate<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">0.001</span><span style="color: #000000;">&#41;</span>;</pre></div>


<p>nie zadziała. Musimy pisać
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">integrate<span style="color: #000000;">&#40;</span>Constant<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">0</span>,<span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">0.001</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Można by wprawdzie przeładować definicje <tt>integrate</tt> dla argumentów typu
<tt>double</tt> ale chyba nie warto, zważywszy na to, że całkowanie stałej
nie jest zbyt kłopotliwe. 
</p><p>Następnym krokiem będzie dodanie wyrażeń arytmetycznych.
</p>

<h3>Dodawanie</h3>
<br />

<p>Zaczniemy od dodawania. Potrzebne będą dwa elementy: klasa funktor, która
symbolizuje dodawanie oraz odpowiednio zdefiniowany operator dodawania.
</p><p>Funktor symbolizujący dodawanie musi mieć dwie składowe odpowiadające
dwu składnikom tej operacji. Przypominamy, że każdy z tych składników
też jest funktorem, a więc posiada jednoargmentowy <tt>operator()(double)</tt>.  Operacja dodawania polegać więc bedzie na dodaniu wyników obu funktorów składowych:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename LHS,<span style="color: #0000ff;">typename</span> RHS &gt; <span style="color: #0000ff;">class</span> AddExpr <span style="color: #000000;">&#123;</span>
  LHS _lhs;
  RHS _rhs;
<span style="color: #0000ff;">public</span>:
  AddExpr<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> LHS &amp;l,<span style="color: #0000ff;">const</span> RHS &amp;r<span style="color: #000000;">&#41;</span> :_lhs<span style="color: #000000;">&#40;</span>l<span style="color: #000000;">&#41;</span>,_rhs<span style="color: #000000;">&#40;</span>r<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> _lhs<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>+_rhs<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: expr_templates.h)
</p><p>Pozostaje nam tylko zdefiniować operator dodawania, który z dwu składników 
utworzy nam obiekt typu <tt>AddExpr</tt>. Ponieważ możemy dodawać cokolwiek, to 
operator dodawania będzie szablonem:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename LHS,<span style="color: #0000ff;">typename</span> RHS &gt; 
Add&lt;LHS,RHS&gt;  operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> LHS &amp;l,
                        <span style="color: #0000ff;">const</span> RHS &amp;r<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> Add&lt;LHS,RHS&gt;<span style="color: #000000;">&#40;</span>l,r<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: expr_templates.h)
</p><p>Żeby móc dodawać stałe potrzebujemy jeszcze specjalizacji szablonu dla
przypadku, w którym jeden z argumentów jest typu <tt>double</tt>):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename LHS &gt; 
Add&lt;LHS,Constant&gt;  operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> LHS &amp;l,
                        <span style="color: #0000ff;">double</span> r<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> Add&lt;LHS,Constant&gt;<span style="color: #000000;">&#40;</span>l,Constant<span style="color: #000000;">&#40;</span>r<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;
template&lt;typename RHS &gt; 
Add&lt;Constant,RHS&gt;  operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> l,
                        <span style="color: #0000ff;">const</span> RHS &amp;r<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">return</span> Add&lt;Constant,RHS&gt;<span style="color: #000000;">&#40;</span>Constant<span style="color: #000000;">&#40;</span>l<span style="color: #000000;">&#41;</span>,r<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: expr_templates.h)
</p><p>Widać, że w identyczny sposób możemy zaimplementować pozostałe trzy
działania.  Odpowiadające im klasy nazwiemy odpowiednio <tt>SubsExpr</tt>,
<tt>MultExpr</tt> i <tt>DivExpr</tt> (pominąłem jednoargumentowy
<tt>operator-()</tt>). Ich kod można zaobaczyć w  Źródło: expr_templates.h.
</p>

<h3>Funkcje</h3>
<br />

<p>Analogicznie implementujemy funkcje np.: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename Arg&gt; <span style="color: #0000ff;">class</span> SinExpr<span style="color: #000000;">&#123;</span> 
  Arg _arg;
<span style="color: #0000ff;">public</span>:
  SinExpr<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Arg&amp; arg<span style="color: #000000;">&#41;</span> :_arg<span style="color: #000000;">&#40;</span>arg<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">sin</span><span style="color: #000000;">&#40;</span>_arg<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
template&lt;typename Arg&gt; SinExpr&lt;Arg&gt; <span style="color: #0000dd;">sin</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Arg&amp;a<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> SinExpr&lt;Arg&gt;<span style="color: #000000;">&#40;</span>a<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span></pre></div>


<p>i operatory unarne (jednoargumentowe), takie jak operator negacji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename LHS&gt; <span style="color: #0000ff;">class</span> NegativeExpr <span style="color: #000000;">&#123;</span>
  LHS _lhs;
<span style="color: #0000ff;">public</span>:
  NegativeExpr<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> LHS &amp;l<span style="color: #000000;">&#41;</span> :_lhs<span style="color: #000000;">&#40;</span>l<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> - _lhs<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>; 
template&lt;typename LHS&gt; 
NegativeExpr&lt;LHS&gt;  operator-<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> LHS &amp;l<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> NegativeExpr&lt;LHS&gt;<span style="color: #000000;">&#40;</span>l<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: expr_templates.h)
</p>

<h3>Jak to działa?</h3>
<br />

<p>Mam nadzieję, że zasada działania szablonów wyrażeń jest już jasna, ale
prześledźmy jeszcze raz przykład wyrażenia:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">\Variable x;
<span style="color: #0000dd;">1.0</span>/<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>+x<span style="color: #000000;">&#41;</span></pre></div>

<p>Kompilator dokonuje rozkładu gramatycznego i interpretuje to wyrażenia jako:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">operator/<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,operator+<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,x<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span></pre></div>

<p>Wiedząc, że <tt>x</tt> jest typu <tt>Variable</tt>, kompilator stara się znaleźć
odpowiednie szablony operatorów. Najpierw dopasuje wewnętrzny
<tt>operator+<Variable>(double, Variable)</variable></tt>
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">operator/<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span>,operator+&lt;Variable&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> <span style="color: #0000dd;">1.0</span> , Variable x<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span></pre></div>


<p>a potem wiedząć, że typ zwracany przez ten operator  
to <tt>AddExpr<Constant,Variable></constant,variable></tt>, skonkretyzuje odpowiedni 
szablon operatora dzielenia:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">operator/&lt;AddExpr&lt;Constant,Variable&gt; &gt;
         <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> <span style="color: #0000dd;">1.0</span>,
          AddExpr&lt;Constant,Variable&gt; 
          operator+&lt;Variable&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> <span style="color: #0000dd;">1.0</span> , 
                               Variable x<span style="color: #000000;">&#41;</span>
<span style="color: #000000;">&#41;</span></pre></div>


<p>Po zastąpieniu skonkretyzowanych operatorów ich definicjami powstanie kod,
który generuje tymczasowy obiekt:
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-9-1.png" alt="Rysunek 9.1. Funktor wygenerowany z wyrażenia ." title="Rysunek 9.1. Funktor wygenerowany z wyrażenia ."  class="image image-_original " width="350" height="246" /><span class="caption"><strong>Rysunek 9.1. Funktor wygenerowany z wyrażenia .</strong></span></span>

<div class="geshifilter"><pre class="geshifilter-cpp">expr=DivExpression&lt;Constant,
AddExpr&lt;Constant,Variable&gt; &gt;<span style="color: #000000;">&#40;</span>Constant<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>,
AddExpr&lt;Constant,Variable&gt;<span style="color: #000000;">&#40;</span>Constant<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>,Variable<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;</pre></div>

<p>Przedstawienie tego obiektu zamieszczone jest na rysunku 9.1.
</p><p>Widać, że obiekt <tt>expr</tt> reprezentuje drzewo rozkładu wyrażenia
\(\displaystyle 1.0/(1.0+x)\). Wywołanie operatora nawiasów spowoduje rekurencyjne wywoływanie operatorów nawiasów wyrażeń składowych i w konsekwencji
obliczenie tego wyrażenia.
</p><p>Proszę zwrócić uwagę, że opisana technika szablonów wyrażeń składa się
z dwóch części. Pierwsza to klasy reprezentujące wyrażenia:
<tt>Constant,Variable,AddExpr</tt>, itd., za pomocą których budujemy
drzewo rozkładu gramatycznego.  Druga - to przeciążone operatory i
funkcje, które to drzewo generują.
</p>

<h2>Zmienne różnych typów</h2>
<hr />
<br />

<p>W przedstawionym przykładzie ograniczyliśmy się do wyrażeń typu
<tt>double</tt>. W duchu programowania uogólnionego postaramy się zmienić
nasz kod tak, aby można było wybierać typ wyrażenia poprzez parametr
szablonu.
</p><p>Okazuje się to jednak nie tak proste. Łatwo jest dodać dodatkowy
parametr do klas reprezentujących wyrażenia:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> Variable <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  T operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>T x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
     <span style="color: #0000ff;">return</span> x;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
template&lt;typename T&gt; <span style="color: #0000ff;">class</span> Constant <span style="color: #000000;">&#123;</span>
  T _c;
<span style="color: #0000ff;">public</span>:
  Constant<span style="color: #000000;">&#40;</span>T c<span style="color: #000000;">&#41;</span> :_c<span style="color: #000000;">&#40;</span>c<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  T operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>T x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _c;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
template&lt;typename T, <span style="color: #0000ff;">typename</span> LHS,<span style="color: #0000ff;">typename</span> RHS &gt; <span style="color: #0000ff;">class</span> AddExpr <span style="color: #000000;">&#123;</span>
  LHS _lhs;
  RHS _rhs;
<span style="color: #0000ff;">public</span>:
  AddExpr<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> LHS &amp;l,<span style="color: #0000ff;">const</span> RHS &amp;r<span style="color: #000000;">&#41;</span> :_lhs<span style="color: #000000;">&#40;</span>l<span style="color: #000000;">&#41;</span>,_rhs<span style="color: #000000;">&#40;</span>r<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  T operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>T x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> _lhs<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>+_rhs<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>ale niestety operatory arytmetyczne nie będą miały jak automatycznie
wydedukować typu <tt>T</tt>. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> LHS,<span style="color: #0000ff;">typename</span> RHS &gt; 
Add&lt;T,LHS,RHS&gt;  operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> LHS &amp;l,
                        <span style="color: #0000ff;">const</span> RHS &amp;r<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> Add&lt;T,LHS,RHS&gt;<span style="color: #000000;">&#40;</span>l,r<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Typ <tt>T</tt> nie pojawia się w argumentach wywołania, a więc nie może być
wydedukowany. Mamy więć kłopot.
</p><p>Rozwiązaniem może być dodanie dodatkowej klasy <tt>Expr</tt> "opakowującej"
wyrażenia, która będzie przenosiła informację o typie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> R = Variable&lt;T&gt; &gt; <span style="color: #0000ff;">class</span> Expr <span style="color: #000000;">&#123;</span>
  R _rep;
 <span style="color: #0000ff;">public</span>:
  Expr<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  Expr<span style="color: #000000;">&#40;</span>R rep<span style="color: #000000;">&#41;</span>:_rep<span style="color: #000000;">&#40;</span>rep<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  T operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>T x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
  R rep<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _rep;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: expr_templates_T.h)
</p><p>Odpowiednie operatory dodawania będą teraz wyglądały następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> LHS,<span style="color: #0000ff;">typename</span> RHS &gt; 
Expr&lt;T,AddExpr&lt;T,LHS,RHS&gt; &gt;  operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Expr&lt;T,LHS&gt; &amp;l,
                        <span style="color: #0000ff;">const</span> Expr&lt;T,RHS&gt; &amp;r<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> Expr&lt;T,AddExpr&lt;T,LHS,RHS&gt; &gt;<span style="color: #000000;">&#40;</span>AddExpr&lt;T,LHS,RHS&gt;<span style="color: #000000;">&#40;</span>l.<span style="color: #00eeff;">rep</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,r.<span style="color: #00eeff;">rep</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;
&nbsp;
template&lt;typename T,<span style="color: #0000ff;">typename</span> LHS &gt; 
Expr&lt;T,AddExpr&lt;T,LHS,Constant&lt;T&gt; &gt; &gt;   
operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Expr&lt;T,LHS&gt;  &amp;l,
                        T r<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">return</span> Expr&lt;T,AddExpr&lt;T,LHS,Constant&lt;T&gt; &gt; &gt;
       <span style="color: #000000;">&#40;</span>AddExpr&lt;T,LHS,Constant&lt;T&gt; &gt;<span style="color: #000000;">&#40;</span>l.<span style="color: #00eeff;">rep</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,Constant&lt;T&gt;<span style="color: #000000;">&#40;</span>r<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Ponieważ teraz typ <tt>T</tt> pojawia się w argumentach wywołania, jest
możliwa jego dedukcja. Pełna implementacja wszystkich operatorów znajduje się 
w  Źródło: expr_templates_T.h. 
</p><p>W porównaniu z poprzednią implementacją jedyna zmiana to taka, że
zmienne musimy teraz deklarować jako:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Expr&lt;double&gt; x;</pre></div>

<p>lub równoważnie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Expr&lt;double,Variable&lt;double&gt; &gt; x;</pre></div>

<p>Teraz możemy również definiować zmienne innych typów:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Expr&lt;complex&lt;double&gt; &gt; z;
Expr&lt;int&gt; i;</pre></div>

<p>Niestety, to ciągle nie jest koniec naszych kłopotów, nie możemy bowiem
mieszać wyrażeń różnych typów. Jeśli np. zdefiniujemy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Expr&lt;double&gt; x;
<span style="color: #0000ff;">int</span> i;</pre></div>

<p>to wyrażenia 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">x<span style="color: #0000dd;">+1</span>;
x+i;</pre></div>

<p>nieskompilują się.  Oczywiście możemy pisać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">x<span style="color: #0000dd;">+1.0</span>;
x+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>i;</pre></div>

<p>ale jest to niewygodne; zwłaszcza jeśli będziemy chcieli użyć zmiennych
zespolonych
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Expr&lt;std::<span style="color: #00eeff;">complex</span>&lt;double&gt; &gt; c;
<span style="color: #0000ff;">double</span> x;
std::<span style="color: #00eeff;">complex</span>&lt;double&gt;<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>+c</pre></div>

<p>wydaje się trochę skomplikowane. Można jednak, używając cech promocji,
tak zmodyfikować nasz kod, aby potrafił automatycznie konwertować typy.
Jest to przedmiotem jednego z ćwiczeń do tego wykładu.
</p>

<h2>Więcej zmiennych</h2>
<hr />
<br />

<p>Jak na razie generowaliśmy funktory jednoargumentowe. Powyższa
technika daje się łatwo zastosować również do funktorów dwuargumentowych. 
W tym celu musimy mieć możność rozróżnienia pierwszego i drugiego argumentu.
Dlatego wprawadzamy dwie klasy, które zastąpią klasę <tt>Variable</tt>. Klasa
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> First <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> x;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x,<span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> x;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>reprezentuje pierwszy argument i może występować w funktorach jedno- lub
dwuargumentowych, więc ma dwa operatory nawiasów. Klasa
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Second <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span>,<span style="color: #0000ff;">double</span> y<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> y;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>reprezentuje drugi argument funktora, więc może występować tylko jako
funkcja dwuargumentowa, stąd tylko jeden dwuargumentowy operator
nawiasów. Podobnie klasa
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Constant <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">double</span> _c;
<span style="color: #0000ff;">public</span>:
  Constant<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> c<span style="color: #000000;">&#41;</span> :_c<span style="color: #000000;">&#40;</span>c<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _c;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span>,<span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _c;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>dorobiła się drugiego operatora nawiasów.
Ostatnia zmiana to dodanie dwuargumentowego operatora nawiasów dla klasy
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename LHS,<span style="color: #0000ff;">typename</span> RHS &gt; <span style="color: #0000ff;">class</span> AddExpr <span style="color: #000000;">&#123;</span>
  LHS _lhs;
  RHS _rhs;
<span style="color: #0000ff;">public</span>:
  AddExpr<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> LHS &amp;l,<span style="color: #0000ff;">const</span> RHS &amp;r<span style="color: #000000;">&#41;</span> :_lhs<span style="color: #000000;">&#40;</span>l<span style="color: #000000;">&#41;</span>,_rhs<span style="color: #000000;">&#40;</span>r<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> _lhs<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>+_rhs<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x,<span style="color: #0000ff;">double</span> y<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> _lhs<span style="color: #000000;">&#40;</span>x,y<span style="color: #000000;">&#41;</span>+_rhs<span style="color: #000000;">&#40;</span>x,y<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>I podobnie dla reszty działań. Operatory pozostają bez zmian.
</p>

<h2>Biblioteka lambda</h2>
<hr />
<br />

<p>Jako przykład  zastosowania opisanych (lub podobnych) technik może
służyć biblioteka <tt>lambda</tt> z
repozytorium <tt>boost</tt>. Korzystając z tej biblioteki możemy używać
predefiniowanych zmiennych <tt>_1</tt>, <tt>_2</tt> i <tt>_3</tt>, które oznaczają
odpowiednio pierwszy, drugi i trzeci argument. Korzystając z nich
możemy przyklad z wykładu 2.6.3 zapisać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">generate_n</span><span style="color: #000000;">&#40;</span>v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,n,SequenceGen&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
std::<span style="color: #00eeff;">vector</span>&lt;int&gt;::<span style="color: #00eeff;">iterator</span> it=find_if<span style="color: #000000;">&#40;</span>v.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,v.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,_1&gt;<span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span>;
std::<span style="color: #00eeff;">cout</span>&lt;&lt;*it&lt;&lt;std::<span style="color: #00eeff;">endl</span>;</pre></div>

<h2>Szablony wyrażeń wektorowych</h2>
<hr />
<br />

<p>Wszystko to piękne, ale po co? Używając wyrażeń szablonowych zyskujemy
być może na wygodzie, ale dzieje się to kosztem znacznego
skomplikowania kodu, a co za tym idzie - czasu kompilacji. Kod jest
również dużo trudniejszy do zdebugowania. Powyższy przykład 
ma głównie walor edukacyjny. Teraz pokażę jak tę technikę można
zastosować do problemu, w którym daje ona istotne korzyści. 
</p><p>Rozważmy w tym celu kolejny typowy przykład wykorzystania C++.
Przeładowywanie operatorów pozwala nam prosto rozszerzyć język o
operacje wektorowe. Implementacja np. operatora dodawania dla dwóch wektorów
mogłaby wyglądać następująco:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; vector&lt;T&gt; operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> vector&lt;T&gt; &amp;lhs,
                                         <span style="color: #0000ff;">const</span> vector&lt;T&gt; &amp;rhs<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
vector&lt;T&gt; res<span style="color: #000000;">&#40;</span>lhs<span style="color: #000000;">&#41;</span> ;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;rhs.<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;++i<span style="color: #000000;">&#41;</span> 
    res<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>+=rhs<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">return</span> res;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Potrzebne są jeszcze przeładowane wersje tego operatora, w których
jeden z argumentów jest <tt>double</tt>-em. Zakładając, że zdefiniujemy
pozostałe potrzebne operatory, możemy teraz pisać kod tak jakby typy
wektorowe i operacje na nich były wbudowane w język (to
zresztą było jednym z kryteriów przy projektowaniu C++): 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">vector&lt;double&gt; v1<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
vector&lt;double&gt; v2<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
vector&lt;double&gt; res<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
res=<span style="color: #0000dd;">1.2</span>*v1+v1*v2+v2*<span style="color: #0000dd;">0.5</span>;
<span style="color: #000000;">&#91;</span>cpp<span style="color: #000000;">&#93;</span>
&nbsp;
&lt;p&gt;Niestety, powyższy kod traci wiele przy bliższej analizie. <span style="color: #00eeff;">Je</span>śli
popatrzymy na definicję operatorów, to zauważymy, że ta linijka w
rzeczywistości generuje coś takiego:
&lt;/p&gt;
&nbsp;
<span style="color: #000000;">&#91;</span>cpp<span style="color: #000000;">&#93;</span>
vector&lt;double&gt; tmp1<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
tmp1=<span style="color: #0000dd;">0.5</span>*v2;
vector&lt;double&gt; tmp2<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
tmp2=v1*v2;
vector&lt;double&gt; tmp3<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
tmp3=tmp1+tmp2
vector&lt;double&gt; tmp4<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
tmp4=<span style="color: #0000dd;">1.2</span>*v1;
vector&lt;double&gt; tmp5<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
tmp5=tmp3+tmp4;
res=tmp5</pre></div>


<p>Tworzymy pięć(!) tymczasowych wektorów (przydzielając na nie pamięć!)
i sześć razy kopiujemy wektory!!
Pisząc ten sam kod ręcznie napisalibyśmy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;<span style="color: #0000dd;">100</span>;i++<span style="color: #000000;">&#41;</span>
    res<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>=<span style="color: #0000dd;">1.2</span>*v1<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>+v1<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>*v2<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>+v2<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>*.<span style="color: #0000dd;">5</span>;</pre></div>

<p>Niepotrzebny jest żaden obiekt tymczasowy i tylko jedno kopiowanie.
Ponadto można liczyć, że kompilator lepiej zoptymalizuje tak prosty
kod np.  eliminując jedno mnożenie:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;<span style="color: #0000dd;">100</span>;i++<span style="color: #000000;">&#41;</span>
    res<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>=v1<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>*<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.2</span>+v2<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>+v2<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>*.<span style="color: #0000dd;">5</span>;</pre></div>

<p>Te dodatkowe niepotrzebne kopiowania i tymczasowe obiekty stanowią
duży narzut, a co za tym idzie mocno ograniczją użyteczność tego typu
bibliotek, a to wielka szkoda. Na ratunek przychodzą nam opisane
wcześniej szablony wyrażeń. Jak widzieliśmy w poprzednim wykładzie,
korzystając z tej techniki najpierw tworzymy reprezentację wyrażenia,
a dopiero potem ją wykonujemy. Postaramy się więc napisać kod, który
będzie tworzył reprezentację wyrażeń wektorowych, a dopiero potem
obliczał je w jednej ostatniej pętli, generowanej przez operator
przypisania. Podobnie jak w poprzednim przykładzie kod będzie prostszy
jeśli ograniczymy się do wektorów jednego typu (<tt>double</tt>).
</p><p>Zaczynamy więc od zdefiniowania nowej klasy <tt>Vector</tt>. Nie możemy
użyć <tt>std::vector</tt> bezpośrednio, bo potrzebujemy przeładować
operator przypisania, ale możemy wykorzystać <tt>std::vector</tt> do
implementacji naszej klasy, np. korzystając z dziedziczenia:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Vector : <span style="color: #0000ff;">public</span> vector&lt;double&gt; <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  Vector<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:vector&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  Vector<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> n<span style="color: #000000;">&#41;</span>:vector&lt;double&gt;<span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  Vector<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> n,<span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span>:vector&lt;double&gt;<span style="color: #000000;">&#40;</span>n,x<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  Vector<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Vector&amp; v<span style="color: #000000;">&#41;</span>:vector&lt;double&gt;<span style="color: #000000;">&#40;</span>static_cast&lt;vector&lt;double&gt; &gt;<span style="color: #000000;">&#40;</span>v<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  Vector<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> vector&lt;double&gt;&amp; v<span style="color: #000000;">&#41;</span>:vector&lt;double&gt;<span style="color: #000000;">&#40;</span>v<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  Vector &amp;operator=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Vector&amp; rhs<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
     vector&lt;double&gt;::<span style="color: #00eeff;">operator</span>=<span style="color: #000000;">&#40;</span>static_cast&lt;vector&lt;double&gt; &gt;<span style="color: #000000;">&#40;</span>rhs<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
template&lt;typename V&gt;  Vector &amp;operator=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> V &amp;rhs<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i =<span style="color: #0000dd;">0</span> ;i&lt;vector&lt;double&gt;::<span style="color: #00eeff;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;++i<span style="color: #000000;">&#41;</span> 
    <span style="color: #000000;">&#40;</span>*<span style="color: #0000dd;">this</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>=rhs<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">return</span> *<span style="color: #0000dd;">this</span>;
<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Dziedziczymy cały interfejs z <tt>std::vector</tt> ale musimy zdefiniować
własne konstruktory. Definiujemy też nowy operator przypisania.
Korzystając z szablonów możemy uczynić argumentem operatora
przypisania jakiekolwiek wyrażenie, które posiada operator
indeksowania. Implementacja klasy <tt>Vector</tt> nie jest istotna jak długo
posiada operator indeksowania i szablon operatora przypisania.
</p><p>Podobnie jak poprzednio, potrzebne jeszcze będzie wyrażenie
reprezentujące skalar, który zachowuje sie jak wektor o wszystkich
polach takich samych:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Const_vector <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">double</span> _c;
<span style="color: #0000ff;">public</span>:
  Const_vector<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> c<span style="color: #000000;">&#41;</span>:_c<span style="color: #000000;">&#40;</span>c<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _c;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Następnie definiujemy wyrażenie reprezentujace sumę dwóch wektorów:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename LHS,<span style="color: #0000ff;">typename</span> RHS&gt; <span style="color: #0000ff;">class</span> AddVectors <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">const</span> LHS &amp;_lhs; <span style="color: #ff0000; font-style: italic;">/* bład ! */</span>
  <span style="color: #0000ff;">const</span> RHS &amp;_rhs; <span style="color: #ff0000; font-style: italic;">/* bład ! */</span>
<span style="color: #0000ff;">public</span>:
  AddVectors<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> LHS &amp;lhs,<span style="color: #0000ff;">const</span> RHS &amp;rhs<span style="color: #000000;">&#41;</span>: _lhs<span style="color: #000000;">&#40;</span>lhs<span style="color: #000000;">&#41;</span>,_rhs<span style="color: #000000;">&#40;</span>rhs<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _lhs<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>+_rhs<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>Proszę zwrócić uwagę, że pola <tt>_lhs</tt> i <tt>_rhs</tt> są referencjami.
Gdyby tak nie było inicjalizacja klasy wymagałaby kopiowania i
stracilibyśmy cały zysk. Niestety, to nie jest jeszcze poprawna implementacja.
Żeby to zauważyć przyjrzyjmy sie operatorowi dodawania:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename LHS,<span style="color: #0000ff;">typename</span> RHS&gt; <span style="color: #0000ff;">inline</span> AddVectors&lt;LHS,RHS&gt; 
operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> LHS &amp;lhs,<span style="color: #0000ff;">const</span> RHS &amp;rhs<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> AddVectors&lt;LHS,RHS&gt;<span style="color: #000000;">&#40;</span>lhs,rhs<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>a dokładniej - tej jego wersji, w której jeden z argmentów jest typu
<tt>double</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename LHS&gt; <span style="color: #0000ff;">inline</span> AddVectors&lt;LHS,Const_vector&gt; 
operator+<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> LHS &amp;lhs,<span style="color: #0000ff;">double</span> rhs<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> AddVectors&lt;LHS,Const_vector&gt;<span style="color: #000000;">&#40;</span>lhs,Const_vector<span style="color: #000000;">&#40;</span>rhs<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>i symetryczny. 
W takim przypadku <tt>operator+(...)</tt> tworzy tymczasowy obiekt typu
<tt>Const_vector</tt>, który przekazuje do konstruktora
<tt>AddVectors<LHS,Const_vector></lhs,const_vector></tt>. Taki obiekt nie może być
przechowywany przez referencję, bo przestaje istnieć poza zakresem
operatora dodawania. Obiekty tego typu muszą wiec być przechowywane
jako kopie. Można to łatwo zaimplementować za pomocą klasy cech:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> V_expr_traits <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span>  T <span style="color: #0000ff;">const</span> &amp; op_type;
<span style="color: #000000;">&#125;</span>  ;
template&lt;&gt; <span style="color: #0000ff;">struct</span> V_expr_traits&lt;Const_vector&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span>  Const_vector  op_type;
<span style="color: #000000;">&#125;</span>  ;</pre></div>

<p>za pomocą której definiujemy pola składowe <tt>AddVectors</tt> jako:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">typename</span> V_expr_traits&lt;LHS&gt;::<span style="color: #00eeff;">op_type</span> _lhs;
<span style="color: #0000ff;">typename</span> V_expr_traits&lt;RHS&gt;::<span style="color: #00eeff;">op_type</span> _rhs;</pre></div>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-9-2.png" alt="Rysunek 9.2. Obiekt wygenerowany z wyrażenia v1*(1.2+v2)+v2*.5." title="Rysunek 9.2. Obiekt wygenerowany z wyrażenia v1*(1.2+v2)+v2*.5."  class="image image-_original " width="350" height="249" /><span class="caption"><strong>Rysunek 9.2. Obiekt wygenerowany z wyrażenia v1*(1.2+v2)+v2*.5.</strong></span></span>


<p>Pomijając te aspekty, widać więc, że implementacja jest całkowicie
analogiczna do przykładu z funktorami, tyle że operator nawiasów został
zastąpiony operatorem indeksowania. Zakładając, że zaimplementujemy
pozostałe klasy i operatory to kompilator z wyrażenia
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">v1*<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.2</span>+v2<span style="color: #000000;">&#41;</span>+v2*.<span style="color: #0000dd;">5</span>;</pre></div>

<p>stworzy nam obiekt przestawiony na rysunku 9.2.
</p><p>Dopiero próba przypisania tego obiektu do wektora <tt>res</tt> spowoduje wywołanie w pętli operatora indeksowania dla tego obiektu, co pociągnie za sobą efektywnie obliczenie wyrażenia
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;n;++i<span style="color: #000000;">&#41;</span>
res<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>=v1<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>*<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.2</span>+v2<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>+v2<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>*.<span style="color: #0000dd;">5</span>;</pre></div>

<p>zgodnie z naszymi zamiarami.
</p>

<h2>Efektywność kodu</h2>
<br />

<p>Aby sprawdzić jak działa to w praktyce, porównałem czas wykonania wyrażenia 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">v1*<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.2</span>+v2<span style="color: #000000;">&#41;</span>+v2*.<span style="color: #0000dd;">5</span>;</pre></div>

<p>korzystając ze "zwykłej" implementacji operatorów arytmetycznych i z
szablonów wyrażeń. Pomiaru dokonywałem poprzez umieszczenie tego
wyrażenia w pętli:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">  Vector v1<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
  Vector v2<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
  Vector res<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">100</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> j = <span style="color: #0000dd;">0</span>;j&lt; <span style="color: #0000dd;">10000000</span>;++j<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>    
    res=<span style="color: #0000dd;">1.2</span>*v1+v1*v2+v2*<span style="color: #0000dd;">0.5</span>;
    f<span style="color: #000000;">&#40;</span>res<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span></pre></div>

<p>Czas wykonania programu mierzyłem poleceniem
systemowym <tt>time</tt>. Wyniki są następujace (w sekundach):
</p>
<div align="center">
<table border="1">

<tr>
<td>
</td><td> zwykłe
</td><td>  szablony
</td></tr>
<tr>
<td align="center">-O0
</td><td align="center">  720
</td><td align="center">  311
</td></tr>
<tr>
<td align="center">-O1
</td><td align="center">  36
</td><td align="center">  6.3
</td></tr>
<tr>
<td align="center">-O2
</td><td align="center">  30
</td><td align="center">  5.5
</td></tr>
<tr>
<td align="center">-O3
</td><td align="center">  30
</td><td align="center">  5.5
</td></tr></table>
</div>

<p>Proszę zauważyć, że znów włączanie optymalizacji daje dramatyczny 20 - 50-krotny wzrost szybkości programu. Podkreślam raz jeszcze, że opcja
<tt>-O0</tt>, czyli brak optymalizacji, jest domyślną opcją dla kompilatora
g++.  Widać też, że używanie szablonów wyrażeń daje pięciokrotny wzrost
szybkości programu. Oczywiście ten wynik będzie silnie zależał od
konkretnych zastosowań. Jak zwykle gorąco zachęcam do własnych eksperymentów.
</p>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Integrate.cpp">Integrate.cpp</a></td><td>311 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Integrate_temp.cpp">Integrate_temp.cpp</a></td><td>638 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Expr_templates.h">Expr_templates.h</a></td><td>3.72 KB</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Expr_templates_T.h">Expr_templates_T.h</a></td><td>4.2 KB</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1246" class="section-2">
  <h1 class="book-heading">Inteligentne wskaźniki</h1>
  <h2>Wstęp</h2>
<hr />
<br />

<p>Wskaźniki to jeden z bardziej pożytecznych elementów języka C/C++, ale
na pewno najbardziej niebezpieczny. Zabawa z gołymi wskaźnikami
przypomina żonglerkę odbezpieczonymi granatami. To nie jest już
kwestia czy nastąpi wybuch, ale kiedy on nastąpi.  Możliwości
wywołania wybuchu i jego konsekwencje są wielorakie:
</p>

<ul><li> Możemy usunąć wskaźnik nie zwalniając pamięci na którą on wskazuje.  Jeśli żaden inny wskaźnik nie wskazuje na ten obszar to jest on bezpowrotnie stracony dla naszej aplikacji i mamy do czynienia z wyciekiem pamięci.
</li><li> Możemy zwolnić ten sam obszar pamięci kilkakrotnie. Powoduje to zwykle krach całej aplikacji. 
</li><li> Podobnie jeśli spróbujemy zdereferencjonować wskaźniki <tt>null</tt>.
</li><li> No i oczywiście mamy całe spektrum możliwości sięgnięcia za pomocą wskaźnika tam gdzie nie powinniśmy, odczytując lub co gorsza zmieniając nie te zmienne co trzeba.
</li></ul>

<p>Jeśli więc nie czujemy się jak Rambo, albo nie przymierzając sam Chuck
Norris, to powinniśmy poszukać jakichś zabezpieczeń. W C++
zabezpieczenia są dostarczane poprzez możliwość definicji własnych
typów klas. Dzięki klasom możemy nie korzystać z dynamicznej alokacji
pamięci bezpośrednio, ale za pośrednictwem klas, które dbają o alokacje
w konstruktorach, dealokację w destruktorach, zwiększają i
zmmniejszają pamięć na żądanie, itp. Przykładem takiego podejścia są
np. kontenery STL, których jedną z zalet jest właśnie zarządzanie
własną pamięcią. Jeśli jednak ciągle potrzebujemy wskaźników to możemy
rozważyć opakowanie ich w klasy.  Jest to możliwe dzięki możliwości
jakie w C++ daje przeładowywanie operatorów, w szczególności możemy
przeładowywać operatory dereferencjonowania <tt>operator*()</tt> i
<tt>operator->()</tt>. W ten sposób możemy upodobnić zachowanie
definiowanych przez nas typów do zachowania wskaźników.
Takie typy nazywamy inteligentnymi wskaźnikami, ponieważ dostarczają
nam dodatkowej funkcjonalności ponad zwykłe zachowanie wskaźnika.
</p><p>Tak jak i u ludzi, rodzaje inteligencji wskaźników bywają różne i
inteligentne wskaźniki występują w najróżniejszych wariacjach. Podział
tych wariantów można przeprowadzić na wiele sposobów, ja skoncentruję
sie na dwóch grupach:
</p>

<ul><li> Zachowanie wskaźników podczas kopiowania, przypisywania i niszczenia. Nazwiemy to prawami własności. 
</li><li> Zachowanie się operatorów  <tt>operator*()</tt> i <tt>operator->()</tt>. Nazwiemy to kontrolą dostępu.
</li></ul>

<p>Poniżej krótko przedstawię przegląd głównych możliwości w każdej z
powyższych grup.
</p>

<h2>Prawa własności</h2>
<hr />
<br />
<p>Głównym powodem używania inteligentnych wskaźników jest uzyskanie
kontroli nad operacjami kopiowania, przypisywania i niszczenia
wskaźnika. W tym kontekście mówimy często, że wskaźnik jest albo nie
jest właścicielem obiektu na który wskazuje.  Poniżej przedstawiam cztery
typowe schematy wskaźników.
</p>

<h4>Głupie wskaźniki</h4>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-10-1.png" alt="Rysunek 10.1. Zwykłe wskaźniki." title="Rysunek 10.1. Zwykłe wskaźniki."  class="image image-_original " width="247" height="321" /><span class="caption"><strong>Rysunek 10.1. Zwykłe wskaźniki.</strong></span></span>

<p>Zwykłe (nieinteligentne) wskaźniki, nie są właścicielami obiektów, na
które wskazują. Kopiowanie czy przypisanie prowadzi do współdzielenia
referencji (oba wskaźniki wskazują na ten sam obiekt) często
niezamierzonej. Zniszczenie wskaźnika nie powoduje
zniszczenia (dealokacji pamięci) obiektu, na który on wskazuje.
Przedstawia to rysunek 10.1, na którym zilustrowano przebieg wykonania kodu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
X *px<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#41;</span>;
X  py<span style="color: #000000;">&#40;</span>px<span style="color: #000000;">&#41;</span>;
X  pz<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#41;</span>;
pz=py;
<span style="color: #000000;">&#125;</span>
&nbsp;
f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<h4>Zliczanie referencji</h4>

<p>Wskaźniki zliczające referencje są niejako właścicielami grupowymi
obiektu, na który wskazują.
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-10-2.png" alt="Rysunek 10.2. Wskaźniki zliczające referencje." title="Rysunek 10.2. Wskaźniki zliczające referencje."  class="image image-_original " width="237" height="276" /><span class="caption"><strong>Rysunek 10.2. Wskaźniki zliczające referencje.</strong></span></span>

<p>Kopiowanie i przypisanie powoduje
współdzielnie referencji, ale kontrolowane, w tym sensie, że
monitorowana jest liczba wskaźników do danego obiektu. Na zasadzie
"ostatni gasi światło" zniszczenie wskaźnika powoduje zniszczenie
obiektu wtedy gdy był to jedyny (ostatni) wskaźnik na ten obiekt.
Liczenie referencji reprezentuje więc prostą wersję "odśmiecacza"
(garbage-collector). Zachowanie się tego typu wskaźników prezentuje
rysunek 10.2, w oparciu o analogiczny kod.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
ref_ptr&lt;X&gt;  px<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#41;</span>;
ref_ptr&lt;X&gt;  py<span style="color: #000000;">&#40;</span>px<span style="color: #000000;">&#41;</span>;
ref_ptr&lt;X&gt;  pz<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#41;</span>;
pz=py;
<span style="color: #000000;">&#125;</span>
&nbsp;
f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<h4>Głęboka/fizyczna kopia</h4>

<p>Takie wskaźniki są pojedynczymi właścicielami obiektów, na które
wskazują i zachowują się jak wartości, a nie wskaźniki.
Kopiowanie bądź
przypisanie powoduje fizyczne kopiowanie obiektu wskazywanego.
Zniszczenie wskaźnika powoduje zniszczenie wskazywanego obiektu. Od
zwykłych wartości obiektów różnią się tym, że mają zachowanie
polimorficzne i używane są tam gdzie polimorfizm jest nam potrzebny, a
więc nie możemy użyć bezpośrednio samych obiektów. Zachowanie kodu
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-10-3.png" alt="Rysunek 10.3. Wskaźniki wykonujące kopie fizyczne." title="Rysunek 10.3. Wskaźniki wykonujące kopie fizyczne."  class="image image-_original " width="248" height="242" /><span class="caption"><strong>Rysunek 10.3. Wskaźniki wykonujące kopie fizyczne.</strong></span></span>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
clone_ptr&lt;X&gt;  px<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#41;</span>;
clone_ptr&lt;X&gt;  py<span style="color: #000000;">&#40;</span>px<span style="color: #000000;">&#41;</span>;
cloen_ptr&lt;X&gt;  pz<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#41;</span>;
pz=py;
<span style="color: #000000;">&#125;</span>&lt;br /&gt;
f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>ilustruje rysunek 10.3.
</p><p>Zastosowanie wskaźników z głębokim kopiowaniem zilustruję na
przykładzie podanego już wcześniej przykładu z kształtami
geometrycznymi.  W programie wykorzystującym takie kształty na pewno
zachodzi konieczność kopiowania kształtów. Załóżmy, że wybraliśmy
(myszką) jakiś kształt i wskaźnik do niego jest przechowywany w
zmiennej <tt>Shape *selected</tt>.  Załóżmy, że jest to obiekt typu
<tt>Circle</tt>.  Teraz chcemy uzyskać kopię tego kształtu. Przypisanie
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Shape *copy=selected;</pre></div>

<p>oczywiście nie zadziała, bo uzyskamy dwa wskaźniki na jeden obiekt. A
my potrzebujemy drugiego obiektu. Bez koniecznośći polimorfizmu
wystarczyłoby użyć konstruktora kopiującego:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Shape *copy=<span style="color: #0000dd;">new</span> Shape<span style="color: #000000;">&#40;</span>*selected<span style="color: #000000;">&#41;</span>;</pre></div>

<p>Niestety, w naszym przypadku ten kod się nawet nie skompiluje, bo klasa
<tt>Shape</tt> jest klasą abstrakcyjną. Nawet gdyby nie była, to i tak
zostałby utworzony obiekt typu <tt>Shape</tt>, a nie <tt>Circle</tt>.
W celu zaimplementowania kopiowania polimorficznego możemy wyposażyć naszą klasę <tt>Shape</tt> w funkcję 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">virtual</span> Shape *clone<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> = <span style="color: #0000dd;">0</span></pre></div>

<p>następnie zdefiniować ją w każdej podklasie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Circle:<span style="color: #0000ff;">public</span> Shape <span style="color: #000000;">&#123;</span>
...
<span style="color: #00eeff;">Circle</span> *clone<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">new</span> Circle<span style="color: #000000;">&#40;</span>*<span style="color: #0000dd;">this</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>i wtedy możemy skopiować (sklonować) nasz obiekt za pomocą 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Shape *copy = selected-&gt;clone<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Możemy teraz tę technikę, nazywaną również wzorcem prototypu lub
fabryką klonów (zob. E. Gamma, R. Helm, R. Johnson, J. Vlissides <i>"Wzorce projektowe. Elementy oprogramowania obiektowego wielokrotnego użytku"</i>), zastosować w implementacji inteligentnego
wskaźnika <tt>clone_ptr</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">clone_ptr&lt;Shape&gt; selected;
...
<span style="color: #00eeff;">clone_ptr</span>&lt;Shape&gt; copy<span style="color: #000000;">&#40;</span>selected<span style="color: #000000;">&#41;</span>;</pre></div>

<h4>auto_ptr</h4>
<br />

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-10-4.png" alt="Rysunek 10.4. Wskaźniki auto_ptr." title="Rysunek 10.4. Wskaźniki auto_ptr."  class="image image-_original " width="233" height="364" /><span class="caption"><strong>Rysunek 10.4. Wskaźniki auto_ptr.</strong></span></span>


<p>Wskaźniki <tt>auto_ptr</tt> (jedyne inteligentne wskaźniki dostępne w
standardzie C++) są pojedynczymi, bardzo zaborczymi, właścicielami obiektu,
na który wskazują. Tak zaborczymi, że nie dopuszczają możliwości
współdzielenia obiektu ani jego kopiowania.  Próba skopiowania albo
przypisania prowadzi do przekazania własności: obiekt
kopiowany(przypisywany) oddaje/przekazuje prawo własności do
posiadanego obiektu drugiemu obiektowi. Oznacza to, że obiekt
kopiowany lub przypisywany jest zmieniany w trakcie tych operacji.
Ilustruje to rysunek 10.4 na podstawie kodu
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
auto_ptr&lt;X&gt;  px<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#41;</span>;
auto_ptr&lt;X&gt;  py<span style="color: #000000;">&#40;</span>px<span style="color: #000000;">&#41;</span>;
auto_ptr&lt;X&gt;  pz<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#41;</span>;
pz=py;
<span style="color: #000000;">&#125;</span>
f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>To bardzo nieintuicyjne zachowanie:
obiekty <tt>auto_ptr</tt> nie są modelami konceptu <tt>Assignable</tt>.
Wskaźniki te zostały wprowadzone aby wspomagać bezpieczną alokację
zasobów (głównie pamięci) według wzorca "alokacja zasobów jest
inicjalizacją" (zob. B. Stroustrup <i>"Język C++"</i>). Rozważmy następujący przykład:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span>  f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  BigX *p = <span style="color: #0000dd;">new</span> BigX;
&lt;i&gt;... <span style="color: #00eeff;">tu</span> coś się dzieje&lt;/i&gt;
  <span style="color: #0000dd;">delete</span>  p;
  <span style="color: #0000ff;">return</span> wynik;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Jest to typowe zastosowanie dynamicznej alokacji pamięci.
Problem polega na tym, że jeżeli pomiędzy przydziałem pamięci a jej
zwolnieniem coś się stanie, to będziemy mieli wyciek pamięci. To coś
to może być np. dodatkowe wyrażenie <tt>return</tt> lub rzucony wyjątek.
W obu przypadkach zniszczone zostaną wszystkie statycznie zaalokowane
obiekty, w tym i wskaźnik <tt>p</tt>. Ale ponieważ jest to zwykły wskaźnik
jego zniszczenie nie spowoduje zwolnienia wskazywanej przez niego
pamięci. Rozwiązaniem jest właśnie uczynienie go obiektem będącym właścicielem 
wskazywanej pamięci:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span>  f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  auto_ptr&lt;BigX&gt; p<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> BigX<span style="color: #000000;">&#41;</span>;&lt;br /&gt;
&lt;i&gt;... <span style="color: #00eeff;">tu</span> coś się dzieje&lt;/i&gt;&lt;br /&gt;
  <span style="color: #0000ff;">return</span> wynik;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Teraz przy wyjściu z funkcji zostanie wywołany destruktor <tt>p</tt>, a on 
zwolni przydzieloną pamięć.
</p><p>Wzkaźniki <tt>auto_ptr</tt> mogą być przekazywane i zwracane z funkcji.
Jeśli przekażemy <tt>auto_ptr</tt> do funkcji przez wartość, to spowodowane
tym kopiowanie spowoduje, że własność zostanie przekazana na argument
funkcji i pamięć zostanie zwolniona kiedy funkcja zakończy swoje działanie.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">void</span> val<span style="color: #000000;">&#40;</span>T p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #000000;">&#125;</span>;
&nbsp;
auto_ptr&lt;X&gt; px<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#41;</span>;
val<span style="color: #000000;">&#40;</span>px<span style="color: #000000;">&#41;</span>;
&lt;i&gt;px zawiera wskaźnik <span style="color: #0000ff;">null</span>. <span style="color: #00eeff;">pami</span>ęć jest zwolniona&lt;/i&gt;
cout&lt;&lt;px.<span style="color: #00eeff;">get</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl; 
&lt;i&gt;zwraca opakowany wskaźnik na X, powinien być zero&lt;/i&gt;</pre></div>

<p>Jeśli przekażemy <tt>auto_ptr</tt> przez referencje to kopiowania nie
będzie, przekazanie własności bedzie zależeć od tego czy wkaźnik
zostanie skopiowany lub przypisany wewnątrz funkcji. 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">void</span> ref_1<span style="color: #000000;">&#40;</span>T &amp;p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  T x = p;
<span style="color: #000000;">&#125;</span>; 
template&lt;typename T&gt; <span style="color: #0000ff;">void</span> ref_2<span style="color: #000000;">&#40;</span>T &amp;p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #000000;">&#125;</span>;&lt;br /&gt;
auto_ptr&lt;X&gt; px<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#41;</span>;
ref_2<span style="color: #000000;">&#40;</span>px<span style="color: #000000;">&#41;</span>;
&lt;i&gt;nic sie nie zmieniło&lt;/i&gt;
cout&lt;&lt;px.<span style="color: #00eeff;">get</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl; &lt;i&gt;wypisuje jakiś adres&lt;/i&gt;
ref_1<span style="color: #000000;">&#40;</span>px<span style="color: #000000;">&#41;</span>
&lt;i&gt;px zawiera wskaźnik <span style="color: #0000ff;">null</span>. <span style="color: #00eeff;">pami</span>ęć jest zwolniona&lt;/i&gt;
cout&lt;&lt;px.<span style="color: #00eeff;">get</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl; 
&lt;i&gt;zwraca opakowany wskaźnik na X, powinien być zero&lt;/i&gt;</pre></div>

<p>W przypadku przekazania <tt>auto_ptr</tt> jako referencji do stałej sprawa
jest bardziej skomplikowana. Obecny standard stanowi, że wskaźnik
<tt>auto_ptr</tt> przekazany jako referencja do stałej, nie przekazuje
własności, tzn. operacje, które by do tego prowadziły nie skompilują
się.  Z tych samych powodów nie powinien skompilować się kod używający
kontenerów STL zawierających wskaźniki <tt>auto_ptr</tt>.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">void</span> cref_1<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  T x = p;
<span style="color: #000000;">&#125;</span>; 
template&lt;typename T&gt; <span style="color: #0000ff;">void</span> cref_2<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #000000;">&#125;</span>;&lt;br /&gt;
auto_ptr&lt;X&gt; px<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#41;</span>;
cref_2<span style="color: #000000;">&#40;</span>px<span style="color: #000000;">&#41;</span>;
&lt;i&gt;OK, nic się nie stanie&lt;/i&gt;
cout&lt;&lt;px.<span style="color: #00eeff;">get</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;endl; &lt;i&gt;wypisuje jakiś adres&lt;/i&gt;
cref_1<span style="color: #000000;">&#40;</span>px<span style="color: #000000;">&#41;</span> &lt;i&gt;nie skompiluje się&lt;/i&gt;&lt;br /&gt;
std::<span style="color: #00eeff;">vector</span>&lt;auto_ptr&lt;X&gt;&gt; v<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>; &lt;i&gt;nie skompiluje się&lt;/i&gt;</pre></div>

<p>( Źródło: auto_ptr.cpp)
</p><p>Różne implementacje różnie sobie z tym radzą i w praktyce wynik
kompilowania powyższych fragmentów kodu może być różny na różnych
platformach. Jest to dość techniczne zagadnienie, zainteresowane
osoby odsyłam do D. Vandevoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i> i N.M. Josuttis <i>"C++ Biblioteka standardowa, podręcznik programisty"</i>.
</p>

<h2>Kontrola dostępu</h2>
<hr />
<br />

<p>Poza kontrolą rodzaju praw własności, inteligentny wskaźnik daje nam
możliwość kontroli nad operacjami dostępu do wskazywanego obiektu
poprzez operatory <tt>operator->()</tt> i <tt>operator*()</tt>.  Wpływać na
zachowanie tych operatorów możemy dwojako. Po pierwsze w oczywisty
sposób możemy wykonać dodatkowy kod zanim zwrócimy z nich odpowiednią
wartość:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T &amp;operator*<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&lt;i&gt;zrób coś&lt;/i&gt;
<span style="color: #0000ff;">return</span> *_p; 
<span style="color: #000000;">&#125;</span></pre></div>

<p>Ten dodatkowy kod może np. sprawdzać czy wskaźnik <tt>_p</tt> nie jest
zerowy, może zliczać wywołania, itp. 
</p><p>Po drugie możemy zmienić zwracany typ. Wbudowane operatory <tt>*</tt> i
<tt>-></tt> zwracają odpowiednio <tt>T&</tt> i <tt>T*</tt>. Oczywiście my możemy
zwrócić cokolwiek, ale żeby to miało jakiś sens powinny to być obiekty
zachowujące sie jak <tt>T&</tt> i <tt>T*</tt>. Takie obiekty które "zachowują
się jak" coś, ale nie są tym (kwacze jak kaczka, ale to nie jest
kaczka) nazywamy obiektami zastępczymi (proxy).
</p>

<h3>Proxy</h3>

<p>Dlaczego moglibyśmy chcieć używać obiektów zastępczych? 
</p><p>Typowe zastosowanie to implementacja operacji przypisania do obiektów,
które tak naprawdę obiektami nie są. Weźmy jako przykład
<tt>ostream_iterator</tt> dostarczany przez STL, który zezwala traktować
plik wyjściowy jak kontener z iteratorem typu <tt>OutputIterator</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">vector&lt;int&gt; V<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">10</span>,<span style="color: #0000dd;">7</span><span style="color: #000000;">&#41;</span>;
copy<span style="color: #000000;">&#40;</span>V.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>, V.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>, ostream_iterator&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">cout</span>, <span style="color: #666666;">&quot;<span style="color: #666666; font-weight: bold;">\n</span>&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Przypatrzny się temu przykładowi bliżej. Jeśli zdefiniujemy
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">ostream_iterator&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">cout</span>, <span style="color: #666666;">&quot;<span style="color: #666666; font-weight: bold;">\n</span>&quot;</span><span style="color: #000000;">&#41;</span> iout;</pre></div>

<p>to w zasadzie jedyną dozwoloną operacją jest przypisanie i zwiększenie
następujące po sobie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #000000;">&#40;</span>*iout<span style="color: #000000;">&#41;</span> = <span style="color: #0000dd;">666</span>; ++iout;</pre></div>

<p>Ewidentnie nie istnieje żaden obiekt, do którego referencje moglibyśmy
zwrócić. Możemy jednak zwrócić obiekt zastępczy, który będzie
definiował operator przypisania:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> writing_proxy <span style="color: #000000;">&#123;</span>
    std::<span style="color: #00eeff;">ostream</span> &amp;_out; 
  <span style="color: #0000ff;">public</span>:
    writing_proxy<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">ostream</span> &amp;out<span style="color: #000000;">&#41;</span>:_out<span style="color: #000000;">&#40;</span>out<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;&lt;br /&gt;
    <span style="color: #0000ff;">void</span> operator=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      _out&lt;&lt;val;
    <span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: out.cpp)
</p><p>Tę klasę zamkniemy wewnątrz klasy <tt>ostream_iterator</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">class</span> ostream_iterator: 
<span style="color: #0000ff;">public</span> std::<span style="color: #00eeff;">iterator</span> &lt;std::<span style="color: #00eeff;">output_iterator_tag</span>, T &gt;  <span style="color: #000000;">&#123;</span>&lt;br /&gt;
  <span style="color: #0000ff;">class</span> writing_proxy <span style="color: #000000;">&#123;</span>
  &lt;i&gt;...&lt;/i&gt;
  <span style="color: #000000;">&#125;</span>;&lt;br /&gt;
  std::<span style="color: #00eeff;">string</span> _sep;
  std::<span style="color: #00eeff;">ostream</span> &amp;_out;
  writing_proxy  _proxy;
<span style="color: #0000ff;">public</span>:
  ostream_iterator<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">ostream</span> &amp;out,std::<span style="color: #00eeff;">string</span> sep<span style="color: #000000;">&#41;</span>:
    _out<span style="color: #000000;">&#40;</span>out<span style="color: #000000;">&#41;</span>,_sep<span style="color: #000000;">&#40;</span>sep<span style="color: #000000;">&#41;</span>,_proxy<span style="color: #000000;">&#40;</span>_out<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> operator++<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>    <span style="color: #000000;">&#123;</span>_out&lt;&lt;_sep;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> operator++<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_out&lt;&lt;_sep;<span style="color: #000000;">&#125;</span>
  writing_proxy &amp;operator*<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _proxy;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: out.cpp)
</p><p>Dziedziczenie z klasy <tt>iterator</tt> zapewni nam, że nasz
<tt>ostream_iterator</tt> posiada wszystkie typy stowarzyszone wymagane
przez iteratory STL. To z kolei pociąga za soba możliwość użycia
<tt>iterator_traits</tt>  (zob. wykład 5.5). Bez tego nie moglibyśmy używać <tt>ostream_iterator</tt> w niektórych algorytmach STL.  
</p><p>Teraz możemy juz używać wyrażeń typu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">ostream_iterator&lt;int&gt; io<span style="color: #000000;">&#40;</span>std::<span style="color: #0000dd;">cout</span>,<span style="color: #666666;">&quot;&quot;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#40;</span>*io<span style="color: #000000;">&#41;</span>=<span style="color: #0000dd;">44</span>;</pre></div>

<p>( Źródło: out.cpp)
</p><p>Wywołanie <tt>*io</tt> zwraca <tt>writing_proxy</tt>. Następnie wywoływany
jest
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">writing_proxy::<span style="color: #00eeff;">operator</span>=<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">44</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#125;</span></pre></div>

<p>który wykonuje operację
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">cout</span>&lt;&lt;<span style="color: #0000dd;">44</span>;</pre></div>

<p>Widać też, że operacja 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">i=<span style="color: #000000;">&#40;</span>*io<span style="color: #000000;">&#41;</span></pre></div>

<p>się nie powiedzie (nie skompiluje). W tym przypadku jest to pożądane
zachowanie, bo taka operacja nie ma sensu. Jeśli byśmy jednak
chcieli umożliwić działanie operacji przypisania w drugą stronę, możemy
w obiekcie proxy zdefiniować operator konwersji na typ <tt>T</tt>.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">operator T<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> T<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>; &lt;i&gt;uwaga bzdurny przykład!!!&lt;/i&gt;</pre></div>

<p>Wtedy wykonanie 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">i=<span style="color: #000000;">&#40;</span>*io<span style="color: #000000;">&#41;</span></pre></div>

<p>przypisze zero do zmiennej <tt>i</tt>. W ten sposób obiekty proxy
pozwalają nam rozróżniać użycie operatora <tt>*</tt> do odczytu i do
zapisu. 
</p><p>Obiekty zastępcze stanowią zresztą często spotykany wzorzec projektowy
(zob. E. Gamma, R. Helm, R. Johnson, J. Vlissides <i>"Wzorce projektowe. Elementy oprogramowania obiektowego wielokrotnego użytku"</i>). Poniżej przedstawię jeszcze jedną "sztuczkę"
opisaną w A. Alexandrescu <i>"Nowoczesne Projektowanie w C++"</i>, służącą do automatycznego obudowywania
funkcji wywoływanych za pośrednictwem inteligentnego wskaźnika
wywoływaniami innych funkcji.
</p>

<h3>Opakowywanie wywołań funkcji</h3>
<br />
<hr />
<p>Załóżmy, że mamy obiekt typu: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> Widget <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">void</span> pre<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>cout&lt;&lt;<span style="color: #666666;">&quot;pre&quot;</span>&lt;&lt;endl;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> post<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>cout&lt;&lt;<span style="color: #666666;">&quot;post&quot;</span>&lt;&lt;endl;<span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">void</span> f1<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>cout&lt;&lt;<span style="color: #666666;">&quot;f1&quot;</span>&lt;&lt;endl;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> f2<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>cout&lt;&lt;<span style="color: #666666;">&quot;f2&quot;</span>&lt;&lt;endl;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: pre_post.cpp)
</p><p>Niech 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Smart_prt&lt;Widget&gt; pw<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> Widget<span style="color: #000000;">&#41;</span>;</pre></div>

<p>bedzię inteligentnym wskaźnikiem do <tt>Widget</tt>. 
Chcemy aby każde wywołanie funkcji z <tt>Widget</tt> np.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">pw-&gt;f1<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span></pre></div>

<p>zostało poprzedzone przez wywołanie funkcji <tt>pre()</tt>, a po nim
nastapiło wywołanie funkcji <tt>post()</tt>. Jedną z możliwości jest
oczywiście zmiana kodu funkcji <tt>f?</tt>, tak aby wywoływały na początku
<tt>pre()</tt> i <tt>post()</tt> na końcu. Można też dodać zestaw funkcji
opakowywujących:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">f1_wrapper<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>pre<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;f1<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;post<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span></pre></div>

<p>Jest to jednak niepotrzebne duplikowanie kodu i możliwe do
zastosowania tylko jeśli mamy możliwość zmiany kodu klasy <tt>Widget</tt>. 
</p><p>Można jednak zrobić inaczej. Zdefiniujemy pomocniczą klasę
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Wrapper <span style="color: #000000;">&#123;</span>
  T* _p;
  Wrapper<span style="color: #000000;">&#40;</span>T* p<span style="color: #000000;">&#41;</span>:_p<span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_p-&gt;pre<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
  ~Wrapper<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>          <span style="color: #000000;">&#123;</span>_p-&gt;post<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
&nbsp;
  T*  operator-&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _p;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: pre_post.cpp)
</p><p>W klasie inteligentnego wskaźnika przedefiniujemy <tt>operator->()</tt>
tak, aby zwracał <tt>Wrapper<T>(T *)</t></tt> zamiast <tt>T*</tt>.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Smart_ptr <span style="color: #000000;">&#123;</span>
  T *_p;
  Smart_ptr<span style="color: #000000;">&#40;</span>T *p<span style="color: #000000;">&#41;</span>:_p<span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  ~Smart_ptr<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #0000dd;">delete</span> _p;<span style="color: #000000;">&#125;</span>;
&nbsp;
  Wrapper&lt;T&gt; operator-&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>   <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> Wrapper&lt;T&gt;<span style="color: #000000;">&#40;</span>_p<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
  T &amp;operator*<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> *_p<span style="color: #000000;">&#125;</span>; 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: pre_post.cpp)
</p><p>Jeśli teraz wywołamy 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">pw-&gt;f1<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>to bedą się dziać następujace rzeczy: 
</p>
<ul><li> zostanie wywołany 
</li></ul>

<div class="geshifilter"><pre class="geshifilter-cpp">pw.<span style="color: #00eeff;">operator</span>-&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>operator ten zwraca obiekt <tt>tmp</tt> typu <tt>Wrapper<Widget></widget></tt>, ale
najpierw musi go skonstruować, a więc
</p>

<ul><li> zostanie wywołany konstruktor 
</li></ul>

<div class="geshifilter"><pre class="geshifilter-cpp">tmp=Wrapper&lt;Widget&gt;<span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span>;</pre></div>

<p>który wywoła
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">p-&gt;pre<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<ul><li> Jeśli <tt>operator->()</tt> zwróci obiekt, który posiada <tt>operator->()</tt> to jest on wywoływany rekurencyjnie, aż zostanie zwrócony typ wskaźnikowy. Tak więc zostanie wywołany <tt>tmp.operator->()</tt>, który zwroci <tt>p</tt>.
</li><li> Poprzez ten wskaźnik zostanie wywołana funkcja
</li></ul>

<div class="geshifilter"><pre class="geshifilter-cpp">p-&gt;f1<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<ul><li> Zakończy się wywołanie <tt>pw.operator->()</tt>, a więc zostanie wywołany destruktor obiektu tymczasowego <tt>tmp</tt>, który wywoła
</li></ul>

<div class="geshifilter"><pre class="geshifilter-cpp">p-&gt;post<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Widać więc, że w końcu zostanie wykonana sekwencja wywołań:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">p-&gt;pre<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
p-&gt;f1<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
p-&gt;post<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>i tak bedzie dla dowolnej wywoływanej metody. 
Jeśli jednak wywołamy funkcję <tt>f1()</tt> za pomocą wyrażenia:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #000000;">&#40;</span>*pw<span style="color: #000000;">&#41;</span>.<span style="color: #00eeff;">f1</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>to ten mechanizm nie zadziała i nie ma możliwości, aby go w tej sytuacji
zaimplementować. Może to być traktowane jako wada, bo nie jesteśmy w
stanie zapewnić, że każde wywołanie funkcji zostanie opakowane, ale z
drugiej strony mamy do dyspozycji możliwość wyboru pomiędzy opakowanym
i nieopakowanym wywołaniem funkcji.
</p>

<h3>Współdzielenie reprezentacji</h3>
<br />

<p>Opisując inteligentne wskaźniki nie można nie wspomnieć o technice
implementacyjnej, która jest ściśle z nimi zwiazana, a mianowicie o
współdzieleniu reprezentacji. Technika ta polega na oddelegowaniu
całego (lub prawie całego) zachowania klasy do innego obiektu,
nazywanego reprezentacją, a  w obiekcie klasy przechowywanie tylko uchwytu
do reprezentacji (zob rysunek 10.5).
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-10-5.png" alt="Rysunek 10.5." title="Rysunek 10.5."  class="image image-_original " width="342" height="340" /><span class="caption"><strong>Rysunek 10.5.</strong></span></span>


<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Wichajster <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
<span style="color: #0000ff;">void</span> do_something<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_rep-&gt;do_something<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">private</span>:
  WichajsterRep _rep;   
<span style="color: #000000;">&#125;</span></pre></div>

<p>Techniki tej używamy np.  kiedy chcemy oszczędzić czas i miejsce
potrzebne na kopiowanie obiektów. Kilka kopii obiektów klasy
<tt>Wichajster</tt> może współdzielić jedną reprezentację korzystając np.
ze zliczania referencji. Istotną różnicą w stosunku do inteligentnych
wskaźników jest zachowanie w przypadku zmiany jednego z obiektów.  W
przypadku wskaźników, współdzielenie referencji jest planowaną cechą
podejścia: kiedy zmieniamy obiekt poprzez jeden ze  wskaźników 
wszystkie inne wskaźniki wskazują na zmieniony obiekt. 
</p><p>W przypadku współdzielenia reprezentacji chcemy cały czas rozróżniać
obiekty, współdzielenie jest tylko technicznym środkiem optymalizacji.
Wymaga to zastosowania techniki "copy on write", tzn. w momencie, w
którym dokonujemy na obiekcie operacji mogącej go zmienić i jeśli
posiada on współdzieloną reprezentację, to tworzymy nową fizyczna
kopię tej reprezentacji i dopiero ją zmieniamy. Przedstawione to jest
na rysunku 10.5.
W przypadku metod łatwo stwierdzić, które zmieniaja obiekt, a które nie,
problem jest tylko z metodami, które zwracaja referencje do wnętrza
obiektu. Takie metody mogą służyć zarówno do zapisu, jak i do odczytu.
Częściowym rozwiązaniem może być użycie obiektów proxy, tak jak to
opisano w poprzednim podrozdziale. Szczegółowy opis tej techniki
znajduje się w S. Meyers <i>"Język C++ bardziej efektywny"</i>.
</p>

<h2>Iteratory</h2>
<hr />
<p>Iteratory to kolejny rodzaj inteligentnych wskaźników. Jeżli chodzi o
prawa własności czy kontrolę dostępu to w większości zachowują się jak
zwykłe wskaźniki. Wyjątkiem są specjalne iteratory, takie jak
<tt>ostream_iterator</tt>, czy <tt>back_inserter</tt>, wspomniane powyżej.
Ale zasadniczo inteligencja iteratorów umiejscowiona jest w operacjach
arytmetycznych. Chodzi głównie o operator <tt>operator++()</tt> ponieważ
wyposażone są w niego wszystkie iteratory kontenerów z STL. To
właśnie jest zresztą podstawowa rola iteratora: przechodzenie do
kolejnych elementów, semantyka wskaźnika to już wybór twórcow STL.
</p>

<h2>Implementacje</h2>
<hr />

<p>Widać, że różnorodność inteligentnych wskaźników może przyprawić o
zawrót głowy. A nie rozważyliśmy jeszcze wszystkich kwestii
dotyczących ich zachowania. Wyczerpująca dyskusja na ten
temat znajduje się w A. Alexandrescu <i>"Nowoczesne projektowanie"</i>. Tam też podana jest
implemenatcja uniwersalnego szablonu klasy inteligentnego wskaźnika
parametryzowanego kilkoma klasami wytycznymi. Alternatywą jest użycie
szeregu klas (szablonów) implementujacych jeden typ wskaźnika każda.
Zbiór takich klas można znaleźć w bibliotece <tt>boost()</tt>.
Bardzo dobre opisy implementacji inteligentnych wskaźników znajdują
się również w D. Vandevoorde, N. Josuttis: <i>"C++ Szablony, Vademecum profesjonalisty"</i> i S. Meyers <i>"Język C++ bardziej efektywny"</i>.
</p><p>Tutaj dla przykładu zaprezentuję implementację wskaźnika zliczającego
referencję paramtryzowanego jedną klasą wytyczną. Jest to podejście
zbliżone do D. Vandevoorde, N. Josuttis: <i>"C++ Szablony, Vademecum profesjonalisty"</i>.
</p>

<h2>Zliczanie  referencji</h2>
<hr />

<p>Implementacje zliczania referencji różnią się przede wszystkim
miejscem, w którym umieszczony zostanie licznik. Dwie główne możliwości
to wewnątrz lub na zewnątrz obiektu, na który wskazujemy. Pierwsza
możliwość jest ewidentnie możliwa tylko wtedy, jeśli mamy dostęp do
kodu tej klasy. W każdej z tych dwu grup  mamy dalsze możliwości, np.
</p>


<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-10-6.png" alt="Rysunek 10.6. Wskaźniki ze współdzieleniem referencji." title="Rysunek 10.6. Wskaźniki ze współdzieleniem referencji."  class="image image-_original " width="344" height="492" /><span class="caption"><strong>Rysunek 10.6. Wskaźniki ze współdzieleniem referencji.</strong></span></span>

<ol><li> Obiekt wskazywany udostępnia miejsce na licznik, zarządzaniem licznikiem zajmuje się wskaźnik
</li><li> Obiekt wskazywany udostępnia nie tylko licznik, ale i interfejs do zarządzania nim.
</li><li> <span id="prz.3"></span>Licznik jest osobnym obiektem. Każdy wskaźnik posiada wskaźnik na obiekt wskazywany i wskaźnik na licznik (zob. rysunek 10.6).
</li><li><span id="prz.4"></span> Licznik jest osobnym obiektem który zawiera również wskaźnik do obiektu wskazywanego. Każdy wskaźnik zawiera tylko wskaźnik do licznika (zob. rysunek 10.6).
</li><li> Nie ma licznika, wskaźniki do tego samego obiektu połączone są w listę (zob. rysunek 10.6). 
</li></ol>

<p>Pokażę teraz przykladową implementację szablonu wskaźnika
parametryzowanego jedną klasą wytyczną, określającą którąś z powyższych
strategii, aczkolwiek przy jednej wytycznej jest to wysiłek, który
pewnie sie nie opłaca, jako że kod wspólny jest dość mały. Ale
implementacja ta może stanowić podstawę do rozszerzenia o kolejne
wytyczne. 
</p><p>Najpierw musimy się zastanowić nad interfejsem lub raczej konceptem
klasy wytycznej. W sumie najłatwiej to zrobić implemetując konkretną
wytyczną. Zaczniemy od osobnego zewnętrznego licznika (zob. strategia 3). Klasa wytyczna musi zawierać wskaźnik do wspólnego licznika:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T&gt; <span style="color: #0000ff;">struct</span> Extra_counter_impl <span style="color: #000000;">&#123;</span>
...
<span style="color: #0000ff;">private</span>:
  <span style="color: #0000ff;">size_t</span> *_c;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>i funkcje zwiekszające i zmniejszające licznik:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">  <span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">bool</span> remove_ref<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>    <span style="color: #000000;">&#123;</span>--<span style="color: #000000;">&#40;</span>*_c<span style="color: #000000;">&#41;</span>;return *_c==<span style="color: #0000dd;">0</span>;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> add_ref<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>       <span style="color: #000000;">&#123;</span>++<span style="color: #000000;">&#40;</span>*_c<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">size_t</span> count<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> *_c;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Funkcja zmniejszająca licznik zwraca prawdę, jeśli usunięta została
ostatnia referencja do wskazywanego obiektu. Potrzebna też będzie
funkcja niszcząca licznik:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> cleanup<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000dd;">delete</span> _c;
  _c=<span style="color: #0000dd;">0</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Potrzebne będą dwa konstruktory: defaultowy, który nic nie robi: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Extra_counter_impl<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_c<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>                    <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>i konstruktor inicjalizujący licznik obiektu powstającego po raz pierwszy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Extra_counter_impl<span style="color: #000000;">&#40;</span>T* p<span style="color: #000000;">&#41;</span>:_c<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> <span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>*_c=<span style="color: #0000dd;">0</span>;<span style="color: #000000;">&#125;</span>;</pre></div>

<p>który przydziela pamięć dla licznika. Argument <tt>T* p</tt> służy tylko
do rozróżnienia tych konstruktorów. 
</p><p>Korzystając z tej klasy nietrudno jest napisać szablon inteligentnego
wskaźnika. Obiekt licznika może być składową tego szablonu lub możemy
dziedziczyć z klasy wytycznej (zob. wykład 7). Niestety, okaże się, że bedziemy mieli problem próbując zaimplementować inne strategie, w szczególności strategię w której licznik i wskaźnik na obiekt wskazywany znajdują się w tym samym obiekcie (zob. strategia 4). Dlatego zmienimy trochę naszą implementację wytycznej i założymy, że obiekty tej klasy będą zawierać również wskaźnik na obiekt wskazywany 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T *_p;</pre></div>

<p>i dodamy funkcję:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T* pointee<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _p;<span style="color: #000000;">&#125;</span></pre></div>

<p>Musimy jeszcze poprawić funkcję czyszczącą:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> cleanup<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000dd;">delete</span> _c;
  <span style="color: #0000dd;">delete</span> _p;
  _p=<span style="color: #0000dd;">0</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: ref_ptr.h)
</p><p>i jeden z konstruktorów:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Extra_counter_impl<span style="color: #000000;">&#40;</span>T* p<span style="color: #000000;">&#41;</span>:_c<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> <span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span>,_p<span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>*_c=<span style="color: #0000dd;">0</span>;<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Szablon wskaźnika korzystający z tak zdefiniowanej klasy wytycznej może 
wyglądać następująco:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,
         <span style="color: #0000ff;">typename</span> counter_impl = Extra_counter_impl&lt;T&gt;  &gt; 
<span style="color: #0000ff;">class</span> Ref_ptr <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  Ref_ptr<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  Ref_ptr<span style="color: #000000;">&#40;</span>T *p<span style="color: #000000;">&#41;</span>:_c<span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    _c.<span style="color: #00eeff;">add_ref</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>;
&nbsp;
  ~Ref_ptr<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>detach<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
&nbsp;
  Ref_ptr<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Ref_ptr &amp;p<span style="color: #000000;">&#41;</span>:_c<span style="color: #000000;">&#40;</span>p._c<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    _c.<span style="color: #00eeff;">add_ref</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  Ref_ptr &amp;operator=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Ref_ptr &amp;rhs<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">this</span>!=&amp;rhs<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      detach<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
      _c=rhs._c;
      _c.<span style="color: #00eeff;">add_ref</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #000000;">&#125;</span>
    <span style="color: #0000ff;">return</span> *<span style="color: #0000dd;">this</span>;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  T* operator-&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _c.<span style="color: #00eeff;">pointee</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
  T &amp;operator*<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> *<span style="color: #000000;">&#40;</span>_c.<span style="color: #00eeff;">pointee</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">size_t</span> count<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _c.<span style="color: #00eeff;">count</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">private</span>:
  mutable counter_impl _c;
  <span style="color: #0000ff;">void</span> detach<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>      
    <span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>_c.<span style="color: #00eeff;">remove_ref</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span> _c.<span style="color: #00eeff;">cleanup</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: ref_ptr.h)
</p>

<h2>auto_ptr</h2>

<p>Implementacja wskaźnika <tt>auto_ptr</tt> oparta jest o dwie funkcje.
Jedna zwalnia przechowywany wskaźnik zwracając go na zewnątrz i
oddając własność:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">T* release<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span>
  T *oldPointee = pointee;
  pointee = <span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">return</span> oldPointee;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: auto_ptr.h)
</p><p><tt>pointee</tt> jest przechowywanym (zwykłym) wskaźnikiem.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">private</span>:
  T *pointee;</pre></div>

<p>Druga funkcja zamienia przechowywany wskaźnik na inny, zwalniając 
wskazywaną przez niego pamięć: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> reset<span style="color: #000000;">&#40;</span>T *p = <span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>pointee!= p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000dd;">delete</span> pointee;
    pointee = p;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: auto_ptr.h)
</p><p>Za pomocą tych funkcji można już łatwo zimplementować resztę szablonu, np.:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;class T&gt; <span style="color: #0000ff;">class</span> auto_ptr <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">explicit</span> auto_ptr<span style="color: #000000;">&#40;</span>T *p = <span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>: pointee<span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>
&nbsp;
  template&lt;class U&gt;
  auto_ptr<span style="color: #000000;">&#40;</span>auto_ptr &lt;U&gt; &amp; rhs<span style="color: #000000;">&#41;</span>: pointee<span style="color: #000000;">&#40;</span>rhs.<span style="color: #00eeff;">release</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>
&nbsp;
  ~auto_ptr<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> <span style="color: #0000dd;">delete</span> pointee; <span style="color: #000000;">&#125;</span>
&nbsp;
  template&lt;class U&gt; 
  auto_ptr&lt;T&gt;&amp; operator=<span style="color: #000000;">&#40;</span>auto_ptr&lt;U&gt;&amp; rhs<span style="color: #000000;">&#41;</span>
  <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">this</span> != &amp;rhs<span style="color: #000000;">&#41;</span> reset<span style="color: #000000;">&#40;</span>rhs.<span style="color: #00eeff;">release</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">return</span> *<span style="color: #0000dd;">this</span>;
  <span style="color: #000000;">&#125;</span>
&nbsp;
  T&amp; operator*<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span> <span style="color: #0000ff;">return</span> *pointee; <span style="color: #000000;">&#125;</span>
  T* operator-&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span> <span style="color: #0000ff;">return</span> pointee; <span style="color: #000000;">&#125;</span>
  T* get<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span> <span style="color: #0000ff;">return</span> pointee; <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: auto_ptr.h)
</p><p>Konstruktor kopiujący i operator przypisania są szablonami, w ten
sposób można kopiować również wskaźniki <tt>auto_ptr</tt> opakowujące
typy, które mogą być na siebie rzutowane, np. można przypisać
<tt>auto_ptr<Derived></derived></tt> do <tt>auto_ptr<Base /></tt>, jeśli <tt>Derived</tt>
dziedziczy publicznie z <tt>Base</tt>. Konstruktor <tt>auto_ptr(T *p =
0)</tt> został zadeklarowany jako <tt>explicit</tt>, wobec czego nie 
spowoduje niejawnej konwresji z typu <tt>T*</tt> na <tt>auto_ptr<T></t></tt>. 
</p><p>Różne impelentacje <tt>auto_ptr</tt> różnią się szczegółami dotyczącymi
obsługi <tt>const auto_ptr</tt> i przekazywania <tt>auto_ptr</tt> przez stałą
referencję. Powyższa implentacja wzięta z S. Meyers <i>"Język C++ bardziej efektywny"</i>, nie posiada pod tym względem żadnych zabezpieczeń. Szczegółowa dyskusja
tego zagadnienia i bardziej zaawansowana implementacja znajduje się w
N.M. Josuttis: <i>"C++ Biblioteka standardowa, podręcznik programisty"</i>. Temat ten jest też poruszony w D. Vandevoorde, N. Josuttis: <i>"C++ Szablony, Vademecum profesjonalisty"</i>.
Warto też zaglądnąć do implementacji <tt>auto_ptr</tt> dostarczonej z
kompilatorem <tt>g++</tt>.
</p>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Auto_ptr.cpp">Auto_ptr.cpp</a></td><td>487 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Out.cpp">Out.cpp</a></td><td>731 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Pre_post.cpp">Pre_post.cpp</a></td><td>721 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Ref_ptr.h">Ref_ptr.h</a></td><td>2.95 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Auto_ptr.h">Auto_ptr.h</a></td><td>800 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1247" class="section-2">
  <h1 class="book-heading">Funktory</h1>
  <h2>Wstęp</h2>
<hr />
<br />

<p>Na poprzednim wykładzie prezentowane były inteligentne wskaźniki,
czyli obiekty, które rozszerzają pojęcie zwykłego wskaźnika.  Na tym
wykładzie będę omawiał obiekty, które stanowią rozszerzenie pojęcia
wskaźnika do funkcji. Motywacja wprowadzenia takich obiektów
funkcyjnych jest jednak inna. Funkcje obiektami <b>nie</b> są i
wskaźniki do nich nie mają kłoptów z prawami własności,
współdzieleniem referencji, itp. Same wskaźniki do funkcji są obiektami
ale typów wbudowanych (lub raczej typów złożonych).  Możemy je
kopiować, przepisywać, przekazywać do funkcji, ale nie mamy nad tym
kontroli.
</p><p>Obiekty funkcyjne posiadaja składnię wywołania funkcji, ale są też
pełnoprawnymi obiektami, mogą więc posiadać stan, konstruktory,
destruktory i inne metody, jak również typy stowarzyszone, no i
oczywiście posiadają też swój własny typ. Te dodatkowe informacje
pozwalają na implementowanie wielu ciekawych rozwiązań niedostępnych
dla zwykłych funkcji i wskaźników do nich.
</p>

<h2>Funkcje, wskaźniki i referencje  do funkcji</h2>
<hr />
<br />

<h3>Typy funkcyjne</h3>
<br />
<p>Zanim zajmiemy się bardziej skomplikowanymi obiektami jakimi są
funktory, chciałbym najpierw wyjaśnić kilka faktów dotyczących funkcji
i wskaźników do nich. Jak już wspomniałem w poprzednim podrozdziale
funkcje nie są obiektami. Nie można ich kopiować ani przypisywać do
siebie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
<span style="color: #0000ff;">void</span>  g<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> = f; &lt;i&gt;niedozwolone&lt;/i&gt;
<span style="color: #0000ff;">void</span> h<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>;
h=f; &lt;i&gt;niedozwolone&lt;/i&gt;</pre></div>

<p>Funkcje posiadają jednak typ. Typ funkcji (nazywany typem funkcyjnym)
jest określony przez typ jej wartości zwracanej i typy jej argumentów.
Typy funkcyjne możemy używać np. w poleceniu <tt>typedef</tt>. Wyrażenie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">void</span> f_type<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span></pre></div>

<p>definiuje <tt>f_type</tt> jako typ funkcji o jednym argumencie typu <tt>double</tt>
i nie zwracającej żadnej wartości. Taki typ ma jednak ograniczone zastosowanie,
możemy go używać do deklarowania, ale nie definiowania innych funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">f_type g;</pre></div>

<p>Typ funkcyjny może też być użyty jako parametr szablonu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename F&gt; Function <span style="color: #000000;">&#123;</span>
F _fun;
<span style="color: #000000;">&#125;</span>;
Function&lt;void <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&gt;</pre></div>

<p>Niewiele jednak będziemy mieli pożytku z pola <tt>_fun</tt>, bo jak już
widzieliśmy, nie będziemy w stanie nic do niego przypisać ani go
zainicjalizować.
</p><p>Możemy również używać typów funkcyjnych w deklaracjach argumentów funkcji. Wyrażenie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">double</span> sum<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>,...<span style="color: #000000;">&#41;</span></pre></div>

<p>oznacza że funkcja <tt>sum</tt> oczekuje jako pierwszego argumentu funkcji
zwracającej <tt>double</tt> o jednym argumencie typu <tt>double</tt>. Ten
zapis jest jednak mylący! W rzeczywistości nie można przekazać
funkcji jako argumentu wywołania i dlatego w deklaracjach argumentów typ
funkcyjny jest automatycznie zamieniany na typ wskaźnika do funkcji i
powyższa deklaracja jest równoważna deklaracji: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">double</span> sum<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>,...<span style="color: #000000;">&#41;</span></pre></div>

<h3>Wskaźniki do funkcji</h3>
<br />

<p>Wskaźniki do funkcji są normalnymi obiektami i mogą być kopiowane i
przypisywane:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
<span style="color: #0000ff;">void</span>  <span style="color: #000000;">&#40;</span>*g<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> = &amp;f;
<span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*h<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>;
h=&amp;f;
<span style="color: #000000;">&#40;</span>*h<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0.0</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#40;</span>*g<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>C++ posiada wygodną własność, która jednak zwiększa konfuzję pomiędzy 
funkcjami i wskaźnikami do nich. Otóż operatory <tt>*</tt> i <tt>&</tt> są 
aplikowane automatycznie  do funkcji i powyższy kod można zapisać jako:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
<span style="color: #0000ff;">void</span>  <span style="color: #000000;">&#40;</span>*g<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> = f;
<span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*h<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>;
h=&amp;f;
h<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0.0</span><span style="color: #000000;">&#41;</span>;
g<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Jest to dość wygodne, ale powoduje, że część ludzi słabo rozróżnia
funkcje od wskaźników do nich (Państwo oczywiście już do nich nie należą:).
</p>

<h3>Referencje do funkcji</h3>
<br />

<p>Żeby już skończyć ten temat i zupełnie zamieszać Państwu w głowach
napiszę, że można też definiować referencje do funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">void</span> f_type<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>
&nbsp;
f_type  &amp;g  = f; 
f_type  &amp;h  = g;
<span style="color: #0000ff;">const</span> f_type  &amp;ch = g; &lt;i&gt;równoważne z wyrażeniem f_type &amp;ch  = g;&lt;/i&gt;
h=g; &lt;i&gt;niedozwolone  h jest refencją <span style="color: #0000ff;">do</span> stałej&lt;/i&gt;</pre></div>

<p>Należy dodać, że typ <tt>const f_type &</tt> nie jest obsługiwany
przez kompilator <tt>g++-3.3</tt> ale przez <tt>g++-3.4</tt> już tak.
</p>

<h3>Dedukcja typów  funcyjnych</h3>
<br />

<p>Ponieważ funktory i funkcje często przekazywane są jako argumenty
wywołania szablonów, których typ podlega dedukcji, warto wiedzieć jak
ten mechanizn rozpoznaje typ przekazywanej funkcji.
Rozważmy najpierw następujacą  definicję:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename  F&gt; test<span style="color: #000000;">&#40;</span>F f<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  F _fun<span style="color: #000000;">&#40;</span>f<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Jeśli teraz wywołamy 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"> <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*g<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> = f;
 <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>&amp;h<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> = f;
&nbsp;
test<span style="color: #000000;">&#40;</span>f<span style="color: #000000;">&#41;</span>;          &lt;i&gt;F = <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&lt;/i&gt;
test<span style="color: #000000;">&#40;</span>g<span style="color: #000000;">&#41;</span>;          &lt;i&gt;F = <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&lt;/i&gt;
test<span style="color: #000000;">&#40;</span>h<span style="color: #000000;">&#41;</span>;          &lt;i&gt;F = <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&lt;/i&gt;</pre></div>

<p>to w każdym przypadku typ <tt>F</tt> zostanie wydedukowany jako 
wskaźnik do funkcji <tt>void (*)(double)</tt>. 
</p><p>Jeśli przypomnimy sobie, że argumenty do funkcji można dla oszczędności
przekazywać jako referencje do stałych, to możemy napisać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename  F&gt; test<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> F &amp;f<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  F _fun<span style="color: #000000;">&#40;</span>f<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>czeka nas jednak niepospodzianka, kod
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"> <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*g<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> = f;
 <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>&amp;h<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> = f;
&nbsp;
test<span style="color: #000000;">&#40;</span>f<span style="color: #000000;">&#41;</span>;          &lt;i&gt;F = <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>, nie skompiluje  się&lt;/i&gt;
test<span style="color: #000000;">&#40;</span>g<span style="color: #000000;">&#41;</span>;          &lt;i&gt;F = <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&lt;/i&gt;
test<span style="color: #000000;">&#40;</span>h<span style="color: #000000;">&#41;</span>;          &lt;i&gt;F = <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> nie skompiluje się&lt;/i&gt;</pre></div>

<p>zachowuje się już inaczej. W przypadku przekazania funkcji lub
referencji do funkcji, wededukowanym typem będzie typ funkcyjny.
Ponieważ nie można inicjalizować zmiennych typu funkcyjnego, wyrażenie
<tt>F _fun(f)</tt> się nie skompiluje. Nie będzie kłopotów jeśli
przekażemy wskaźnik do funkcji, ale tym razem musimy to zrobić jawnie,
nie nastąpi automatyczna konwersja nazwy funkcji na wskaźnik do niej.
</p><p>Można by przedefiniować funkcję <tt>test</tt> następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename  F&gt; test<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> F &amp;f<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  F *_fun<span style="color: #000000;">&#40;</span>f<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Teraz wywołania 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">test<span style="color: #000000;">&#40;</span>f<span style="color: #000000;">&#41;</span>;          &lt;i&gt;F = <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&lt;/i&gt;
test<span style="color: #000000;">&#40;</span>h<span style="color: #000000;">&#41;</span>;          &lt;i&gt;F = <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&lt;/i&gt;</pre></div>

<p>skompilują się, ale nie skompiluje się linijka
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">test<span style="color: #000000;">&#40;</span>g<span style="color: #000000;">&#41;</span>;          &lt;i&gt;F = <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&lt;/i&gt;</pre></div>

<p>bo pole <tt>_fun</tt> stanie się typu <tt>void (**)(double)</tt>. Kompilator <tt>g+-3.3</tt> nawet tego kodu nie skompiluje, bo nie zezwala na referencje do stałych typów funkcyjnych.
</p><p>Widać więc, że przy przekazywaniu funkcji najlepiej używać
wywołania przez wartość, która i tak jest automatycznie konwertowana
na przekazywanie wskaźnika do funkcji.
</p>

<h2>Obiekty funkcyjne</h2>
<hr />
<br />

<p>Definiowanie własnych obiektów funkcyjnych jest możliwe dzięki
możliwości przeładowania operatora wywołania (będziemy go też nazywać
operatorem nawiasów): <tt>operator()(...)</tt>.  Np.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> <span style="color: #0000dd;">Sin</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">sin</span><span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>

<p>Z obiektów typu <tt>Sin</tt> możemy teraz korzystać jak z funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000dd;">Sin</span> c_sin;
c_sin<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Nie jest to być może porywający przykład, ale głównym powodem używania
obiektów funkcyjnych jest to, że mogą posiadać stan. Skorzystamy z tego,
aby umożliwić wybór typu argumentu funkcji <tt>sin</tt>. Zwyczajowo
kalkulatory (ktoś wie co to jest?) zezwalają na podawanie argumentów
funkcji trygonometrycznych w radianach, stopniach lub gradusach.
Możemy to zaimplemetować następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> <span style="color: #0000dd;">Sin</span> <span style="color: #000000;">&#123;</span> 
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">enum</span> arg <span style="color: #000000;">&#123;</span>radian,degree,grad<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000dd;">Sin</span><span style="color: #000000;">&#40;</span>arg s = radian<span style="color: #000000;">&#41;</span>:_state<span style="color: #000000;">&#40;</span>s<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">void</span> set_radians<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> _state=radian;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> set_degrees<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_state=degree;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> set_grads<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>   <span style="color: #000000;">&#123;</span>_state=grad;<span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">sin</span><span style="color: #000000;">&#40;</span>conv<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">private</span>:
  arg _state;
  <span style="color: #0000ff;">double</span> conv<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">switch</span> <span style="color: #000000;">&#40;</span>_state<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">case</span> radian: <span style="color: #0000ff;">return</span> x;
    <span style="color: #0000ff;">case</span> degree: <span style="color: #0000ff;">return</span> x*<span style="color: #000000;">&#40;</span>M_PI/<span style="color: #0000dd;">180.0</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">case</span> grad  : <span style="color: #0000ff;">return</span> x*<span style="color: #000000;">&#40;</span>M_PI/<span style="color: #0000dd;">200.0</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #000000;">&#125;</span>
  <span style="color: #000000;">&#125;</span>  
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: sin.cpp)
</p><p>Nie jest to najwydajniejsza implementacja, bo za każdym wywołaniem
funkcji <tt>sin</tt> wykonywana jest insrukcja <tt>switch</tt>. Przerobimy ją
więc na:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> BetterSin <span style="color: #000000;">&#123;</span>  
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">enum</span> arg <span style="color: #000000;">&#123;</span>radian,degree,grad<span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">void</span> set_radians<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> _conv=&amp;BetterSin::<span style="color: #00eeff;">to_radians</span>;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> set_degrees<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> _conv=&amp;BetterSin::<span style="color: #00eeff;">to_degrees</span>;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">void</span> set_grads<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>   <span style="color: #000000;">&#123;</span> _conv=&amp;BetterSin::<span style="color: #00eeff;">to_grads</span>;<span style="color: #000000;">&#125;</span>
&nbsp;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">sin</span><span style="color: #000000;">&#40;</span> <span style="color: #000000;">&#40;</span>this-&gt;*_conv<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
&nbsp;
  BetterSin<span style="color: #000000;">&#40;</span>arg s = radian<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">switch</span> <span style="color: #000000;">&#40;</span>s<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">case</span> radian: set_radians<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;break;
    <span style="color: #0000ff;">case</span> degree: set_degrees<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;break;
    <span style="color: #0000ff;">case</span> grad  : set_grads<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;break;
    <span style="color: #000000;">&#125;</span>
  <span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">private</span>:
  <span style="color: #0000ff;">double</span> <span style="color: #000000;">&#40;</span>BetterSin::<span style="color: #00eeff;">*</span> _conv<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">double</span> to_radians<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> x;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> to_degrees<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> x*<span style="color: #000000;">&#40;</span>M_PI/<span style="color: #0000dd;">180.0</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> to_grads<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> x*<span style="color: #000000;">&#40;</span>M_PI/<span style="color: #0000dd;">200.0</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: sin.cpp)
</p>
<h3>Wskaźniki do metod (funkcji składowych)</h3>
<br />

<p>Ten przykład, który powinien działać szybciej, ilustruje ponadto
użycie wskaźników do funkcji składowych (metod).  Różnice pomiędzy
wskaźnikami do funkcji i wskaźnikami do metod są opisane w D. Vandervoorde, N. Josuttis: <i>"C++ Szablony, Vademecum profesjonalisty"</i> oraz S. B. Lippman <i>"Model obiektu w C++"</i>, tutaj zwrócę tylko uwagę na różnice w ich używaniu.  Jak już pisałem wskaźniki do funkcji można
używać na skróty, bez jawnego wywoływania operatorów <tt>&</tt> i <tt>*</tt>.
W przypadku wskaźników do metod, musimy pobierać adres jawnie i
dereferencjonować go przed wywołaniem. Ponadto każda metoda ma dodatkowy
niejawny argument, którym jest wskaźnik na obiekt, przez który została
ona wywołana, dlatego wywołując metodę poprzez wskaźnik też musimy ten
argument podać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> X <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>std::<span style="color: #00eeff;">cout</span>&lt;&lt;<span style="color: #666666;">&quot;f1&quot;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>X::<span style="color: #00eeff;">*f_ptr</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #ff0000;">//f_ptr pf1=X::f; bład kompilacji</span>
  f_ptr pf1=&amp;X::<span style="color: #00eeff;">f</span>;
    X x;
  X *px = <span style="color: #0000dd;">new</span> X;
    <span style="color: #000000;">&#40;</span>x.<span style="color: #00eeff;">*pf1</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #000000;">&#40;</span>px-&gt;*pf1<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: m_ptr.cpp)
</p>

<h3>Adaptery funktorów</h3>
<br />

<p>Obiekty mogą jednak posiadać więcej informacji niż tylko swój stan,
mogą zawierać również informacje o typie. Przede wszystkim funktory same
posiadają typ, konsekwencje tego faktu omówię poźniej, teraz zajmę się
typami stowarzyszonymi. Nasuwająca się od razu możliwość, to
stowarzyszenie z funktorem typu wartości zwracanej oraz typów jego
argumentów. Można stowarzyszyć również informację o liczbie
argumentów. W przypadku szablonu <tt>Sin</tt> i <tt>BetterSin</tt> moglibyśmy dodać
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">double</span> result_type;
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">double</span> argument_type;
<span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>n_arguments = <span style="color: #0000dd;">1</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>Taki schemat nazewnictwa nie najlepiej się rozszerza na większą ilość
argumentów, ale właśnie takie definicje typów są wymagane dla
jednoargumentowych obiektów funkcyjnych w STL. W celu ułatwienia
tworzenia własnych funktorów spełniających te wymagania, dostarczony
jest szablon klasy, z której można dziedziczyć:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class Arg1, <span style="color: #0000ff;">class</span> Arg2, <span style="color: #0000ff;">class</span> Result&gt;
<span style="color: #0000ff;">struct</span> binary_function <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> Arg1 first_argument_type;
<span style="color: #0000ff;">typedef</span> Arg2 second_argument_type;
<span style="color: #0000ff;">typedef</span> Result result_type;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>czyli moglibyśmy również napisać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> BetterSin: <span style="color: #0000ff;">public</span> unary_function&lt;double,double&gt; <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;</pre></div>

<p>STL nie wymaga definiowania liczby argumentów. 
</p><p>Podobnie zdefiniowany jest szablon dla funkcji dwuargumentowych: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class Arg1, <span style="color: #0000ff;">class</span> Arg2, <span style="color: #0000ff;">class</span> Result&gt;
<span style="color: #0000ff;">struct</span> binary_function <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> Arg1 first_argument_type;
<span style="color: #0000ff;">typedef</span> Arg2 second_argument_type;
<span style="color: #0000ff;">typedef</span> Result result_type;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Opis bardziej uniwersalnego schematu obiektów funkcyjnych,
uwzględniający funktory z dowolną ilością argumentów znajduje się w D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i>. Dodajmy, że do określenia typów argumentów można użyć listy typów przedstawione w   wykładzie 6.3, razem z szablonem indeksowania (zob. A. Alexandrescu <i>"Nowoczesne projektowanie w C++"</i>). 
</p><p>My jednak pozostaniemy na razie przy schemacie z STL. Trzeba
jasno powiedzieć, że obiekty funkcyjne używane przez algorytmy STL nie
muszą posiadać wymienionych typów stowarzyszonych, w szczególności
mogą to być zwykłe funkcje. Ale jeśli takie typy posiadają, to można
używać ich w adapterach funkcji.
</p><p>Adaptery funkcji to funktory, które w jakiś sposób modyfikują działanie
innych funktorów.  STL definiuje dość skromny wybór adapterów, ale na
szczęście istnieje wiele innych niezależnych źródeł, w szczególności
SGI i <tt>boost</tt>.
</p><p>Jak działają adaptery wyjaśnię na przykładzie adaptera <tt>binder1st</tt>
z STL. <tt>binder1st</tt> reprezentuje funktor jednoargumentowy, powstały
przez zastąpienie pierwszego argumentu podanego funktora
dwuargumentowego podaną wartością. Rozważmy następujący przykład:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Cov:<span style="color: #0000ff;">public</span> std::<span style="color: #00eeff;">binary_function</span>&lt;double,<span style="color: #0000ff;">double</span>,double&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">double</span> _ax,_ay,_axy;
<span style="color: #0000ff;">public</span>: 
  Cov<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> ax,<span style="color: #0000ff;">double</span> ay,<span style="color: #0000ff;">double</span> axy<span style="color: #000000;">&#41;</span>:_ax<span style="color: #000000;">&#40;</span>ax<span style="color: #000000;">&#41;</span>,_ay<span style="color: #000000;">&#40;</span>ay<span style="color: #000000;">&#41;</span>,_axy<span style="color: #000000;">&#40;</span>axy<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x,<span style="color: #0000ff;">double</span> y<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _ax*x*x+_ay*y*y+_axy*x*y;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  Cov f<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,<span style="color: #0000dd;">2.0</span>,<span style="color: #0000dd;">2.0</span><span style="color: #000000;">&#41;</span>;
&nbsp;
  std::<span style="color: #00eeff;">cout</span>&lt;&lt;f<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,<span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
  std::<span style="color: #00eeff;">cout</span>&lt;&lt;f<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,<span style="color: #0000dd;">2.0</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
&nbsp;
  std::<span style="color: #00eeff;">cout</span>&lt;&lt;::<span style="color: #00eeff;">bind1st</span><span style="color: #000000;">&#40;</span>f,<span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
  std::<span style="color: #00eeff;">cout</span>&lt;&lt;::<span style="color: #00eeff;">bind1st</span><span style="color: #000000;">&#40;</span>f,<span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2.0</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: bind.cpp)
</p><p>Działanie adaptera nietrudno zrozumieć, jeśli się zrozumiało działanie
szablonów wyrażeń (zob. wykład 9). Szablon <tt>binder1st</tt> można zdefiniować następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename F&gt; <span style="color: #0000ff;">class</span> binder1st <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span>  <span style="color: #0000ff;">typename</span> F::<span style="color: #00eeff;">first_argument_type</span>  bind_type;
  <span style="color: #0000ff;">typedef</span>  <span style="color: #0000ff;">typename</span> F::<span style="color: #00eeff;">second_argument_type</span> first_argument_type;
  <span style="color: #0000ff;">typedef</span>  <span style="color: #0000ff;">typename</span> F::<span style="color: #00eeff;">result_type</span> result_type;
&nbsp;
  <span style="color: #0000ff;">const</span> bind_type _val;
  F _op;
  <span style="color: #0000ff;">public</span>:
  binder1st<span style="color: #000000;">&#40;</span>F op,bind_type val<span style="color: #000000;">&#41;</span>:_op<span style="color: #000000;">&#40;</span>op<span style="color: #000000;">&#41;</span>, _val<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  result_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>first_argument_type x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> op<span style="color: #000000;">&#40;</span>_val,x<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: bind.cpp)
</p><p>Podobnie jak w przypadku szablonów wyrażeń, będziemy jeszcze
potrzebowali funkcji, która wytworzy nam taki obiekt. To zadanie spełni
nam funkcja <tt>bind1st</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename F&gt; 
binder1st&lt;F&gt; 
bind1st<span style="color: #000000;">&#40;</span>F op,<span style="color: #0000ff;">typename</span> F::<span style="color: #00eeff;">first_argument_type</span> val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">return</span> binder1st&lt;F&gt;<span style="color: #000000;">&#40;</span>op,val<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: bind.cpp)
</p><p>Na podstawie tego przykładu mam nadzieję, że już łatwo Państwu będzie
wywnioskować implementację pozostałych adapterów STL: <tt>binder2nd</tt>,
<tt>unary_negate</tt> i <tt>binary_negate</tt>. 
</p><p>STL dostarcza ponadto dodatkowe adaptery, które opakowują zwykłe
wskaźniki do funkcji i wskaźniki do metod tak, aby można było ich użyć
razem z adapterami obiektów.
</p>

<h3>Składanie funktorów</h3>

<p>Żaden z adapterów zaimplementowanych w STL nie umożliwia składania
funktorów, czyli tworzenia funktora poprzez połączenie dwu lub wiecej
innych funktorów. Oczywiście istnieje wiele możliwych sposobów
składania funkcji, w N.M. Josuttis <i>"C++ Biblioteka standardowa, podręcznik programisty"</i> autor wyróżnia pięć 
takich adapterów realizujących następujące złożenia:
</p>

<div align="center">
<table border="1">

<tr>
<td align="center"> \(\displaystyle f(g(x))\)       </td><td> (<tt>unary_compose</tt>)
</td></tr>
<tr>
<td align="center"> \(\displaystyle f(g(x,y))\)     </td><td>
</td></tr>
<tr>
<td align="center"> \(\displaystyle f(g(x),h(x))\)  </td><td> (<tt>binary_compose</tt>)
</td></tr>
<tr>
<td align="center"> \(\displaystyle f(g(x),h(y))\)  </td><td>
</td></tr></table>
</div>
<p>Dwa z nich (<tt>unary_compose</tt> i <tt>binary_compose</tt>) są zdefiniowane w
implementacji STL firmy SGI, a więc dostępne razem z kompilatorem <tt>g++</tt>.
</p><p>Implementacja ich jest analogiczna do implementacji <tt>binder1st</tt>, ale 
dla wprawy podam tu możliwą implementację złożenia \(\displaystyle f(g(x,y))\). 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename F,<span style="color: #0000ff;">typename</span> G&gt; <span style="color: #0000ff;">class</span> compose_f_gxy_t <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> F::<span style="color: #00eeff;">result_type</span> result_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> G::<span style="color: #00eeff;">first_argument_type</span>  first_argument_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> G::<span style="color: #00eeff;">second_argument_type</span>  second_argument_type;
&nbsp;
  F _f;
  G _g;
&nbsp;
<span style="color: #0000ff;">public</span>:
  compose_f_gxy_t<span style="color: #000000;">&#40;</span>F f,G g<span style="color: #000000;">&#41;</span>:_f<span style="color: #000000;">&#40;</span>f<span style="color: #000000;">&#41;</span>,_g<span style="color: #000000;">&#40;</span>g<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  result_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>first_argument_type x,
                         second_argument_type y<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> _f<span style="color: #000000;">&#40;</span>_g<span style="color: #000000;">&#40;</span>x,y<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
&nbsp;
<span style="color: #000000;">&#125;</span>;
&nbsp;
template&lt;typename F,<span style="color: #0000ff;">typename</span> G&gt; 
compose_f_gxy_t&lt;F,G&gt;
compose_f_gxy<span style="color: #000000;">&#40;</span>F f,G g<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span>  compose_f_gxy_t&lt;F,G&gt;<span style="color: #000000;">&#40;</span>f,g<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;</pre></div>
<p>( Źródło: bind.cpp)

</p>

<p>
Używamy tego funktora następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">cout</span>&lt;&lt;compose_f_gxy<span style="color: #000000;">&#40;</span>
                         __gnu_cxx::<span style="color: #00eeff;">compose1</span><span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">ptr_fun</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">exp</span><span style="color: #000000;">&#41;</span>,
                                       std::<span style="color: #00eeff;">negate</span>&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>,
                         f<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,<span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;</pre></div>

<p>( Źródło: bind.cpp)

</p><p>Powyższe wyrażenie efektywnie produkuje funktor obliczający 
\(\displaystyle \exp(-f(x,y))\) gdzie \(\displaystyle f(x,y)= a_x x^2+a_y y^2+a_{xy}x*y\). 
Wykorzystaliśmy w nim szereg konstrukcji
</p>

<ol><li> Adapter realizujący złożenie dwu funkcji jednoargumentowych <tt>unary_compose</tt> (zwrócony przez funkcję <tt>compose1()</tt>) dostarczony  wraz z kompilatorem <tt>g++</tt>.
</li><li> Za pomocą tego adaptera złożyliśmy funkcję \(\displaystyle \exp\) ze standardowej biblioteki C z obiektem funkcyjnym <tt>std::negate<double></double></tt> predefiniowanym w STL.
</li><li> Aby móc użyć funkcji \(\displaystyle \exp\) w adapterze musiałem ją opakować za pomocą adaptera <tt>std::ptr_fun</tt>.
</li><li> Funkcję \(\displaystyle \exp(-f)\) złożyłem z \(\displaystyle f(x,y)\) za pomocą <tt>compose_f_gxy</tt>.  
</li></ol>

<p>Na powyższym przykładzie widać siłę, ale i też pewne niedogodności
używania funktorów, przynajmniej w takiej postaci, jak zdefiniowanej w
STL. Podany kod jest dość rozwlekły i mało czytelny, co gorsza, tak
zdefiniowanego funktora nie możemy łatwo przechować w jakiejś
zmiennej, bo jego typ też jest bardzo skomplikowany (zobacz zadania).
</p>

<h3>Klasy cech dla funktorów</h3>
<br />

<p>Programowanie uogólnione za pomocą funktorów mogłoby być prostsze
gdybyśmy posiadali jakiś uniwersalny sposób dostępu do informacji o
nich. Taki uniwersalny szkielet funktora z możliwościami introspekcji
jest opisany w D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i>, rozdz.22. Tutaj zaprezentuję tylko
możliwą implementację klasy cech dostarczającej informacji o
funktorach w stylu STL i wskaźnikach na funkcje. 
</p><p>Załóżmy, że mamy jakiś typ <tt>F</tt> i chcemy się dowiedzieć czy jest on
funktorem czy nie. W C++ nie mamy możliwości sprawdzić czy dana klasa
posiada operator nawiasów czy nie. Funktory będziemy więc rozpoznawać
po posiadanych typach stowarzyszonych. Skorzystamy z zasady
rozstrzygania przeciążenia szablonów funkcji: "nieudane podstawienie
nie jest błędem". Podobnie jak w przypadku szablonu <tt>Is_class</tt>
(zob. wykład 6.2.2) wykorzystamy dwa typy:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename F&gt; funktor_info <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">char</span> one;
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">struct</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">char</span> a<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span>;<span style="color: #000000;">&#125;</span> two;</pre></div>

<p>( Źródło: functor_type.h)
</p><p>i dwa szablony funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename C&gt; one test_arg<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">typename</span> C::<span style="color: #00eeff;">argument_type</span> *<span style="color: #000000;">&#41;</span> ;
template&lt;typename C&gt; two test_arg<span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span> ;</pre></div>

<p>( Źródło: functor_type.h)
</p><p>Za ich pomocą możemy sprawdzić czy dany typ <tt>F</tt> posiada zdefiniowany
stowarzyszony typ <tt>argument_type</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>has_argument = <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>test_arg&lt;F&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>one<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: functor_type.h)
</p><p>Podobnie możemy zdefiniować jeszcze trzy stałe logiczne:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>has_result = <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>test_res&lt;F&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>one<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>has_first_argument  = <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>test_arg1&lt;F&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>one<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>has_second_argument = <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>test_arg2&lt;F&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>==<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>one<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: functor_type.h)
</p><p>Pary funkcji <tt>test_...</tt> są zdefiniowane analogicznie do <tt>test_arg</tt>. 
Za pomocą tych stałych możemy wyrazić inne własności obiektu <tt>F</tt>, np:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>has_one_argument  = has_argument &amp;&amp; !has_first_argument 
       &amp;&amp; !has_second_argument<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>has_two_arguments = has_first_argument &amp;&amp; has_second_argument 
       &amp;&amp; !has_argument<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>has_no_arguments = !has_argument &amp;&amp; !has_first_argument 
       &amp;&amp; !has_second_argument<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>is_generator = has_result &amp;&amp; has_no_arguments<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>is_unary_function = has_result &amp;&amp; has_one_argument<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>is_binary_function = has_result &amp;&amp; has_two_arguments<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>is_functor = is_generator || is_unary_function || is_binary_function<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>is_function= <span style="color: #0000ff;">false</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: functor_type.h)
</p><p>Funkcje możemy rozpoznawać za pomocą specjalizacji częściowych:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename A1,<span style="color: #0000ff;">typename</span> A2 , <span style="color: #0000ff;">typename</span> R &gt; 
<span style="color: #0000ff;">struct</span> functor_info&lt;R <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>A1,A2<span style="color: #000000;">&#41;</span> &gt;<span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>has_result  = <span style="color: #0000ff;">true</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>has_argument  = <span style="color: #0000ff;">false</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>has_first_argument  = <span style="color: #0000ff;">true</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>has_second_argument  = <span style="color: #0000ff;">true</span><span style="color: #000000;">&#125;</span>;
... <span style="color: #00eeff;">tak</span> samo jak powyżej
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: functor_type.h)
</p><p>Podobnie dla funkcji zero- i jednoargumentowych. 
Mając już klasę <tt>functor_info</tt> można zdefiniować klasę 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename F,<span style="color: #0000ff;">int</span> n_args = functor_info&lt;F&gt;::<span style="color: #00eeff;">n_args</span>&gt; 
<span style="color: #0000ff;">struct</span> functor_traits ;</pre></div>

<p>i jej specjalizacje:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename F&gt; <span style="color: #0000ff;">struct</span> functor_traits&lt;F,<span style="color: #0000dd;">2</span>&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> F::<span style="color: #00eeff;">result_type</span> result_type; 
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> F::<span style="color: #00eeff;">first_argument_type</span>  arg1_type; 
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> F::<span style="color: #00eeff;">second_argument_type</span> arg2_type; 
  <span style="color: #0000ff;">typedef</span> std::<span style="color: #00eeff;">binary_function</span>&lt;arg1_type,arg2_type,result_type&gt; f_type;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>n_args=<span style="color: #0000dd;">2</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
template&lt;typename F&gt; <span style="color: #0000ff;">struct</span> functor_traits&lt;F,<span style="color: #0000dd;">1</span>&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> F::<span style="color: #00eeff;">result_type</span> result_type; 
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> F::<span style="color: #00eeff;">argument_type</span>  arg1_type; 
  <span style="color: #0000ff;">typedef</span> empty_type  arg2_type; 
  <span style="color: #0000ff;">typedef</span> std::<span style="color: #00eeff;">unary_function</span>&lt;arg1_type,result_type&gt; f_type;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>n_args=<span style="color: #0000dd;">1</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
template&lt;typename F&gt; <span style="color: #0000ff;">struct</span> functor_traits&lt;F,<span style="color: #0000dd;">0</span>&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> F::<span style="color: #00eeff;">result_type</span> result_type; 
  <span style="color: #0000ff;">typedef</span> empty_type   arg1_type; 
  <span style="color: #0000ff;">typedef</span> empty_type  arg2_type; 
  <span style="color: #0000ff;">typedef</span> generator&lt;result_type&gt; f_type;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>n_args=<span style="color: #0000dd;">0</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: functor_type.h)
</p><p>Podobnie dla wskaźników do funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename R,<span style="color: #0000ff;">typename</span> A1,<span style="color: #0000ff;">typename</span> A2&gt; 
<span style="color: #0000ff;">struct</span> functor_traits&lt;R <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>A1,A2<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">2</span>&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> R   result_type; 
  <span style="color: #0000ff;">typedef</span> A1  arg1_type; 
  <span style="color: #0000ff;">typedef</span> A2  arg2_type; 
  <span style="color: #0000ff;">typedef</span> std::<span style="color: #00eeff;">binary_function</span>&lt;arg1_type,arg2_type,result_type&gt; f_type;
  <span style="color: #0000ff;">enum</span> <span style="color: #000000;">&#123;</span>n_args=<span style="color: #0000dd;">2</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
...</pre></div>

<p>( Źródło: functor_type.h)
</p><p>Jeśli teraz  użyjemy klasy <tt>functor_traits</tt> w definicji
adaptera <tt>binder1st</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename F&gt; <span style="color: #0000ff;">class</span> binder1st <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span>  <span style="color: #0000ff;">typename</span> functor_traits&lt;F&gt;::<span style="color: #00eeff;">arg1_type</span>  bind_type;
  <span style="color: #0000ff;">typedef</span>  <span style="color: #0000ff;">typename</span> functor_traits&lt;F&gt;::<span style="color: #00eeff;">arg2_type</span> first_argument_type;
  <span style="color: #0000ff;">typedef</span>  <span style="color: #0000ff;">typename</span> functor_traits&lt;F&gt;::<span style="color: #00eeff;">res_type</span> result_type;
&nbsp;
  <span style="color: #0000ff;">const</span> bind_type _val;
  F _op;
  <span style="color: #0000ff;">public</span>:
  binder1st<span style="color: #000000;">&#40;</span>F op,bind_type val<span style="color: #000000;">&#41;</span>:_op<span style="color: #000000;">&#40;</span>op<span style="color: #000000;">&#41;</span>, _val<span style="color: #000000;">&#40;</span>val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  result_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>first_argument_type x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> _op<span style="color: #000000;">&#40;</span>_val,x<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
&nbsp;
template&lt;typename F&gt; 
binder1st&lt;F&gt; 
bind1st<span style="color: #000000;">&#40;</span>F op,<span style="color: #0000ff;">typename</span> functor_traits&lt;F&gt;::<span style="color: #00eeff;">arg1_type</span> val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">return</span> binder1st&lt;F&gt;<span style="color: #000000;">&#40;</span>op,val<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>to bedziemy mogli używać go z wskaźnikami do funkcji bez konieczności opakowywania ich w adapter <tt>ptr_fun</tt>.
</p><p>Można stosunkowo łatwo rozszerzyć kod adaptera <tt>binder1st</tt> tak, aby można go było używać zarówno do funktorów dwu- jak i jednoargumentowych.
</p>
<h3>Biblioteki funktorów</h3>
<br />

<p>Kod przedstawiony w poprzednim podrozdziale daje, mam nadzieję, pewne
wyobrażenie o tym, jak można implemetować bardziej zaawansowane
funktory i operacje na nich. Widać jednak, że nie jest to  zbyt proste:
kod szybko staje się skomplikowany i trudny do debugowania. 
</p><p>Na szczeście istnieją już gotowe implementacje. Jak już wspomiałem
propozycje bardziej rozwiniętego szkieletu funktorów znajdą państwo w D. Vandervoorde, N. Josuttis <i>"C++ Szablony, Vademecum profesjonalisty"</i>, rozdz. 22. Ponadto biblioteka <tt>boost</tt> oferuje szereg narzędzi, w tym biblioteki <tt>lambda</tt> i <tt>bind</tt>. O tej
pierwszej już wspominałem przy omawianiu szablonów wyrażeń. Biblioteka <tt>lambda</tt> dostarcza funkcjonalności adapterów <tt>bind...</tt> i <tt>compose...</tt>  za pomocą wyrażenia jednego wyrażenia <tt>bind</tt>. Korzystając z niego, można kod podany w poprzednim podrozdziale
zapisać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include&lt;boost/lambda/lambda.hpp&gt;</span>
<span style="color: #339900;">#include&lt;boost/lambda/bind.hpp&gt;</span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span> boost::<span style="color: #00eeff;">lambda</span>;
&nbsp;
  <span style="color: #0000ff;">double</span> x=<span style="color: #0000dd;">1</span>;
  std::<span style="color: #00eeff;">cout</span>&lt;&lt;bind<span style="color: #000000;">&#40;</span>f,<span style="color: #0000dd;">1.0</span>,_1<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
  std::<span style="color: #00eeff;">cout</span>&lt;&lt;bind<span style="color: #000000;">&#40;</span>f,<span style="color: #0000dd;">1.0</span>,_1<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>make_const<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2.0</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
  wyrażenie z biblioteki lambda nie przyjmują stałych stąd
  konieczność użycia zamienej x, lub wyrażenia makeconstant<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>
  std::<span style="color: #00eeff;">cout</span>&lt;&lt;bind<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">exp</span>,-bind<span style="color: #000000;">&#40;</span>f,_1,_2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>x,x<span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;</pre></div>

<p>( Źródło: bind_lambda.cpp)
</p>
<table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sin.cpp">Sin.cpp</a></td><td>1.42 KB</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/M_ptr.cpp">M_ptr.cpp</a></td><td>258 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Bind_0.cpp">Bind.cpp</a></td><td>518 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Functor_type.h">Functor_type.h</a></td><td>5.97 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Bind_lambda.cpp">Bind_lambda.cpp</a></td><td>808 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1248" class="section-2">
  <h1 class="book-heading">Używanie funktorów</h1>
  <h2>Wstęp</h2>
<hr />
<br />

<p>W poprzednim wykładzie omawiałem pojęcie obiektu funkcyjnego, jako
uogólnienia wskaźników do funkcji. I choć funktory można wywoływać
bezpośrednio tak jak funkcje, to dużo częściej używa się ich jako
parametrów przekazywanych do innych funkcji, w celu dostarczenia tej
funkcji informacji koniecznych do wykonania swojego zadania. W tej
kategorii zastosowań mieści się większość bibliotek, w tym STL, gdzie
funktory służą jako argumenty do uogólnionych algorytmów. Przykłady
takich zastosowań były już podawane w poprzednich wykładach, a na tym
wykładzie omówię je trochę bardziej szczegółowo.
</p><p>Inny popularny schemat użycia wskaźników funkcji (a więc i funktorów)
to rozdzielenie miejsca i czasu definicji funkcji od miejsca i czasu
jej wykonania. Wygląda to zwykle następująco: Klient definiuje funkcje
i przekazuje ich wskaźniki do aplikacji, aplikacja wywołuje te funkcje
w wybranym przez siebie czasie. Klient nie ma pojęcia kiedy zostaną
wywołane przekazane przez niego funkcje, a aplikacja nie wie jakie
one mają działanie. Taka technika funkcji zwrotnych
(callbacks) jest podstawą implementacji wielu szkieletów graficznych
interfejsów użytkownika i w E. Gamma, R. Helm, R. Johnson, J. Vlissides <i>"Wzorce projektowe. Elementy oprogramowania obiektowego wielokrotnego użytku"</i> wymieniona jest jako wzorzec
polecenie. Aby używać funktorów definiowanych na poprzednim wykładzie,
we wzorcu polecenie trzeba będzie je trochę dostosować. Zostanie to
opisane w drugiej części tego wykładu.
</p>
<br />

<h2>Algorytmy  uogólnione i programowanie funkcyjne</h2>
<hr />
<p>Algorytmy stanowią, jak już to opisałem w wykładzie 2, jedną z części biblioteki STL, większośc z tych algorytmów posiada wersje
przyjmujące funktor jako jeden z argumentów. Nie jest moim celem
przedstawianie tutaj wszystkich algorytmów, jest ich zresztą blisko
100, choć gorąco zachęcam Państwa do zapoznania się z nimi. W tym celu
polecam książke N.M. Josuttis <i>"C++ Biblioteka Standardowa. Podręcznik programisty"</i> i stronę <a href="http://www.sgi.com/tech/stl/" title="http://www.sgi.com/tech/stl/">http://www.sgi.com/tech/stl/</a>.
Znakomita jest też pozycja S. Meyers <i>"STL w praktyce. 50 sposobów efektywnego wykorzystania"</i>, jak zresztą wszystkie
książki tego autora.
</p><p>W tym wykładzie chciałbym tylko zwrócić uwagę, że biblioteka algorytmów
wprowadza do C++ elementy programowania funkcyjnego. Programowanie
funkcyjne polega, z grubsza rzecz biorąc, na zastępowaniu pętli
poleceniami, które potrafią wywołać daną funkcję na każdym elemencie
danej kolekcji. Taki styl programowania jest często spotykany w
językach interpretowanych, np. używa go pakiet <tt>Mathematica</tt>,
podobnie pakiet do obliczeń numerycznych w Perlu: Perl Data Language i
wiele innych. Biblioteka STL oferuje tylko namiastkę tego stylu, ale
właśnie ją chciałbym przedstawić w tej części wykładu. 
</p><p>Podstawą programowania funkcyjnego są funkcje, które wywołują inne
funkcje na każdym obiekcie z kolekcji. STL oferuje kilka takich algorytmów,
podstawowym z nich jest <tt>for_each</tt>.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator, <span style="color: #0000ff;">class</span> UnaryFunction&gt;
UnaryFunction 
for_each<span style="color: #000000;">&#40;</span>InputIterator first,InputIterator last, 
         UnaryFunction op<span style="color: #000000;">&#41;</span>;</pre></div>

<p>Działanie tego algorytmu polega na wywołaniu podanego funktora <tt>op</tt>
na każdym elemencie zakresu <tt>[first,last)</tt>. Funktor może
modyfikować wywoływany obiekt i może powodowac inne skutki uboczne.
Jego kopia jest zwracana po wykonaniu wszystkich operacji. Wartość
zwracana przez funktor <tt>op</tt> jest ignorowana. Algorytm zwraca kopię funktora <tt>op</tt>.
</p><p>Podobnym algorytmem jest <tt>transform</tt>. W swojej pierwszej wersji
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator, <span style="color: #0000ff;">class</span> OutputIterator, <span style="color: #0000ff;">class</span> UnaryFunction&gt;
OutputIterator transform<span style="color: #000000;">&#40;</span>InputIterator first, InputIterator last,
                         OutputIterator result, UnaryFunction op<span style="color: #000000;">&#41;</span>;</pre></div>

<p>działa  podobnie jak <tt>for_each</tt>, z tą różnicą, że wyniki wywołania
operacji <tt>op</tt> na wartościach zakresu <tt>[firts,last)</tt> są zapisywane poprzez
iterator <tt>result</tt>. Ważną cechą tego algorytmu jest to, że może on operować
na dwu wejściowych zakresach. Jego druga wersja
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator1, <span style="color: #0000ff;">class</span> InputIterator2, 
          <span style="color: #0000ff;">class</span> OutputIterator,<span style="color: #0000ff;">class</span> BinaryFunction&gt;
OutputIterator 
transform<span style="color: #000000;">&#40;</span>InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, OutputIterator result,
          BinaryFunction op<span style="color: #000000;">&#41;</span>;</pre></div>


<p>wywołuje operację binarną <tt>op</tt> na parach wartości wziętych  po
jednej z każdego zakresu wejściowego. Wynik zapisywany jest poprzez
iterator wyjściowy <tt>result</tt>.
</p><p>Warto też zwrócić uwagę na algorytmy numeryczne, które pomimo ich
nazwy mogą spokojnie zostać użyte do innych ogólnych zastosowań. Są to:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator, <span style="color: #0000ff;">class</span> T, <span style="color: #0000ff;">class</span> BinaryFunction&gt;
T accumulate<span style="color: #000000;">&#40;</span>InputIterator first, InputIterator last, T init,
             BinaryFunction op<span style="color: #000000;">&#41;</span>;</pre></div>

<p>który oblicza uogólnioną sumę podanego zakresu
</p>

<div style="text-align: center">\(\displaystyle  init \operatorname{op} a_1 \operatorname{op} a_2  \operatorname{op} \cdots \operatorname{op}  a_n \equiv \operatorname{op}(\operatorname{op}(\operatorname{op}(init,a_1),a2) ... a_n)\)</div>
<p>iloczyn skalarny <tt>inner_product</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator1, <span style="color: #0000ff;">class</span> InputIterator2, <span style="color: #0000ff;">class</span> T,
          <span style="color: #0000ff;">class</span> BinaryFunction1, <span style="color: #0000ff;">class</span> BinaryFunction2&gt;
T inner_product<span style="color: #000000;">&#40;</span>InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, T init, BinaryFunction1 op1,
                BinaryFunction2 op2<span style="color: #000000;">&#41;</span>;</pre></div>


<p>który oblicza uogólniony iloczyn skalarny
</p>
<div style="text-align: center">\(\displaystyle  (a_1 \operatorname{op}_1 b_1 ) \operatorname{op}_2 (a_2 \operatorname{op}_1 b_2 ) \operatorname{op}_2 \cdots \operatorname{op}_2 (a_n \operatorname{op}_1 b_n )  \cdots\)</div>
<p>oraz sumy i różnice częściowe:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class InputIterator, <span style="color: #0000ff;">class</span> OutputIterator, <span style="color: #0000ff;">class</span> BinaryOperation&gt;
OutputIterator 
partial_sum<span style="color: #000000;">&#40;</span>InputIterator first,   InputIterator last,
            OutputIterator result, BinaryOperation binary_op<span style="color: #000000;">&#41;</span>;
&nbsp;
<span style="color: #0000ff;">template</span> &lt;class InputIterator, <span style="color: #0000ff;">class</span> OutputIterator, <span style="color: #0000ff;">class</span> BinaryFunction&gt;
OutputIterator adjacent_difference<span style="color: #000000;">&#40;</span>InputIterator first, InputIterator last,
                                   OutputIterator result,
                                   BinaryFunction op<span style="color: #000000;">&#41;</span>;</pre></div>

<p>zwracające poprzez iterator <tt>result</tt> odpowiednio:
</p>
<div style="text-align: center">\(\displaystyle  a_1,a_1 \operatorname{op} a_2,a_1 \operatorname{op} a_2 \operatorname{op} a3,\ldots, a_1 \operatorname{op} \cdots \operatorname{op}   a_n\)</div>
<p>i 
</p>

<div style="text-align: center">\(\displaystyle  a_1,a_2 \operatorname{op} a_1,a_3 \operatorname{op} a2,\ldots, a_{n} \operatorname{op} a_{n-1}\)</div>
<p><br />
Zwłaszcza algorytm <tt>adjacent_difference</tt> jest ciekawy, umożliwia
bowiem zastosowanie dwuargumentowej operacji do kolejnych par
elementów: 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">int</span> print<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i,<span style="color: #0000ff;">int</span> j<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  cout&lt;&lt;<span style="color: #666666;">&quot;(&quot;</span>&lt;&lt;i&lt;&lt;<span style="color: #666666;">&quot;:&quot;</span>&lt;&lt;j&lt;&lt;<span style="color: #666666;">&quot;)&quot;</span>;
  <span style="color: #0000ff;">return</span> <span style="color: #0000dd;">0</span>;
<span style="color: #000000;">&#125;</span>
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  list&lt;int&gt; li;
  list&lt;int&gt; res;
  generate_n<span style="color: #000000;">&#40;</span>back_insert_iterator&lt;list&lt;int&gt; &gt;<span style="color: #000000;">&#40;</span>li<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">10</span>,SequenceGen&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
  adjacent_difference<span style="color: #000000;">&#40;</span>li.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,li.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,back_insert_iterator&lt;list&lt;int&gt; &gt;<span style="color: #000000;">&#40;</span>res<span style="color: #000000;">&#41;</span>,print<span style="color: #000000;">&#41;</span>;</pre></div>


<p>( Źródło: sums.cpp)
</p><p>Ten przykładzik ilustruje niedogodność posługiwania się algorytmami przyjmującymi zakres wyjściowy, takimi jak <tt>adjacent_difference</tt> czy <tt>transform</tt>, do prostego działania funkcją, która nie zwraca żadnych wartości. Do tego przeznaczony jest algorytm <tt>for_each</tt>. Niestety, ten algorytm nie pozwala bezpośrednio operować na parach kolejnych elementów, tak jak <tt>adjacent_difference</tt>. To by jeszcze można zasymulować używając odpowiedniego funktora, ale <tt>for_each</tt> nie potrafi operować na parach elementów pochodzących z dwu zakresów, tak jak potrafi to <tt>transpose</tt>.
</p><p>Jest kilka możliwości rozwiązania tego problemu. Możemy np. napisać własne algorytmy (zob. zadania). Możemy też dalej korzystać np. z <tt>adjacent_difference</tt> ale napisać narzędzia pomagające adoptować takie algorytmy do naszych celów. Jak by to mogło wyglądać? 
</p><p>Patrzac na nasz przykład i deklarację <tt>adjacent_difference</tt> widzimy, że są dwa problemy: po pierwsze wartość zwracana z funkcji <tt>op</tt> musi być tego samego typu jak typ elementów w zakresie wejściowym, po drugie musimy jakoś "zjeść" te zwracane wartości. Potrzebny więc będzie funktor opakowujący dowolną funkcję i zwracający wartość zadanego typu, oraz iterator pełniący rolę <tt>/dev/null</tt>, czyli "czarnej dziury" połykającej wszystko co się do niej zapisze. Mając takie obiekty możemy powyższy kod zapisać następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> print<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i,<span style="color: #0000ff;">int</span> j<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  cout&lt;&lt;<span style="color: #666666;">&quot;(&quot;</span>&lt;&lt;i&lt;&lt;<span style="color: #666666;">&quot;:&quot;</span>&lt;&lt;j&lt;&lt;<span style="color: #666666;">&quot;)&quot;</span>;
<span style="color: #000000;">&#125;</span>
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  list&lt;int&gt; li;
&nbsp;
  generate_n<span style="color: #000000;">&#40;</span>back_insert_iterator&lt;list&lt;int&gt; &gt;<span style="color: #000000;">&#40;</span>li<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">10</span>,SequenceGen&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
  adjacent_difference<span style="color: #000000;">&#40;</span>li.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,li.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,dev_null&lt;char&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,dummy&lt;char&gt;<span style="color: #000000;">&#40;</span>print<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>Obiekt klasy <tt>dev_null<T></t></tt> to iterator typu <tt>output_iterator</tt>, którego <tt>value_type</tt> jest równy <tt>T</tt>. Iterator ten ignoruje wszelkie operacje na nim wykonywane, w tym przypisanie do niego. Funckja <tt>dummy<T>(F f, T val = T())</t></tt> zwraca funktor, który wywołuje funkcję <tt>f</tt>, a następnie zwraca wartośc <tt>val</tt> typu <tt>T</tt>. Implementacje tych szablonów pozostawiam jako ćwiczenie (zob. zadania).
</p><p>Pomysły można mnożyć. Jako ostatni zaprezentuję iterator, który nie wstawia nic do żądanego kontenera, ale wywołuje na przypisywanym do niego obiekcie jakąś zadaną funkcję:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> p<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  std::<span style="color: #00eeff;">cout</span>&lt;&lt;<span style="color: #666666;">&quot;printing  &quot;</span>&lt;&lt;x&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
<span style="color: #000000;">&#125;</span>;
&nbsp;
<span style="color: #0000ff;">double</span>  frac<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> i/<span style="color: #0000dd;">10.0</span>;
<span style="color: #000000;">&#125;</span>
  list&lt;int&gt; li;
  generate_n<span style="color: #000000;">&#40;</span>back_insert_iterator&lt;list&lt;int&gt; &gt;<span style="color: #000000;">&#40;</span>li<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">10</span>,SequenceGen&lt;int&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
std::<span style="color: #00eeff;">transform</span><span style="color: #000000;">&#40;</span>li.<span style="color: #00eeff;">begin</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,li.<span style="color: #00eeff;">end</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>,function_iterator&lt;double&gt;<span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span>,frac<span style="color: #000000;">&#41;</span>;</pre></div>

<p>Taki iterator łatwo zaimplementować przy pomocy klas proxy (zob. zadania).
</p>
<br />
<h2>Wzorzec Polecenie</h2>

<p>Wzorzec polecenie najlepiej omówić na przykładzie. Jak już wspomniałem,
typowe zastosowanie to graficzny interfejs użytkownika (GUI). Taki
interfejs musi reagować na różne zdarzenia: kliknięcie myszą,
naciśnięcie przycisku, wybranie polecenia z menu. Ewidentnie twórca
biblioteki GUI nie może wiedziec jakie działanie ma pociągnąć dane
zdarzenie.  Nawet jednak gdybyśmy sami pisali cały kod, to
"zaszycie" polecenia na stałe w kodzie danego elementu interfejsu
jest bardzo złą praktyką programistyczną. Dlatego używa się w tym celu
funkcji zwrotnych. I tak w jakiejś hipotetycznej klasie 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Window <span style="color: #000000;">&#123;</span></pre></div>

<p>znajdziemy na pewno funkcję w rodzaju 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">on_mouse_click<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span></pre></div>

<p>służącą do przekazania wskaźnika do funkcji, która zostanie wywołana po
naciśnięciu myszką na oknie. Podobnie dla innych komponentów:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> Button <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*_f<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> ; <span style="color: #ff0000; font-style: italic;">/*wskaźnik do funkcji */</span>
<span style="color: #0000ff;">void</span> when_pressed<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*f<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>_f=f;<span style="color: #000000;">&#125;</span>;
...
<span style="color: #000000;">&#125;</span></pre></div>

<p>Ponieważ typ funkcji określony jest poprzez typ jej parametrów i typ
wartości zwracanej to możemy w ten sposób ustawić dowolną fukcję o
odpowiedniej sygnaturze. Niestety, jeżeli chcemy wykorzystać
dobrodziejstwa jakie daje nam zastosowanie obiektów funkcyjnych
zamiast funkcji, musimy je dziedziczyć ze wspólnej klasy bazowej,
ponieważ jedną z podstawowych cech funktorów jest to, że posiadają swój
typ.  Żeby więc móc przekazywać różne funktory za pomocą tej samej
sygnatury, musimy je rzutować w górę na wspólny typ. To jest cała
esencja wzorca polecenie (zob. E. Gamma, R. Helm, R. Johnson, J. Vlissides <i>"Wzorce projektowe. Elementy oprogramowania obiektowego wielokrotnego użytku"</i>).
</p><p>Oznacza to jednak, że nie możemy skorzystać z całej technologii
wyprowadzonej na poprzednim wykładzie. Szablony też nam nie pomogą,
ponieważ wenątrz elementów GUI musimy jakoś przechować funktor
zwrotny. Aby przechowywać różne funktory musielibyśmy parametryzować
nasz element typem funktora, co doprowadziłoby do tego, że typ elementu
interfejsu zależałby od konkretnego polecenia, które wywołuje! To
uniemożliwiłoby w praktyce jakiekolwiek funkcjonowanie szkieletu. 
</p><p>Żeby więc wykorzystać już istniejące funkcje i funktory musimy je
opakować w typ, który będzie zależał tylko od typów wartości zwracanej
i argumentów, podobnie jak w przypadku zwykłych funkcji. Poniżej
przedstawię zarys konstrukcji szablonu, który umożliwia robienie tego
automatycznie. Będę się opierał na implementacji zamieszczonej w
A. Alexandrescu: <i>"Nowoczesne projektowanie w C++"</i>, ale ograniczę się do funktorów zero-, jedno- i
dwuargumentowych.
</p>
<br />

<h3>Uniwersalny funktor</h3>

<p>Uniwersalny funktor (nazwiemy go <tt>Function</tt>) ma z założenia
odpowiadać typowi funkcyjnemu, czyli zależeć jedynie od typu wartości
zwracanej i typów argumentów.  Musi więc być zdefiniowany jako
szablon, paremetryzowany właśnie tymi typami. Tu napotykamy pierwszy
problem: C++ nie dopuszcza zmiennej liczby parametrów szablonu.
Najprostszym nasuwającym się rozwiązaniem jest stworzenie trzech
różnych szablonów <tt>Function0</tt>, <tt>Function1</tt> i <tt>Function2</tt>,
każdy z odpowiednią liczbą parametrów. Takie rozwiązanie jest jednak
niegodne prawdziwego uogólnionego programisty:). Poszukajmy więc typów,
które zawierają w sobie inne typy.  Możliwości mamy całkiem sporo,
moglibyśmy np. wykorzystać klasy ze zdefiniowanymi odpowiednimi typami
stowarzyszonymi, można wykorzystać typy funkcyjne lub typy wskaźników
do funkcji, no i listy typów wprowadzonych w wykładzie 6.3 właśnie do takich celów. Orginalne rozwiązanie w A. Alexandrescu <i>"Nowoczesne projektowanie w C++"</i> wykorzystuje listy typów (autor tej pozycji jest ich twórcą), ja użyję typów
wskaźnikow do funkcji. To, że bedę używał wskaźników, a nie samych typów funkcji, podyktowane jest względami czysto technicznymi: moja klasa cech <tt>functor_traits</tt> rozpoznaje typy wskaźników do funkcji, a same typy funkcyjne już nie (choć jest to tylko kwestia dodania odpowiednich specjalizacji). Deklaracja szablonu <tt>Function</tt> wyglądała będzie
więc następująco:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename FT&gt; <span style="color: #0000ff;">class</span> Function:
<span style="color: #0000ff;">public</span>  functor_traits&lt;FT&gt;::<span style="color: #00eeff;">f_type</span> <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> functor_traits&lt;FT&gt;::<span style="color: #00eeff;">result_type</span> res_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> functor_traits&lt;FT&gt;::<span style="color: #00eeff;">arg1_type</span>   arg1_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> functor_traits&lt;FT&gt;::<span style="color: #00eeff;">arg2_type</span>   arg2_type;
 <span style="color: #0000ff;">public</span>:  
...
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: universal.h)
</p><p>Dziedziczenie z <tt>functor_traits<FT>::f_type</ft></tt> zapewnia nam, że
<tt>Function</tt> będzie posiadał odpowiednie typy stowarzyszone zgodnie z
konwencją STL.
</p><p>Jako klasa opakowująca <tt>Function</tt> musi zawierać
opakowywany funktor. Nie może jednak tego robić bezpośrednio, bo nie
znamy typu tego funktora (a raczej nie chcemy go znać). <tt>Function</tt> 
będzie więc zawierał wskaźnik do abstrakcyjnej klasy 
<tt>AbstractFunctionHolder<FT></ft></tt> parametryzowanej tym samym typem.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">std::<span style="color: #00eeff;">auto_ptr</span>&lt;AbstractFunctionHolder&lt;FT&gt; &gt; _ptr_fun;</pre></div>

<p>Z tej klasy będą dziedziczyć klasy opakowujące konkretne typy funktorów:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename FT,<span style="color: #0000ff;">typename</span> F&gt; 
<span style="color: #0000ff;">class</span> FunctionHolder: <span style="color: #0000ff;">public</span> AbstractFunctionHolder&lt;FT&gt; <span style="color: #000000;">&#123;</span>
&nbsp;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> functor_traits&lt;FT&gt;::<span style="color: #00eeff;">result_type</span> res_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> functor_traits&lt;FT&gt;::<span style="color: #00eeff;">arg1_type</span> arg1_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> functor_traits&lt;FT&gt;::<span style="color: #00eeff;">arg2_type</span> arg2_type;
...
&nbsp;
<span style="color: #0000ff;">private</span>:
   F _fun;
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: universal.h)
</p><p>Konstruktor klasy <tt>FunctionHolder</tt> będzie inicjalizował pole <tt>_fun</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">FunctionHolder<span style="color: #000000;">&#40;</span>F fun<span style="color: #000000;">&#41;</span>:_fun<span style="color: #000000;">&#40;</span>fun<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>


<p>Korzystać z niego będzie konstruktor klasy <tt>Function</tt>, który musi
być szablonem aby pozwolić na inicjalizowanie <tt>Function</tt> dowolnym 
typem funktora:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename F&gt;  Function<span style="color: #000000;">&#40;</span>F fun<span style="color: #000000;">&#41;</span>:
  _fun<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> FunctionHolder&lt;FT,F&gt;<span style="color: #000000;">&#40;</span>fun<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: universal.h)
</p><p>Ten konstruktor zamienia statyczną informację o typie <tt>F</tt> na
informację dynamiczną zawartą we wskaźniku <tt>_ptr_fun</tt>. 
Tę informację  odzyskujemy za pomocą polimorfizmu. W celu uzyskania
polimorficznego zachowania przy kopiowaniu i przypisywaniu obiektów
<tt>Function</tt> skorzystamy z klonowania:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Function<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Function&amp; f<span style="color: #000000;">&#41;</span>:_fun<span style="color: #000000;">&#40;</span>f._fun-&gt;Clone<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
Function &amp;operator=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Function &amp;f<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  _fun.<span style="color: #00eeff;">reset</span><span style="color: #000000;">&#40;</span>f._fun-&gt;Clone<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: universal.h)
</p><p>Wymaga to dodania do klasy <tt>AbstractFunctionHolder</tt> wirtualnych funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">virtual</span>  AbstractFunctionHolder* Clone<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>=<span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">virtual</span>  AbstractFunctionHolder<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: universal.h)
</p><p>Klasa <tt>FunctionHolder</tt> implementuje funkcję <tt>Clone()</tt> następująco:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">FunctionHolder*Clone<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #0000dd;">new</span> FunctionHolder<span style="color: #000000;">&#40;</span>*<span style="color: #0000dd;">this</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: universal.h)
</p><p>Proszę zwrócić uwage na typ argumentu konstruktorów. Zgodnie z tym co
napisałem w wykładzie 11.2, użyłem wywołania przez wartość <tt>(F fun)</tt>, inaczej nie możnaby inicjalizować pola <tt>F _fun</tt> w przypadku gdyby <tt>F</tt> był typem funkcyjnym. Należy nadmienić, że implementacja opisana w A. Alexandrescu: <i>"Nowoczesne projektowanie w C++"</i> zawiera właśnie taki błąd, który nie występuje w kodzie biblioteki <tt>loki</tt> dostępnym w Internecie.
</p>
<br />
<h3>Wywoływanie: operator()</h3>
<p>W ten sposób mamy już wszystko poza najważniejszym: operatorem <tt>operator()(...)</tt>, który czyni funktor funktorem.
</p><p>Zacznijmy od operatora nawiasów w klasie <tt>Function</tt>. Problem polega
na tym, że nie ma możliwości zdefiniowania operatora odpowiadającego
przekazanemu typowi funkcyjnemu (można by ewentulanie go
zadeklarować), bo wymagałoby to definicji dopuszczającej zmienną
liczbę argumengtów (tak, tak, wiem w C jest taka możliwość,
ale lepiej z niej nie korzystać, zresztą nie ma potrzeby). Możliwe
rozwiązanie to specjalizacja szablonu dla funktorów bez argumentów, z
jednym lub z dwoma argumentami i w każdej specjalizacji
zdefiniowanie operatora <tt>operator()(...)</tt> z odpowiednią liczbą
argumentów. Okazuje się, że nie ma takiej potrzeby, możemy zdefiniować
wszystkie wersje operatora wywołania funkcji w tej samej klasie i
polegać na mechaniźmie opóźnionej konkretyzacji: dopóki nie wywołamy
operatora ze złą ilością argumentów, to nie będzie on konkretyzowany.
Dodajemy więc do klasy <tt>Function</tt> następujące linijki:
</p>


<div class="geshifilter"><pre class="geshifilter-cpp">res_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>*_ptr_fun<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
res_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>arg1_type x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>*_ptr_fun<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
res_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>arg1_type x,arg2_type y<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>*_ptr_fun<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>x,y<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>


<p>( Źródło: universal.h)
</p><p>Wskaźnik <tt>_ptr_fun</tt> jest typu <tt>AbstractFunctionHolder*</tt>, musimy 
więc zaimplementować w tej klasie operator nawiasów.
Klasa <tt>AbstractFunctionHolder*</tt> nie posiada wystarczającej w tym celu 
informacji, więc deklarujemy te funkcje  jako czyste funkcje wirtualne,
które zostaną zdefiniowane dopiero w klasie pochodnej <tt>FunctionHolder</tt>.
Niestety deklaracja trzech różnych wariantów operatora 
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">virtual</span> res_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> = <span style="color: #0000dd;">0</span>;
 <span style="color: #0000ff;">virtual</span> res_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>arg1_type x<span style="color: #000000;">&#41;</span> = <span style="color: #0000dd;">0</span>;
 <span style="color: #0000ff;">virtual</span> res_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>arg1_type x,arg2_type y<span style="color: #000000;">&#41;</span>=<span style="color: #0000dd;">0</span>;</pre></div>


<p>i odpowiadające im definicje w klasie <tt>FunctionHolder</tt>
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">res_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _fun<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
 res_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>arg1_type x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _fun<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;
 res_type operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>arg1_type x,arg2_type y<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _fun<span style="color: #000000;">&#40;</span>x,y<span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>;</pre></div>

<p>spowodują błędy w kompilacji już przy konstrukcji klasy. Dzieje się
tak dlatego, że funkcje wirtualne mogą niepodlegać konkretyzacji
opóźnionej i w implementacji kompilatora <tt>g++</tt> jej nie podlegają. Tzn.
kiedy kompilator dokonuje konkretyzacji klasy
<tt>FunctionHolder<FT,F></ft,f></tt>, wymaganej przez konstruktor inicjalizujący
klasy <tt>Function</tt>, konkretyzuje wszystkie funkcje wirtualne, a tylko
jedna wersja operatora wywołania jest prawidłowa. W tym przypadku nie
unikniemy więc konieczności specjalizowania szablonów dla każdej
ilości agumentów. Na szczęście wystarczy wyspecjalizować tylko klasę 
<tt>AbstractFunctionHolder</tt>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename FT&gt; <span style="color: #0000ff;">class</span> AbstractFunctionHolder ;
&nbsp;
template&lt;typename R,<span style="color: #0000ff;">typename</span> A1,<span style="color: #0000ff;">typename</span> A2&gt; 
<span style="color: #0000ff;">class</span> AbstractFunctionHolder&lt;R <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>A1,A2<span style="color: #000000;">&#41;</span>&gt; <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">virtual</span> R operator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span>A1 x, A2 y<span style="color: #000000;">&#41;</span> = <span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">virtual</span>  AbstractFunctionHolder* Clone<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>=<span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">virtual</span>  AbstractFunctionHolder<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span> ;</pre></div>

<p>( Źródło: universal.h)
</p><p>i tak samo dla funkcji z jednym i bez argumentów.
</p><p>Szablon <tt>FunctionHolder</tt> może dalej definiować wszystkie warianty
operatora wywołania. Prześledźmy teraz konkretyzację tych szablonów na
przykładzie:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">double</span> f<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> x;<span style="color: #000000;">&#125;</span>
&nbsp;
Function&lt;double<span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&gt; Func1;</pre></div>

<p>Konstrutor klasy <tt>Function<double (*)(double)></double></tt> wywoła konstruktor 
klasy <tt>FunctionHandler<double (*)(double),double (*)(double)></double></tt>,
co pociągnie za sobą konieczną konkretyzację tego szablonu. 
Ten szablon dziedziczy z
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">AbstractFunctionHandler&lt;double <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&gt;</pre></div>


<p>która ma zdefiniowany tylko jeden operator
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">double</span> operator<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x<span style="color: #000000;">&#41;</span> = <span style="color: #0000dd;">0</span></pre></div>

<p>Ale to oznacza, że z trzech wariantów operatora wywołania
zdefiniowanych w <tt>FunctionHandler<double (*)(double),double (*)(double)></double></tt> tylko jeden jest wirtualny: ten dobry! I właśnie ten zostanie skonkretyzowany, pozostałe dwa są zwykłymi funkcjami składowymi i nie zostaną utworzone jesli ich nie użyjemy. Jeśli jednak spróbujemy ich użyć dostaniemy błąd kompilacji, co jest w tej sytuacji zachowaniem pożądanym.
</p><p>Używając szablonu <tt>Function</tt> możemy teraz napisać:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include&quot;universal.h&quot;</span>
  Cov f<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,<span style="color: #0000dd;">2.0</span>,<span style="color: #0000dd;">2.0</span><span style="color: #000000;">&#41;</span>;
&nbsp;
  Function&lt;double <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span>,<span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&gt;  fc;
  fc=compose_f_gxy<span style="color: #000000;">&#40;</span>
                           __gnu_cxx::<span style="color: #00eeff;">compose1</span><span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">ptr_fun</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">exp</span><span style="color: #000000;">&#41;</span>,
                                         std::<span style="color: #00eeff;">negate</span>&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>,
                           f<span style="color: #000000;">&#41;</span>;
&nbsp;
std::<span style="color: #00eeff;">cout</span>&lt;&lt;fc<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,<span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
&nbsp;
Function&lt;double <span style="color: #000000;">&#40;</span>*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&gt; my_exp<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">exp</span><span style="color: #000000;">&#41;</span>;
&nbsp;
std::<span style="color: #00eeff;">cout</span>&lt;&lt;my_exp<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;</pre></div>

<p>( Źródło: test_universal.cpp)
</p>
<br />
<h3>boost::functions</h3>
<p>Podobną funkcjonalność dostarcza biblioteka <tt>functions</tt> z repozytorium <tt>boost</tt>.  Zresztą stamtąd wziąłem pomysł parametryzowania funktorów typem funkcyjnym. Kod używający tej biblioteki będzie wyglądał bardzo podobnie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include&lt;boost/function.hpp&gt;</span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span> boost;
&nbsp;
  Cov f<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,<span style="color: #0000dd;">2.0</span>,<span style="color: #0000dd;">2.0</span><span style="color: #000000;">&#41;</span>;
&nbsp;
  boost::<span style="color: #00eeff;">function</span>&lt;double <span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span>,<span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>&gt;  fc;
  fc=compose_f_gxy<span style="color: #000000;">&#40;</span>
                           __gnu_cxx::<span style="color: #00eeff;">compose1</span><span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">ptr_fun</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">exp</span><span style="color: #000000;">&#41;</span>,
                                         std::<span style="color: #00eeff;">negate</span>&lt;double&gt;<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>,
                           f<span style="color: #000000;">&#41;</span>;
&nbsp;
std::<span style="color: #00eeff;">cout</span>&lt;&lt;fc<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1.0</span>,<span style="color: #0000dd;">1.0</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;</pre></div>

<p>( Źródło: boost_function.cpp)
</p>
<table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Sums.cpp">Sums.cpp</a></td><td>681 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Universal.h">Universal.h</a></td><td>2.82 KB</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Test_universal.cpp">Test_universal.cpp</a></td><td>384 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Boost_function.cpp">Boost_function.cpp</a></td><td>1.23 KB</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1347" class="section-2">
  <h1 class="book-heading">Wyjątki</h1>
  <h2>Wstęp</h2>
<hr />
<br />
<p>Jesteśmy istotami omylnymi, więc niezależnie od naszych starań, pisane przez nas 
programy bedą zawierały usterki, dostarczane do nich dane nie zawsze
będą poprawne, a i sprzęt może nie działać tak jak trzeba.
</p><p>Nie oznacza to, że należy zaniechać dążenia do pisania bezbłędnego kodu,
wprost przeciwnie, jakość kodu powinna być jednym z naszych
priorytetów, ale należy się też pogodzić z faktem, że błędy będą
występować i powinniśmy być na takie sytuacje przygotowani. Jak to
mówią "najwyższą formą zaufania jest kontrola".
</p><p>Na potrzeby tego wykładu zdefiniujemy bardzo luźno błąd jako
wystąpienie sytuacji, która wystąpić nie powinna. Nie będziemy też
interesować się bardzo tym, jak błedy wykrywać, ale raczej co zrobić,
kiedy takowy wykryjemy. W następnym podrozdziale omówię bardzo
pobieżnie różne możliwości reakcji na wystąpienie błędu i wprowadzę 
pojęcie wyjątku. Reszta wykładu będzie poświęcona zagadnieniom związanym
z pisaniem kodu używającego wyjątków.
</p>
<br />
<h2>Wykrywanie błędów</h2>
<p>Zanim przejdziemy do sytuacji, w której wiemy, że wystąpił bład, musimy poświęcić kilka akapitów na zastanowienie się czy w ogóle należy błedy wykrywać i obsługiwać. Nawet jeśli większość z Państwa krzyknie "oczywiście, że
tak" (choć podejrzewam, że większość tego sama nie robi: kto ostatnio sprawdzał wartość zwróconą przez funkcję <span class="geshifilter"><code class="text geshifilter-text">printf</code></span>?), to
i tak pozostaje pytanie, jakie błędy będziemy starali się wykrywać.
</p><p>Na to pytanie nie ma jednoznacznej odpowiedzi, jak zresztą na
większość pytań dotyczących decyzji projektowych. Różne projekty
wymagają różnego poziomu niezawodności, a więc i różnych zabezpieczeń.
</p><p>Na jednym końcu są programy, które po prostu nie mogą "paść", na
drugim np. niektóre progamy symulacyjne, które wykonują się w
godzinę lub mniej. 
Nawet jednak w tej ostatniej sytuacji, różne formy obsługi błędów 
mogą  nam bardzo pomóc w debugowaniu. Linijki typu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">NULL</span>==<span style="color: #000000;">&#40;</span>fin=<span style="color: #0000dd;">fopen</span><span style="color: #000000;">&#40;</span>input_file_name,<span style="color: #666666;">&quot;r&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    <span style="color: #0000dd;">fprintf</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">stderr</span>,<span style="color: #666666;">&quot;cannot open file input_file_name);
    exit(1); 
  }
}</span></pre></div>
<p>lub</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">NULL</span>==<span style="color: #000000;">&#40;</span>p=<span style="color: #0000dd;">malloc</span><span style="color: #000000;">&#40;</span>n_bytes<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    <span style="color: #0000dd;">fprintf</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">stderr</span>,<span style="color: #666666;">&quot;cannot allocate memory for ...&quot;</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #0000dd;">exit</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>
<p>mogą nam oszczędzić jeśli nie godzin, to wielu minut frustracji.
Proszę zwrócić uwagę, że oba przykłady dotyczą  zasobów
zewnętrznych, nie do końca pod naszą kontrolą i tym bardziej powinny
być sprawdzane, zwłaszcza, że  będzie nas to kosztować minutę pisania
i prawie tyle co nic w trakcie wykonania.
</p>
<br />
<h3>Kontrola zakresu</h3>
<p>A co z bardziej kosztownymi testami? Typowym przykładem jest
sprawdzanie zakresu. Czy np. nasz stos <span class="geshifilter"><code class="text geshifilter-text">Stack</code></span> powinien 
sprawdzać, czy wykonujemy <span class="geshifilter"><code class="text geshifilter-text">pop</code></span> lub <span class="geshifilter"><code class="text geshifilter-text">top</code></span> na stosie pustym 
albo <span class="geshifilter"><code class="text geshifilter-text">push</code></span> na stosie pełnym? Czy powinniśmy sprawdzać 
poprawność podanego indeksu w wyrażeniach <span class="geshifilter"><code class="text geshifilter-text">v[i]</code></span>?
</p><p>Mam nadzieję, że Państwo nie oczekują jednoznacznej odpowiedzi na te
pytania, bo jej po prostu nie ma. Niestety, tego rodzaju testy mogą być
bardzo kosztowne. Operacje dostępu do elementów są bardzo proste,
koszt testu będzie pewnie dominujący, a te operacje mogą być bardzo
często wykonywane. Z drugiej strony  błędy przekroczenia zakresu
są bardzo "wredne". Rozważmy np. taki prosty kod:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;int,<span style="color: #0000dd;">5</span>&gt; s;
&nbsp;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;<span style="color: #0000dd;">1000</span>;i++<span style="color: #000000;">&#41;</span>
    s.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&#41;</span>;
&nbsp;
  <span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span> 
    std::<span style="color: #00eeff;">cerr</span>&lt;&lt;++i&lt;&lt;<span style="color: #666666;">&quot; &quot;</span>&lt;&lt;s.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;</pre></div>

<p>( Źródło: overflow.cpp)
</p><p>Na moim komputerze powyższy program wykonał 20981 operacji <span class="geshifilter"><code class="text geshifilter-text">pop()</code></span>,
zanim padł z komunikatem <tt>Naruszenie ochrony pamięci</tt>.  Proszę
zauważyć, że najpierw zapisał 995 liczb w pamięci należącej nie wiadomo
do kogo! Skutki takiego błędu mogą więc wystąpić w zupełnie innym
miejscu programu. 
</p><p>Nie ma dobrego rozwiązania tego dylematu, ale zawsze może pomóc zdrowy
rozsądek. Użycie sprawdzenia zakresu w operacji mnożenia macierzy
miałoby katastrofalne skutki dla wydajności kodu. Z drugiej strony
jest to prosty kod, w którym łatwo zapewnić aby indeksy nie wychodziły
poza zakres. Tutaj więc kontrola zakresu jest niewskazana. 
</p><p>Częstym rozwiązaniem jest włączanie kontroli zakresu podczas
debugowania i wyłączanie jej w "produkcyjnej" wersji programu.  Moim
zdaniem może to być bardzo pożyteczne, zwłaszcza w językach, które
dopuszczają włączanie i wyłączanie sprawdzania zakresów za pomocą
opcji kompilacji (oczywiście może to dotyczyć tylko typów
wbudowanych). W przypadku stosu, mogą  nam się przydać w tym celu
klasy wytyczne, opracowane w wykładzie 7. Może warto
dodać, że kontenery STL, dostarczające operację indeksowania,
dostarczają również metodę dostępu ze sprawdzaniem: <span class="geshifilter"><code class="text geshifilter-text">at(int)</code></span>.
</p>
<br />
<h2>Obsługa błędów</h2>
<p>Załóżmy więc, że w pogramie mamy przynajmniej kilka linijek
wykrywających potencjalne błędy.  No i stało się. Wiemy już, że w
programie wystąpił błąd, co teraz? Mamy wiele możliwości, wymienię
tylko kilka z nich:
</p>

<ol><li> Kończymy program z ewentualnym komunikatem o błędzie.
</li><li> Kończymy program, ale najpierw sprzątamy po sobie: zwalniamy zasoby, których nie zwolni system operacyjny, zapisujemy dane, itp.
</li><li> Staramy się kontynuować program pomimo błędu, próbując go poprawić, obejść lub zrezygnować z części funkcjonalności. 
</li></ol>
<p>W tym wykładzie nie będzie interesować nas sama konkretna strategia,
ale sposób rozdzielenia procesu wykrycia błędu od wyboru strategii.
Jest to problem, który dotyczy każdego kodu, ale głównie funkcji
bibliotecznych.  Ich projektant/programista może wykryć, że w trakcie
ich wykonywania wystąpiła nieprawidłowość, ale nie może jednak wiedzieć
jak z takim błędem postąpić.  To jest decyzja osoby korzystającej z
tej funkcji. Musi więc istnieć jakiś mechanizm przekazywania tej
informacji z wywoływanej funkcji na zewnątrz do funkcji wywołującej.
</p><p>Najprostyszym sposobem jest zwrócenie jakiejś wartości sygnalizującej
błąd. Jeśli funkcja nie zwraca żadnego wyniku, to jest to proste;
jeśli jednak funkcja ma zwracać jakiś wynik, to nie zawsze da się
znaleźć taką wartość, która by jednoznacznie mogła definiować błąd.
Rozszerzenia tej metody, to zwrócenie informacji o przebiegu funkcji
poprzez dodatkowy argument przekazywany przez referencje.  Można też
ustawiać i odczytywać jakieś zmienne stanu.  Największą wadą tego
podejścia jest konieczność każdorazowego sprawdzania tych wartości, co
wymaga pisania dużej ilości trywialnego kodu. Z tego powodu
sprawdzanie poprawności wywołania takich funkcji jest często
opuszczane. W C++ dochodzi jeszcze niemożność zwrócenia wartości z
konstruktora (choć oczywiście możemy ustawić w nim zmienną stanu
informującą o powodzeniu konstrukcji).
</p>
<br />
<h2>Wyjątki</h2>
<p>C++ dostarcza nowego mechanizmu, jakim są wyjątki. Polega on na tym, że
funkcja która błąd wykryje i nie chce lub nie może go obsłużyć sama,
rzuca wyjątek, który może być dowolnym obiektem.  Rzucenie wyjątku
powoduje natychmiastowe przerwanie wykonywania funkcji.  Procedura
wywołująca może ten wyjątek złapać. Wyjątek niezłapany prowadzi do
zatrzymania programu, a więc wyjątki nie mogą zostać zignorowane.
Zilustruję to na przykładzie naszego stosu, do którego dodam
instrukcje rzucające wyjątki w przypadku przekroczenia zakresu
(dla prostoty nie będę korzystał z klas wytycznych):
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T = <span style="color: #0000ff;">int</span> , <span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">100</span>&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:	
  T _rep<span style="color: #000000;">&#91;</span>N<span style="color: #000000;">&#93;</span>;
  <span style="color: #0000ff;">size_t</span> _top;
<span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>:_top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span>T val<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>_top == N<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      throw <span style="color: #666666;">&quot;pushing on top of the full stack&quot;</span>;
    <span style="color: #000000;">&#125;</span>
    _rep<span style="color: #000000;">&#91;</span>_top++<span style="color: #000000;">&#93;</span>=val;
  <span style="color: #000000;">&#125;</span>
  T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
      throw <span style="color: #666666;">&quot;poping form an empty stack&quot;</span>;
    <span style="color: #000000;">&#125;</span>
    <span style="color: #0000ff;">return</span> _rep<span style="color: #000000;">&#91;</span>--_top<span style="color: #000000;">&#93;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span>     <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> <span style="color: #000000;">&#40;</span>_top==<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span>;</pre></div>

<p>( Źródło: stack_except.h)
</p><p>Polecenie <span class="geshifilter"><code class="text geshifilter-text">throw</code></span> służy właśnie do rzucania wyjątków. W tym wypadku 
rzucane są stałe napisowe, które będą automatycznie konwertowane na typ 
<span class="geshifilter"><code class="text geshifilter-text">const char *</code></span>.  
Wykonanie programu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  Stack&lt;int,<span style="color: #0000dd;">5</span>&gt; s;
  s.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
  s.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  s.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000; font-style: italic;">/* tu będzie rzucony wyjątek */</span>
&nbsp;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;<span style="color: #0000dd;">10</span>;i++<span style="color: #000000;">&#41;</span> 
  s.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&#41;</span>; <span style="color: #ff0000; font-style: italic;">/* tu też gdyby udało się tu dojść */</span>
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: overflow.cpp)
</p><p>spowoduje przerwanie programu w trakcie wykonywania drugiego polecenia
<span class="geshifilter"><code class="text geshifilter-text">pop</code></span>. Komunikat, który się przy tym pojawia jest zależny
od implementacji. 
</p><p>Wyjątki można łapać, korzystając z bloku <span class="geshifilter"><code class="text geshifilter-text">try</code></span>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">Stack&lt;int,<span style="color: #0000dd;">5</span>&gt; s;
  s.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
    s.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    s.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *msg<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    std::<span style="color: #00eeff;">cerr</span>&lt;&lt;msg&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
      <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;<span style="color: #0000dd;">10</span>;i++<span style="color: #000000;">&#41;</span> 
    s.<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *msg<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    std::<span style="color: #00eeff;">cerr</span>&lt;&lt;msg&lt;&lt;std::<span style="color: #00eeff;">endl</span>;
  <span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: stack_except.cpp)
</p><p>W bloku <span class="geshifilter"><code class="text geshifilter-text">try</code></span> umieszczamy instrukcje, które mogą potencjalnie rzucić
wyjątek. Za blokiem <span class="geshifilter"><code class="text geshifilter-text">try</code></span> umieszczamy jedną lub więcej klauzul <span class="geshifilter"><code class="text geshifilter-text">catch</code></span>,
które te wyjątki łapią. Wyjątek rzucony w bloku <span class="geshifilter"><code class="text geshifilter-text">try</code></span>  powoduje przekazanie
sterowania do pierwszej pasującej klauzuli <span class="geshifilter"><code class="text geshifilter-text">catch</code></span>.
</p>
<br />

<h2>Wyjątki złapane</h2>
<p>Przyjrzyjmy się teraz dokładniej mechanizmowi rzucania i łapania
wyjątków.  Rozważmy prosty przykład:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> X <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">int</span> val;
  X<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>:val<span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>cerr&lt;&lt;<span style="color: #666666;">&quot;constructing &quot;</span>&lt;&lt;val&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;<span style="color: #000000;">&#125;</span>
   X<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>cerr&lt;&lt;<span style="color: #666666;">&quot;destructing &quot;</span>&lt;&lt;val&lt;&lt;endl;<span style="color: #000000;">&#125;</span>  
<span style="color: #000000;">&#125;</span>;
&nbsp;
<span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span>
  X x<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
  throw <span style="color: #0000dd;">0</span>;
  cout&lt;&lt;<span style="color: #666666;">&quot;f&quot;</span>;
<span style="color: #000000;">&#125;</span>;
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
  X  y<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
    X z<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#41;</span>;
    f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    cout&lt;&lt;<span style="color: #666666;">&quot;try&quot;</span>;
  <span style="color: #000000;">&#125;</span> 
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>cout&lt;&lt;<span style="color: #666666;">&quot;zlapalem double-a&quot;</span>;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>cout&lt;&lt;<span style="color: #666666;">&quot;zlapalem int-a&quot;</span>;<span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>cout&lt;&lt;<span style="color: #666666;">&quot;zlapalem cos &quot;</span>;<span style="color: #000000;">&#125;</span>
&nbsp;
 cout&lt;&lt;<span style="color: #666666;">&quot;main&quot;</span>;
<span style="color: #000000;">&#125;</span></pre></div>


<p>( Źródło: caught.cpp)
</p><p>Oto wynik wykonania tego programu:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">constructing <span style="color: #0000dd;">2</span>
constructing <span style="color: #0000dd;">3</span>
constructing <span style="color: #0000dd;">1</span>
destructing <span style="color: #0000dd;">1</span>
destructing <span style="color: #0000dd;">3</span>
zlapalem int-a
main
destructing <span style="color: #0000dd;">2</span></pre></div>

<p>Co możemy zauważyć? 
</p>
<ol><li> Wyjątek przerwał wykonywanie funkcji <span class="geshifilter"><code class="text geshifilter-text">f()</code></span> i bloku <span class="geshifilter"><code class="text geshifilter-text">try</code></span>, sterowanie zostało przekazana do klauzuli <span class="geshifilter"><code class="text geshifilter-text">catch(int)</code></span>. 
</li><li> Przedtem  wywołane zostały destruktory obiektów <span class="geshifilter"><code class="text geshifilter-text">x</code></span> i <span class="geshifilter"><code class="text geshifilter-text">z</code></span>, czyli lokalnych obiektów w zasięgu bloku <span class="geshifilter"><code class="text geshifilter-text">try</code></span>. Ten proces nazywamy "zwijaniem stosu".
</li><li> Po wykonaniu klauzuli <span class="geshifilter"><code class="text geshifilter-text">catch</code></span> sterowanie zostało przekazane do następnego wyrażenia.
</li></ol>
<p>Klauzula <span class="geshifilter"><code class="text geshifilter-text">catch(...)</code></span> wyłapuje każdy wyjątek. Jeśli np. pominiemy
klauzulę <span class="geshifilter"><code class="text geshifilter-text">catch(int)</code></span>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>cout&lt;&lt;<span style="color: #666666;">&quot;zlapalem double-a&quot;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #ff0000;">//catch(int){cout&lt;&lt;&quot;zlapalem int-a&quot;;}</span>
<span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>cout&lt;&lt;<span style="color: #666666;">&quot;zlapalem cos &quot;</span>;<span style="color: #000000;">&#125;</span></pre></div>

<p>to wynikiem wywołania programu będzie:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">constructing <span style="color: #0000dd;">2</span>
constructing <span style="color: #0000dd;">3</span>
constructing <span style="color: #0000dd;">1</span>
destructing <span style="color: #0000dd;">1</span>
destructing <span style="color: #0000dd;">3</span>
zlapalem <span style="color: #0000dd;">cos</span>
main
destructing <span style="color: #0000dd;">2</span></pre></div>

<p>Z tego przykładu widać też, że w przypadku dopasowywania klauzul
<span class="geshifilter"><code class="text geshifilter-text">catch</code></span> nie następuje niejawna konwersja argumentów.
</p>
<br />
<h2>Niezłapane wyjątki</h2>
<p>A co się stanie, jeśli wyjątku nie złapiemy? Żeby się o tym przekonać
usuniemy kolejną klauzulę <span class="geshifilter"><code class="text geshifilter-text">catch</code></span>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>cout&lt;&lt;<span style="color: #666666;">&quot;zlapalem double-a&quot;</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #ff0000;">//catch(int){cout&lt;&lt;&quot;zlapalem int-a&quot;;}</span>
<span style="color: #ff0000;">//catch(...){cout&lt;&lt;&quot;zlapalem cos &quot;;}</span></pre></div>

<p>Wynik programu jest teraz zupełnie inny:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">constructing <span style="color: #0000dd;">2</span>
constructing <span style="color: #0000dd;">3</span>
constructing <span style="color: #0000dd;">1</span>
terminate called after throwing an instance of <span style="color: #666666;">'int'</span>
<span style="color: #0000dd;">Abort</span></pre></div>

<p>Niezłapany wyjątek spowodował wywołanie funkcji <span class="geshifilter"><code class="text geshifilter-text">abort()</code></span>, która
zakończyła program bez wywołania  destruktorów. Ściśle rzecz
biorąc, niezłapany wyjątek wywołuje funkcję <span class="geshifilter"><code class="text geshifilter-text">terminate()</code></span>, która z
kolei domyślnie wywołuje funkcję <span class="geshifilter"><code class="text geshifilter-text">abort()</code></span>. Co do tego, czy wywoływane
są destruktory lokalnych obiektów (zwijanie stosu), to jest to
zachowanie zależne od implementacji.  Jak widać, w implementacji
<span class="geshifilter"><code class="text geshifilter-text">g++</code></span> w przypadku niezłapania wyjątku destruktory obiektów nie są
wywoływane.
</p><p>Domyślne zachowanie funkcji <span class="geshifilter"><code class="text geshifilter-text">terminate()</code></span> można zmienić, ustawiając
własną funkcję, za pomocą:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>*terminate_handler<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span><span style="color: #000000;">&#41;</span>;
terminate_handler set_terminate<span style="color: #000000;">&#40;</span>terminate_handler new_terminate<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>Funkcja ustawiana w tym poleceniu nie może zwrócić sterowania, taka
próba kończy sie wywołaniem funkcji <span class="geshifilter"><code class="text geshifilter-text">abort()</code></span>. Oznacza to, że funkcja
<span class="geshifilter"><code class="text geshifilter-text">new_terminate()</code></span> musi kończyć się wywołaniem <span class="geshifilter"><code class="text geshifilter-text">abort()</code></span> lub
<span class="geshifilter"><code class="text geshifilter-text">exit()</code></span>.
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> my_terminate<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>std::<span style="color: #00eeff;">cerr</span>&lt;&lt;<span style="color: #666666;">&quot;terminating &quot;</span>&lt;&lt;std::<span style="color: #00eeff;">endl</span>;exit<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;<span style="color: #000000;">&#125;</span>
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  std::<span style="color: #00eeff;">set_terminate</span><span style="color: #000000;">&#40;</span>my_terminate<span style="color: #000000;">&#41;</span>;
  throw <span style="color: #0000dd;">0</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: terminate.cpp)
</p>
<br />
<h2>Wyjątki w destruktorach</h2>
<p>Jeśli podczas opisanego powyżej procesu obsługi wyjątku, wywołana
zostanie funkcja, która sama wywoła wyjątek, to program zostanie
natychmiast przerwany wykonaniem funkcji <span class="geshifilter"><code class="text geshifilter-text">terminate()</code></span> (nie dotyczy
to już funkcji wywoływanych wewnątrz klauzuli <span class="geshifilter"><code class="text geshifilter-text">catch</code></span>).  W
szczególności stanie się to, jeśli któryś z destruktorów wywoływanych w
trakcie zwijania stosu rzuci wyjątek:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> X <span style="color: #000000;">&#123;</span>
  ~X<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    std::<span style="color: #00eeff;">cerr</span>&lt;&lt;std::<span style="color: #00eeff;">uncaught_exception</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
    throw <span style="color: #0000dd;">0</span>;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span> ;
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">try</span> 
    <span style="color: #000000;">&#123;</span>
      X x;
    <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
    X x;
    throw <span style="color: #0000dd;">0</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span></pre></div>
<p>( Źródło: destruktor.cpp)
</p><p>W powyższym kodzie destruktor klasy <span class="geshifilter"><code class="text geshifilter-text">X</code></span> jest wołany dwa razy. Po raz
pierwszy, podczas wychodzenia z pierwszego bloku <span class="geshifilter"><code class="text geshifilter-text">try</code></span>. Jest to
normalne wywołanie spowodowane wyjściem poza zakres. 
Destruktor rzuca wyjątek, który zostaje wyłapany przez
klauzulę <span class="geshifilter"><code class="text geshifilter-text">catch(int)</code></span> na końcu bloku. Drugi raz destruktor jest
wołany jako część zwijania stosu po wyjątku rzuconym jawnie w drugim bloku
<span class="geshifilter"><code class="text geshifilter-text">try</code></span>. Mimo że łapiemy wyjątki <span class="geshifilter"><code class="text geshifilter-text">int</code></span>, i tak w tej sytuacji
wywoływana jest funkcja <span class="geshifilter"><code class="text geshifilter-text">terminate()</code></span>, a w konsekwencji i
<span class="geshifilter"><code class="text geshifilter-text">abort()</code></span>. Jest to  jeden z powodów, dla których destruktory
nie powinny rzucać wyjątków. Funkcja <span class="geshifilter"><code class="text geshifilter-text">uncaught_exception()</code></span>
umożliwia rozróżnienie tych dwu kontekstów wywołania destruktora.
Zwraca ona prawdę, jeśli jakiś wyjątek jest właśnie obsługiwany.
</p><p>Inne powody nie rzucania wyjątków z destruktorow wiążą się z dynamiczną
alokacją pamięci  i zostaną omówione w kolejnym  wykładzie.
</p>
<br />

<h2>Hierachie wyjątków</h2>
<p>Jako wyjątek może zostać wyrzucony dowolny obiekt. Umożliwia  nam to
grupowanie wyjątków w hierarchie za pomocą dziedziczenia. Zilustrujemy
to za pomocą hierachii wyjątków z biblioteki standardowej, przedstawionej
na rysunku 13.1. 
</p>

<span class="inline inline-center"><img src="http://smurf.mimuw.edu.pl/sites/default/files/images/Cpp-13-1.png" alt="Rysunek 13.1. Hierarchia wyjątków biblioteki standardowej." title="Rysunek 13.1. Hierarchia wyjątków biblioteki standardowej."  class="image image-_original " width="594" height="342" /><span class="caption"><strong>Rysunek 13.1. Hierarchia wyjątków biblioteki standardowej.</strong></span></span>

<p>Można z niej korzystać np. następująco:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
        throw domain_error<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> ;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>invalid_argument &amp;e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    cerr&lt;&lt;e.<span style="color: #00eeff;">what</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>logic_error &amp;e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    cerr&lt;&lt;<span style="color: #666666;">&quot;logic &quot;</span>&lt;&lt;e.<span style="color: #00eeff;">what</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>exception &amp;e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    cerr&lt;&lt;<span style="color: #666666;">&quot;some exception &quot;</span>&lt;&lt;e.<span style="color: #00eeff;">what</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>&lt;&lt;<span style="color: #666666;">&quot;&quot;</span>;
  <span style="color: #000000;">&#125;</span> 
<span style="color: #000000;">&#125;</span></pre></div>
<p>( Źródło: hierarchy.cpp)
</p><p>Kolejność klauzul <span class="geshifilter"><code class="text geshifilter-text">catch</code></span> jest ważna, ponieważ klauzule są
sprawdzane po kolei i pierwsza, która pasuje, zostanie wykonana.
Gdybyśmy więc podali kaluzulę <span class="geshifilter"><code class="text geshifilter-text">catch(Exception &amp;e)</code></span> jako pierwszą,
przechwyciła by ona wszystkie standardowe wyjątki. Ważne jest też, aby
korzystając z hierarchii dziedziczenia,  przechwytywać wyjątki przez
referencję.  Inaczej nie zostaną wywołane poprawne funkcje wirtualne.
Zachęcam do eksperymentów z powyższym kodem.
</p>
<br />
<h2>Deklaracje wyjątków</h2>
<p>C++ pozwala na deklarowanie listy możliwych wyjątków rzucanych z
funkcji.  Służy do tego deklaracja <span class="geshifilter"><code class="text geshifilter-text">throw(...)</code></span> umieszczana za
deklaracją listy argumentów funkcji, np.:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> no_throw<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>

<p>deklaruje, że funkcja <span class="geshifilter"><code class="text geshifilter-text">no_throw</code></span> nie rzuci żadnego wyjątku, natomiast
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> throw_std<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span>exception<span style="color: #000000;">&#41;</span>;</pre></div>

<p>deklaruje, że funkcja <span class="geshifilter"><code class="text geshifilter-text">throw_std</code></span> będzie rzucać tylko wyjątki ze
standardowej hierarchii. Brak deklaracji oznacza, że funkcja może rzucać
co chce. 
</p><p>Niestety, C++ nie dostarcza nam praktycznie żadnych mechanizmów, które
by mogły wymusić konsystencję tych deklaracji. Rozważmy implementację 
funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>throw i;<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">void</span> g<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>throw <span style="color: #0000dd;">0</span>;<span style="color: #000000;">&#125;</span>; 
<span style="color: #0000ff;">void</span> no_throw<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>f<span style="color: #000000;">&#40;</span>i;<span style="color: #000000;">&#125;</span>;</pre></div>

<p>Funkcja <span class="geshifilter"><code class="text geshifilter-text">f</code></span> proklamuje całemu światu, że może rzucać wyjątek
(poprzez brak deklaracji, że nie może), podobnie funkcja <span class="geshifilter"><code class="text geshifilter-text">g()</code></span>, a pomimo to kompilator nie
pozwala na to, aby wywołać ją wewnątrz funkcji, która jawnie deklaruje,
że wyjątku nie rzuci. Proszę to porównać np. z zastosowaniem
kwalifikatora <span class="geshifilter"><code class="text geshifilter-text">const</code></span>: funkcja zadeklarowana jako <span class="geshifilter"><code class="text geshifilter-text">const</code></span> nie
może wywołać funkcji, które <span class="geshifilter"><code class="text geshifilter-text">const</code></span> nie są. W przypadku wyjątków
narzucenie takiej konsystencji spowodowałoby, że potrzeba by
przerabiać ogromne ilości kodu napisanego, zanim mechanizm wyjątków
stał się używany. Sprawia to niestety, że deklaracje wyjątków nie są
zbyt użyteczne, łatwo bowiem niechcący napisać kod, który je złamie.  A
konsekwencje tego są poważne. Sprawdzania konsystencji w czasie
kompilacji wprawdzie nie ma, ale jest sprawdzanie w czasie wykonania.
Jeżeli funkcja rzuci wyjątek, który nie znajduje się na jej liście
zadeklarowanych wyjątków, to następuje wywołanie funkcji
<span class="geshifilter"><code class="text geshifilter-text">unexpected()</code></span>, która domyślnie wywołuje <span class="geshifilter"><code class="text geshifilter-text">abort()</code></span>. Nawet
złapanie tego wyjątku nic nie pomoże.
</p><p>Kolejnym problemem są szablony funkcji i metody szablonów klas. Ich
projektant nie może przewidzieć, z jakimi argumentami zostaną one
konkretyzowane, a więc jakie wyjątki mogą zostać rzucone. Dlatego w
szablonach lepiej deklaracje wyjątków pomijać. W ogóle, deklaracje
wyjątków należy umieszczać tam, gdzie uważamy, że rzucenie każdego innego
wyjątku jest przejawem poważnego błędu. Najczęściej jest to sytuacja,
kiedy chcemy zadeklarować, że dana funkcja w ogóle nie rzuca wyjątków. 
Jak już pisałem taką własność powinny posiadać destruktory.
</p>
<br />
<h3>Niespodziewane wyjątki</h3>
<p>Podobnie jak w przypadku funkcji <span class="geshifilter"><code class="text geshifilter-text">terminate()</code></span>, możemy podstawić
własną funkcję <span class="geshifilter"><code class="text geshifilter-text">unexpected()</code></span>. Podobnie jak <span class="geshifilter"><code class="text geshifilter-text">terminate()</code></span> funkcja
<span class="geshifilter"><code class="text geshifilter-text">unexpected()</code></span> nie zwraca sterowania, może za to sama rzucić
wyjątek.  W ten sposób możemy jej użyć do "podmiany"
niespodziewanego wyjątku na inny. Zobaczmy jak to działa:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  throw <span style="color: #666666;">&quot;niespodzianka!&quot;</span>;
<span style="color: #000000;">&#125;</span>;
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
  f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: unexpected.cpp)
</p><p>Ponieważ <span class="geshifilter"><code class="text geshifilter-text">f()</code></span>  rzuca <span class="geshifilter"><code class="text geshifilter-text">const char *</code></span>, a deklaruje tylko <span class="geshifilter"><code class="text geshifilter-text">int</code></span>-a,
powyższy program wywoła funkcję <span class="geshifilter"><code class="text geshifilter-text">unexpected()</code></span>, która przerwie program.
Jeżeli podmienimy wyjątek poprzez ustawienie odpowiedniej funkcji:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> unexpected_handler<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>throw <span style="color: #0000dd;">0</span>;<span style="color: #000000;">&#125;</span>;
std::<span style="color: #00eeff;">set_unexpected</span><span style="color: #000000;">&#40;</span>unexpected_handler<span style="color: #000000;">&#41;</span>;</pre></div>

<p>to zamiast <span class="geshifilter"><code class="text geshifilter-text">const char *</code></span> zostanie rzucony <span class="geshifilter"><code class="text geshifilter-text">int</code></span> i złapany przez
klauzulę <span class="geshifilter"><code class="text geshifilter-text">catch(...)</code></span>. Tak się stanie ponieważ <span class="geshifilter"><code class="text geshifilter-text">int</code></span> jest na
liście wyjątków funkcji <span class="geshifilter"><code class="text geshifilter-text">f()</code></span>. Gdyby nie był, to zostałaby wywołana
funkcja <span class="geshifilter"><code class="text geshifilter-text">terminate()</code></span>. Jeżeli jednak deklaracja wyjątków funkcji
<span class="geshifilter"><code class="text geshifilter-text">f()</code></span> zawierać będzie wyjątek <span class="geshifilter"><code class="text geshifilter-text">std::bad_exception</code></span>, to każdy
wyjątek rzucony przez <span class="geshifilter"><code class="text geshifilter-text">unexpected()</code></span> i nie znajdujący się na liście
zadeklarowanych wyjątków funkcji <span class="geshifilter"><code class="text geshifilter-text">f()</code></span>, jest podmieniany na
<span class="geshifilter"><code class="text geshifilter-text">std::bad_exception()</code></span>:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span>,std::<span style="color: #00eeff;">bad_exception</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  throw <span style="color: #666666;">&quot;niespodzianka!&quot;</span>;
<span style="color: #000000;">&#125;</span>;
&nbsp;
<span style="color: #0000ff;">void</span> unexpected_handler<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>throw <span style="color: #0000dd;">3.1415926</span>;<span style="color: #000000;">&#125;</span>;
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  std::<span style="color: #00eeff;">set_unexpected</span><span style="color: #000000;">&#40;</span>unexpected_handler<span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
  f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">bad_exception</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: unexpected.cpp)
</p>
<h2>Wydajność wyjątków</h2>
<p>Autor pozycji <i>"Język C++ bardziej efektywny"</i> S. Meyers sugerował, że użycie mechanizmu
wyjątków może spowolnić program, nawet jeśli wyjątki nie będą rzucane.
Ponieważ od tego czasu minęło dobrych kilka lat, postanowiłem sam
sprawdzić, jak się sprawy mają. W tym celu skorzystałem z następujących 
programików:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">double</span> scin<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x,<span style="color: #0000ff;">bool</span> flag<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>flag<span style="color: #000000;">&#41;</span> throw <span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">return</span> <span style="color: #0000dd;">sin</span><span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">int</span> f=<span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">double</span> s=<span style="color: #0000dd;">0.0</span>;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;<span style="color: #0000dd;">100000000</span>;++i<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
    s+=scin<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">rand</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>/<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span><span style="color: #0000ff;">RAND_MAX</span>,f<span style="color: #000000;">&#41;</span>;
    <span style="color: #000000;">&#125;</span> <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: exceptions.cpp)
</p><p>oraz
</p>

<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">double</span> scin<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span> x,<span style="color: #0000ff;">bool</span> flag<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>flag<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">return</span> <span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">return</span> <span style="color: #0000dd;">sin</span><span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">int</span> f=<span style="color: #0000dd;">0</span>;
  <span style="color: #0000ff;">double</span> s=<span style="color: #0000dd;">0.0</span>;
  <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span>;i&lt;<span style="color: #0000dd;">100000000</span>;++i<span style="color: #000000;">&#41;</span>
    s+=scin<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">rand</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>/<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span><span style="color: #0000ff;">RAND_MAX</span>,f<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>

<p>( Źródło: no_exceptions.cpp)
</p><p>Jak widać drugi z nich nie ma nawet śladu wyjątków. W pierwszym podejściu 
ustawilem flagę <span class="geshifilter"><code class="text geshifilter-text">f</code></span> na zero, co powodowało, że żaden wyjątek nie był rzucany.
Czas wykonania obu programów (w sekundach) podany jest w poniższej tabelce:
</p>
<div align="center">
<table border="1">

<tr>
<td align="center">  </td><td>   nie rzucane wyjątki   </td><td>  bez wyjątków  </td><td>   rzucane wyjątki  </td><td>  <tt>return</tt>
</td></tr>
<tr>
<td align="center"> -O0
</td><td align="center">  15
</td><td align="center">  15
</td><td align="center">
</td><td align="center">
</td></tr>
<tr>
<td align="center"> -O1
</td><td align="center">  13
</td><td align="center">  4
</td><td align="center">
</td><td align="center">
</td></tr>
<tr>
<td align="center"> -O2
</td><td align="center">  13
</td><td align="center">  4
</td><td align="center">
</td><td align="center">
</td></tr>
<tr>
<td align="center"> -O3
</td><td align="center">  4
</td><td align="center">  4
</td><td align="center">  600
</td><td align="center">  4
</td></tr></table>
</div>
<p>Porównując kolumny 1 i 2, widać, że dla pełnej optymalizacji nie ma
żadnej różnicy. Szczegółowe badanie wykazało, że to włączenie opcji
<span class="geshifilter"><code class="text geshifilter-text">-finline-functions</code></span> powoduje skok prędkości pomiędzy dwoma
ostatnimi wierszami w pierwszej kolumnie. Ten sam efekt można uzyskać,
dodając do funkcji <span class="geshifilter"><code class="text geshifilter-text">scin</code></span> kwalifikator <span class="geshifilter"><code class="text geshifilter-text">inline</code></span>.
</p><p>Następnie porównałem koszt zwykłego powrotu z funkcji z kosztem
rzucenia wyjątku. Wyniki są przedstawione w dwóch ostatnich kolumnach
tabelki.  Tu widać dramatyczną różnicę: obsługa wyjątku jest ponad 100
razy wolniejsza.
</p>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Overflow.cpp">Overflow.cpp</a></td><td>240 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_except.h">Stack_except.h</a></td><td>543 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_except.cpp">Stack_except.cpp</a></td><td>330 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Caught.cpp">Caught.cpp</a></td><td>469 bajtów</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Terminate.cpp">Terminate.cpp</a></td><td>440 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Destruktor.cpp">Destruktor.cpp</a></td><td>242 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Hierarchy.cpp">Hierarchy.cpp</a></td><td>1.1 KB</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Unexpected.cpp">Unexpected.cpp</a></td><td>283 bajty</td> </tr>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Exceptions.cpp">Exceptions.cpp</a></td><td>324 bajty</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/No_exceptions.cpp">No_exceptions.cpp</a></td><td>292 bajty</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1348" class="section-2">
  <h1 class="book-heading">Zarządzenie pamięcią</h1>
  <h2>Wstęp</h2>
<hr />
<br />
<p>Dynamiczna alokacja pamięci to bardzo ważny element języka C.  W C do
przydziału i zwolnienia pamięci służą odpowiedno funkcje <span class="geshifilter"><code class="text geshifilter-text">malloc</code></span>
(i jego "kuzyni") i <span class="geshifilter"><code class="text geshifilter-text">free</code></span>. W C++ są one również dostępne, ale 
używane są raczej wyrażenia
<span class="geshifilter"><code class="text geshifilter-text">new</code></span> i <span class="geshifilter"><code class="text geshifilter-text">delete</code></span>. Ta zmiana ma poważną przyczynę: te wyrażenia
robią więcej niż tylko przydzielanie lub zwalnianie pamięci. Wyrażenie
<span class="geshifilter"><code class="text geshifilter-text">new</code></span> tworzy nowy obiekt, a więc nie tylko przydziela pamięc, ale
również inicjalizuje go, używając odpowiedniego konstruktora. Wyrażenie
<span class="geshifilter"><code class="text geshifilter-text">delete</code></span> niszczy obiekt, wywołując jego destruktor i dopiero potem
zwalnia zajętą przez niego pamięć. W tym wykładzie pokażę, co tak
naprawdę się dzieje, gdy dynamicznie tworzymy lub niszczymy obiekty.
</p><p>Wyrażenia <span class="geshifilter"><code class="text geshifilter-text">new</code></span> i <span class="geshifilter"><code class="text geshifilter-text">delete</code></span> posługują się systemowymi alokatorami
i dealokatorami pamięci. C++ daje nam możliwość 
wykorzystania w tym celu własnych implementacji.
Napisanie jednak  bardziej wydajnego alokatora
pamięci niż alokator standardowy nie jest łatwe.
Można jednak próbować zwiększyć wydajność przydzielania i zwalniania
pamięci w sytuacjach szczególnych, np. jeśli 
używamy dużej ilości małych obiektów o stałym rozmiarze, które muszą
być dynamicznie tworzone i niszczone. Pod koniec wykładu podamy prosty
schemat obsługi pamięci mający zastosowanie w takiej sytuacji.
</p>
<br />
<h2>new</h2>
<hr />
<p>Przyjrzyjmy się najpierw dokładnie procesowi tworzenia pojedynczego, nowego
obiektu za pomocą wyrażenia <span class="geshifilter"><code class="text geshifilter-text">new</code></span>:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">X *p  = <span style="color: #0000dd;">new</span> X inicjalizator;</pre></div>
<p>lub 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">X *p  = <span style="color: #0000dd;">new</span> <span style="color: #000000;">&#40;</span>lista_argumentow<span style="color: #000000;">&#41;</span> X inicjalizator;</pre></div>
<p>Druga forma jest nazywana z przyczyn historycznych "placement new"
(pochodzenie tej nazwy wyjaśnię poniżej);  <span class="geshifilter"><code class="text geshifilter-text">inicjalizator</code></span>
może być dowolnym wyrażeniem inicjalizującym, np.:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">X *p1 = <span style="color: #0000dd;">new</span> X;
X *p2 = <span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
X x,y;
X *p3 = <span style="color: #0000dd;">new</span> X = x;
X *p4 = <span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#40;</span>y<span style="color: #000000;">&#41;</span>;
X *p5 = <span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>Oczywiście zakładamy istnienie odpowiednich konstruktorów. 
</p>
<br />
<h4>Przydział pamięci</h4>
<p>Najpierw przydzielana jest "goła" (raw) pamięć. Służy do tego
funkcja przydziału pamięci (alokator) <span class="geshifilter"><code class="text geshifilter-text">operator new()</code></span>: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> *tmp = operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>lub 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> *tmp = operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span>,lista_argumentow<span style="color: #000000;">&#41;</span>;</pre></div>
<p>jeśli użyliśmy formy placement.  Nazwa placement pochodzi od operatora
<span class="geshifilter"><code class="text geshifilter-text">new</code></span> dostarczanego w bibliotece standardowej, który przyjmuje drugi
argument typu <span class="geshifilter"><code class="text geshifilter-text">void *</code></span>:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span>* operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span>std::<span style="color: #0000ff;">size_t</span> size, <span style="color: #0000ff;">void</span>* ptr<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> ptr;<span style="color: #000000;">&#125;</span>;</pre></div>
<p>Operator ten nie przydziela żadnej pamięci tylko zwraca wskaźnik
<span class="geshifilter"><code class="text geshifilter-text">ptr</code></span>.  Jego wywołanie nie może się nie powieść, dlatego nie rzuca
żadnych wyjątków.  Ta forma operatora służy do 
umieszczania (placement) obiektu w
zadanym obszarze pamięci:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> *p =<span style="color: #0000dd;">malloc</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
X *px=<span style="color: #0000dd;">new</span> <span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span> X;</pre></div>
<p>stąd jego nazwa.
</p><p>Środowisko C++ dostarcza jeszcze dwu wersji globalnych funkcji
<span class="geshifilter"><code class="text geshifilter-text">operator new()</code></span>:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span>* operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span>std::<span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">void</span>* operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span>std::<span style="color: #0000ff;">size_t</span> size, std::<span style="color: #00eeff;">nothrow_t</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>ale użytkownik może podać własne definicje, zarówno
globalne, jak i dla pojedynczych klas. Odpowiednia funkcja <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> jest najpierw wyszukiwana w klasie <span class="geshifilter"><code class="text geshifilter-text">X</code></span>, a następnie w
przestrzeni globalnej. Jeśli nie znajdzie się definicja odpowiadająca
podanym argumentom, to wystąpi błąd kompilacji. Np. jeśli zażądamy
stworzenia obiektu wyrażeniem: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">X *p = <span style="color: #0000dd;">new</span> X;</pre></div>
<p>to kompilator będzie szukał funkcji:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>a w drugiej kolejności:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> *tmp =::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>Wyrażenie
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">X *p = <span style="color: #0000dd;">new</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.15</span><span style="color: #000000;">&#41;</span> X;</pre></div>
<p>spowoduje poszukiwanie funkcji:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span>,<span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>lub
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span>,<span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>Pierwszy argument każdej funkcji <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> musi być typu
<span class="geshifilter"><code class="text geshifilter-text">size_t</code></span> i przekazywany jest przez niego rozmiar żądanego obszaru
pamięci.
</p><p>Każda funkcja <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> zwraca <span class="geshifilter"><code class="text geshifilter-text">void *</code></span>. W przypadku
powodzenia zwracany jest wskaźnik do przydzielonego obszaru pamięci:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> *p = operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1000</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>W przypadku niepowodzenia <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> może rzucić wyjątek
<span class="geshifilter"><code class="text geshifilter-text">std::bad_alloc</code></span> lub zwrócić wskaźnik zerowy.
</p>
<br />
<h4>Tworzenie obiektu </h4>
<p>Jeśli przydział pamięci  powiedzie się, tzn. <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> zwróci
niezerowy wskaźnik, to następuje wywołanie konstruktora klasy <span class="geshifilter"><code class="text geshifilter-text">X</code></span>
w celu stworzenia obiektu,
który jest umieszczany w przydzielonej pamięci.  Np:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">X *p = X<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>spowoduje wywołanie konstruktora:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">X::<span style="color: #00eeff;">X</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>jeśli takowy istnieje.  Jeśli konstrukcja się powiedzie (nie rzuci
wyjątku), to proces się kończy. Jeśli jednak wywołany konstruktor
rzuci wyjątek, który zostanie złapany, to wyrażenie <span class="geshifilter"><code class="text geshifilter-text">delete</code></span>
postara się zwolnić przydzieloną pamięć w "trybie awaryjnym".
</p>
<br />
<h4>Awaryjne zwolnienie pamięci</h4>
<p>W ramach takiej obsługi przerwania, zwalnianie pamięci przydzielonej przez <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> odbywa sie za pomocą odpowiadajacej mu wersji <span class="geshifilter"><code class="text geshifilter-text">operator delete</code></span>. 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> operator <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> *p,lista_argumentow<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p><span class="geshifilter"><code class="text geshifilter-text">operator delete</code></span> odpowiada wersji operatora <span class="geshifilter"><code class="text geshifilter-text">new</code></span> z taką sama listą argumentów. Jeśli lista argumentów jest niepusta, to 
taki operator nazywamy  placement delete.  
Przy wywoływaniu placement delete, przekazywana mu jest lista dodatkowych
argumentów, identyczna z listą dodatkowych argumentów operatora placement new, 
który pamięć przydzielił.
</p><p>Biblioteka C++ dostarcza globalnych implementacji operatorów
<span class="geshifilter"><code class="text geshifilter-text">delete</code></span>, odpowiadających trzem wspomnianym powyżej operatorom
<span class="geshifilter"><code class="text geshifilter-text">new</code></span>, ale można też dodawać własne definicje, zarówno w klasie jak
i w przestrzeni globalnej.  Jeśli kompilator nie znajdzie żadnej
odpowiedniej definicji <span class="geshifilter"><code class="text geshifilter-text">operator delete</code></span>, to żadna funkcja
zwalniająca nie zostanie wywołana. 
Rozważmy następujący przykład: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> X <span style="color: #000000;">&#123;</span>
X<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000; font-style: italic;">/* rzuca wyjątek typu int*/</span>
<span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#41;</span>; 
<span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> *p<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>
<p>Wyrażenie:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
X *p  = <span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>
<p>spowoduje wywołanie:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> *tmp=X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span>tmp<span style="color: #000000;">&#41;</span>;</pre></div>
<p>Dodanie do klasy <span class="geshifilter"><code class="text geshifilter-text">X</code></span> dwu operatorów:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span>,<span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#41;</span>; 
<span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> *p,<span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>spowoduje, że wyrażenie:   
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
X *p  = <span style="color: #0000dd;">new</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.14</span><span style="color: #000000;">&#41;</span> X<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>
<p>wywoła:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> *tmp=X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">3.14</span><span style="color: #000000;">&#41;</span>;
X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span>tmp,<span style="color: #0000dd;">3.14</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>Tę logikę zaburza trochę fakt istnienia wyróżnionej wersji funkcji
<span class="geshifilter"><code class="text geshifilter-text">operator delete</code></span>. Są to składowe klas posiadające drugi parametr
typu <span class="geshifilter"><code class="text geshifilter-text">size_t</code></span>:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> *p,<span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#41;</span>;</pre></div>
<p>Jeśli klasa nie posiada jednoargumentowego operatora <span class="geshifilter"><code class="text geshifilter-text">delete</code></span>, to
powyższy operator jest traktowany jak jednoargumentowy (non
placement). Za drugi argument podstawiany jest automatycznie rozmiar
zwalnianego obiektu.  Rozważmy, więc teraz taki przykład:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> X <span style="color: #000000;">&#123;</span>
X<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000; font-style: italic;">/* rzuca wyjątek typu int*/</span>
<span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#41;</span>; 
<span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> *p,<span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>
<p>Wyrażenie: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
X *p  = <span style="color: #0000dd;">new</span>  X<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>
<p>wywoła:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> *tmp=X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span>tmp,<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>a wyrażenie: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
X *p  = <span style="color: #0000dd;">new</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#41;</span>  X<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>
<span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>
<p>wywoła:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> *tmp=X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">3</span><span style="color: #000000;">&#41;</span>;
X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span>tmp,<span style="color: #0000dd;">3</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>Proszę zwrócić uwagę na różnicę w wartości drugiego argumentu przekazanego
do <span class="geshifilter"><code class="text geshifilter-text">operator delete</code></span>.
</p>
<br />
<h2>delete</h2>
<p>Stworzony dynamicznie obiekt niszczymy wyrażeniem
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000dd;">delete</span> p;</pre></div>
<p>które najpierw wywołuje destruktor klasy <span class="geshifilter"><code class="text geshifilter-text">X</code></span>:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">p-&gt;~X<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>Jeśli to wywołanie się nie powiedzie (zostanie rzucony wyjątek) to mamy
kłopot, bo nie zostanie wywołany <span class="geshifilter"><code class="text geshifilter-text">operator delete</code></span> w celu
zwolnienia pamięci.  Jest to kolejny powód aby nie rzucać wyjątków z
destruktora. Poniższy programik ilustruje ten problem, doprowadzając
do szybkiego wyczerpania pamięci:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">class</span> X <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">char</span> a<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">100000</span><span style="color: #000000;">&#93;</span>;
<span style="color: #0000ff;">public</span>:
  ~X<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>throw <span style="color: #0000dd;">0</span>;<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;
&nbsp;
main<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>
    X *p = <span style="color: #0000dd;">new</span> X;
    <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
      <span style="color: #0000dd;">delete</span> p;                      
    <span style="color: #000000;">&#125;</span>
    <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>
<p>Jeśli jednak nic złego się nie wydarzy, to po wywołaniu destruktora
przydzielona pamięć zostaje zwolniona za pomocą funkcji <span class="geshifilter"><code class="text geshifilter-text">operator delete()</code></span>. O zwalnianiu pamięci dużo już napisałem przy omawianiu wyrażenia <span class="geshifilter"><code class="text geshifilter-text">new</code></span>. W przypadku wyrażenia <span class="geshifilter"><code class="text geshifilter-text">delete</code></span> dzieje się to jednak trochę inaczej. Wyrażenie <span class="geshifilter"><code class="text geshifilter-text">delete</code></span> używa do zwolnienia pamięci tylko funkcji <span class="geshifilter"><code class="text geshifilter-text">operator delete()</code></span> niebędących typu
placement, tzn.  posiadające jeden lub ewentualnie dwa argumenty:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> operator <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> p<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">void</span> operator <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> p,<span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>Jest to niezależne od tego jaki <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> został użyty do
przydzielenia pamięci. Czyli jeśli zdefiniujemy, np.:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> X <span style="color: #000000;">&#123;</span>
X<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000; font-style: italic;">/* rzuca wyjątek typu int*/</span>
<span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#41;</span>; 
<span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span>,<span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#41;</span>; 
<span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span>,<span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#41;</span>; 
<span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> *p,<span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> *p,<span style="color: #0000ff;">double</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>
<p>to  wyrażenia: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">X p1 = <span style="color: #0000dd;">new</span>        X;
X p2 = <span style="color: #0000dd;">new</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>    X;
X p3 = <span style="color: #0000dd;">new</span> <span style="color: #000000;">&#40;</span><span style="color: #0000dd;">3.14</span><span style="color: #000000;">&#41;</span> X;
<span style="color: #0000dd;">delete</span> p3;
<span style="color: #0000dd;">delete</span> p2;
<span style="color: #0000dd;">delete</span> p1;</pre></div>
<p>spowodują wywołanie:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> *tmp1 = X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">void</span> *tmp2 = X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">void</span> *tmp3 = X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span>,<span style="color: #0000dd;">3.14</span><span style="color: #000000;">&#41;</span>;
X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span>tmp3,<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span>tmp2,<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span>tmp1,<span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<br />
<h2>operator new</h2>
<p>Z powyższego opisu widać, że wpływ na proces dynamicznego tworzenia
obiektu możemy mieć tylko poprzez własne definicje przydzielającego
pamięć operatora <span class="geshifilter"><code class="text geshifilter-text">new</code></span>. Zanim jednak napiszemy własną wersję
takiego operatora,  przyjrzymy się dokładniej właściwościom
standardowego operatora <span class="geshifilter"><code class="text geshifilter-text">new</code></span>.
</p><p>Jak już wiemy funkcja <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> musi posiadać co najmniej jeden
argument typu <span class="geshifilter"><code class="text geshifilter-text">size_t</code></span>. Standardowy <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> posiada
tylko ten jeden argument:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span>* operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span>std::<span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>Jeśli wszystko pójdzie dobrze, to <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> zwraca wskaźnik
do obszaru pamięci o rozmiarze co najmniej <span class="geshifilter"><code class="text geshifilter-text">size</code></span>; jeśli przydział
się nie powiedzie, to  rzuca wyjątek <span class="geshifilter"><code class="text geshifilter-text">std::bad_alloc</code></span>. 
</p><p>Dokładniej rzecz biorąc <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> rzuca wyjątek tylko wtedy
jeśli nie ustawiona jest funkcja obsługi błędów.  Do jej ustawiania 
służy funkcja:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#40;</span>new_handler*<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
new_hadler set_new_handler<span style="color: #000000;">&#40;</span>new_handler f<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>
<p>Funkcja <span class="geshifilter"><code class="text geshifilter-text">set_new_handler</code></span> ustawia nową funkcję obsługi błędów i
zwraca wskaźnik do poprzedniej funkcji obsługi lub <span class="geshifilter"><code class="text geshifilter-text">null</code></span>, jeśli
funkcja nie była ustawiona. Przekazanie wskaźnika <span class="geshifilter"><code class="text geshifilter-text">null</code></span> jako
argumentu powoduje, że nie będzie ustawiona żadna funkcja obsługi. To co
się dzieje wewnątrz <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> wygląda mniej wiecej tak:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">void</span> *p = przydziel pamiec;
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>proba powiodla sie<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">return</span> p;
    new_handler handler = set_new_handler<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;
    set_new_handler<span style="color: #000000;">&#40;</span>handler<span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>handler<span style="color: #000000;">&#41;</span>
       handler<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">else</span>   
       throw std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;    
  <span style="color: #000000;">&#125;</span></pre></div>
<p>Funkcja <span class="geshifilter"><code class="text geshifilter-text">handler</code></span> musi więc uzyskać więcej pamięci,  rzucić
wyjątek albo przerwać program. Może też ustawić inną funkcję obsługi,
inaczej program będzie się wykonywał w niekończącej się pętli.   
</p>
<br />
<h3>nothrow</h3>
<hr />
<p>Trzecia forma operatora <span class="geshifilter"><code class="text geshifilter-text">new</code></span> dostarczonego w bibliotece
standardowej to wersja <span class="geshifilter"><code class="text geshifilter-text">no_throw</code></span>. Operator <span class="geshifilter"><code class="text geshifilter-text">new</code></span> nie musi
rzucać wyjątku w razie niepowodzenia, ale musi wtedy zwrócić wskaźnik
zerowy (null). Aby wywołać tę wersję operatora <span class="geshifilter"><code class="text geshifilter-text">new</code></span> korzystamy 
z tego, że posiada ona drugi argument typu <span class="geshifilter"><code class="text geshifilter-text">nothrow_t</code></span>. 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span>* operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span>std::<span style="color: #0000ff;">size_t</span> size, 
                   <span style="color: #0000ff;">const</span> std::<span style="color: #00eeff;">nothrow_t</span>&amp;<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>W tym celu zdefiniowana została globalna stała typu <span class="geshifilter"><code class="text geshifilter-text">std::nothrow_t</code></span>:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span> 
<span style="color: #0000ff;">struct</span> nothrow_t <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> nothrow_t nothrow;
<span style="color: #000000;">&#125;</span></pre></div>
<p>Wersję <span class="geshifilter"><code class="text geshifilter-text">nothrow</code></span>  używamy więc następująco:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">X *p=<span style="color: #0000dd;">new</span> <span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">nothrow</span><span style="color: #000000;">&#41;</span> X;
<span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>!p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;</pre></div>
<br />
<h2>operator delete</h2>
<hr />
<p>Operator <span class="geshifilter"><code class="text geshifilter-text">delete</code></span> musi posiadać co najmniej jeden parametr będący
wskaźnikiem na zwalniany obszar pamięci:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> operator <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span>* ptr<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>Może to być wskaźnik zerowy, wtedy <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> nic nie robi.
Operator <span class="geshifilter"><code class="text geshifilter-text">delete</code></span> nie rzuca wyjątków.
Jak już opisałem to powyżej, dwuargumentowa wersja będąca składową klasy: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> operator <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span>* ptr<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>zachowuje się, w  większości przypadków jak wersja jednoargumentowa i
drugi argument zostaje automatycznie inicjalizowany rozmiarem zwalnianej 
pamięci.
</p>
<br />
<h2>Tablice</h2>
<hr />
<p>W powyższej dyskusji ograniczyłem się do tworzenia pojedynczych obiektów.
C++ zezwala na tworzenie tablic obiektów:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"> X *px  =     <span style="color: #0000dd;">new</span> X<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">10</span><span style="color: #000000;">&#93;</span>;</pre></div>
<p>Powyższe wyrażenie przydziela pamięć na 10 obiektów klasy <span class="geshifilter"><code class="text geshifilter-text">X</code></span> i
tworzy je za pomocą konstruktorów standardowych. 
W przypadku niepowodzenia konstrukcji niszczy skonstruowane obiekty (jeśli takowe istnieją) i zwalnia pamięć. Alokacja gołej pamięci jest dokonywana poprzez: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"> <span style="color: #0000ff;">void</span> * operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>i zwalniana za pomocą: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"> <span style="color: #0000ff;">void</span> * operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span>;</pre></div>
<h2>Przeładowywanie operatorów new i delete</h2>
<p>Po tym przydługim, technicznym wprowadzeniu, możemy wreszcie pokusić
się o napisanie własnego operatora <span class="geshifilter"><code class="text geshifilter-text">new</code></span> lub przeładowanie
istniejącego.  Do wyboru mamy wersję globalną lub funkcję składową
jakiejś klasy. Globalny alokator pamięci to poważna sprawa: dotyczy
działania całego programu i musi przydzielać pamięć dowolnych
rozmiarów.  Trudno będzie pod tym względem pobić działanie standardowej
wersji <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span>. Dlatego częściej będziemy chcieli definiować
operatory <span class="geshifilter"><code class="text geshifilter-text">new</code></span> we własnych klasach.  
</p><p>Na co musimy zwrócić w takim przypadku uwagę? Mam
nadzieję, że przekonałem Państwa, że do każdego operatora <span class="geshifilter"><code class="text geshifilter-text">new</code></span>
należy dopisać odpowiednią wersję operatora <span class="geshifilter"><code class="text geshifilter-text">delete</code></span>, inaczej nie
będziemy w stanie zapewnić bezpiecznego zachowania w sytuacji, w
której zostanie rzucony wyjątek z konstruktora. 
</p><p>Musimy też uważać na jawne zwalnianie pamięci. Jeśli w jednej klasie
zdefiniujemy kilka operatorów placement <span class="geshifilter"><code class="text geshifilter-text">new</code></span>, to nie będziemy
mogli ich rozróżnić w poleceniu <span class="geshifilter"><code class="text geshifilter-text">delete</code></span>!. 
</p><p>Musimy też zadbać aby <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> albo rzucał wyjątek, albo
zwracał wskaźnik pusty w razie niemożności przydziału pamięci.  W
innym przypadku wyrażenie <span class="geshifilter"><code class="text geshifilter-text">new</code></span> nie rozpozna, że przydział pamięci
się nie powiódł i będzie próbować tworzyć obiekt w nieprzydzielonej
pamięci.
</p><p>A co z obsługą <span class="geshifilter"><code class="text geshifilter-text">new_handler</code></span>? W zasadzie możemy jej nie
implementować i jeśli robimy to tylko na własny użytek, to pewnie nic
złego się nie stanie.  Ale jeśli <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> jest częścią
zewnętrznego interfejsu klasy, to prędzej czy później któryś z
użytkowników może się postarać skorzystać z <span class="geshifilter"><code class="text geshifilter-text">set_new_handler()</code></span>.
W końcu jeżeli nazywamy naszą funkcję <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span>, a nie np.
<span class="geshifilter"><code class="text geshifilter-text">allocate()</code></span>, to sugerujemy, że będzie ona miała funkcjonalność
<span class="geshifilter"><code class="text geshifilter-text">operator new</code></span>. Zwykle robimy to po to, aby skorzystać z
istniejącego już kodu, który używa wyrażeń <span class="geshifilter"><code class="text geshifilter-text">new</code></span>.  Jeśli chcemy
tworzyć obiekty i przydzielać pamięć, ale nie zależy nam na
interfejsie  <span class="geshifilter"><code class="text geshifilter-text">new</code></span>, lepiej nazwać nasze alokatory inaczej.
</p>
<br />
<h2>Memory pool</h2>
<hr />
<p>Jak już sygnalizowałem na wstępie, konieczność zdefiniowania własnego
operatora <span class="geshifilter"><code class="text geshifilter-text">new</code></span> pojawia się, gdy chcemy uzyskać wydajność lepszą
niż oferowana przez standardowy <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span>. Rozważmy więc
sytuację, kiedy używamy wielu małych przedmiotów o takim samym
rozmiarze.  Typowy przykład to inteligentne wskaźniki. W jaki więc
sposób moglibyśmy wydajnie przydzielać i zwalniać pamięć dla takich obiektów?
</p><p>Jednym z prostszych sposobów jest przydzielenie za pomocą 
stadardowego alokatora pewnej ilości pamięci, a następnie przydzielanie
z niej po kawałku pamięci na pojedyncze obiekty.
</p>



<span class="inline inline-center"><img src="http://informatyka.mimuw.edu.pl/sites/default/files/images/Cpp-14-1_1.png" alt="" title=""  class="image image-_original " width="243" height="247" /></span>
<span class="inline inline-center"><img src="http://informatyka.mimuw.edu.pl/sites/default/files/images/Cpp-14-2_0.png" alt="Rysunek 14.1. Działanie zasobnika pamięci." title="Rysunek 14.1. Działanie zasobnika pamięci."  class="image image-_original " width="245" height="245" /><span class="caption"><strong>Rysunek 14.1. Działanie zasobnika pamięci.</strong></span></span>


<p>Dokładniej wygląda to tak (zob. animacja 14.1): przydzielamy
obszar pamięci mogący pomieścić <span class="geshifilter"><code class="text geshifilter-text">N</code></span> kawałków żądanego przez nas
rozmiaru. Na początku wszystkie te kawałki łączymy w listę. Ponieważ na
liście bedą się znajdowały tylko kawałki nieprzydzielonej pamięci,
możemy umieścić wskaźnik do następnego kawałka na liście w samym
kawałku. Nasz alokator nie ma więc żadnego narzutu pamięci poza
wskaźnikiem do pierwszego elementu listy (głowa). 
</p><p>Kiedy potrzebujemy przydzielić pamięć, to usuwamy z listy jej pierwszy
element i zwracamy wskaźnik do niego. Kiedy chcemy zwolnić pamięć
przyłączamy zwalniany kawałek na początku listy. Obie te operacje są
bardzo szybkie. Jeśli mamy wystarczająco dużo pamięci, możemy
zrezygnować ze zwalniania jej pojedynczo, tylko zwolnić cały obszar naraz, gdy nie będzie nam już potrzebny.
</p><p>Kiedy będziemy potrzebowali więcej kawałków niż może ich pomieścić
nasz obszar, możemy przydzielić nowy. 
</p><p>Napisanie klasy obsługującej taki schemat pozostawiam jako ćwiczenie.
Tutaj wykorzystam gotową klasę <span class="geshifilter"><code class="text geshifilter-text">pool</code></span> dostarczaną w bibliotece <span class="geshifilter"><code class="text geshifilter-text">boost::pool</code></span>.
</p><p>Ewidentnie taki schemat nie nadaje się do implementacji  globalnej wersji 
<span class="geshifilter"><code class="text geshifilter-text">operator new</code></span>,  która przydziela pamięć dowolnych rozmiarów. 
Idealnie pasuje jednak do klasowego  operatora <span class="geshifilter"><code class="text geshifilter-text">new</code></span>. 
Deklarujemy więc:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #339900;">#include&lt;boost/pool/pool.hpp&gt;</span>
<span style="color: #0000ff;">struct</span> X <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">int</span> _val;
  <span style="color: #0000ff;">char</span> c<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1000</span><span style="color: #000000;">&#93;</span>;<span style="color: #ff0000; font-style: italic;">/* to tylko zwiększa rozmiar klasy*/</span>
  <span style="color: #0000ff;">static</span> boost::<span style="color: #00eeff;">pool</span>&lt;&gt; pool;
<span style="color: #0000ff;">public</span>:
  X<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i=<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>:_val<span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
  operator <span style="color: #0000ff;">int</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000ff;">return</span> _val;<span style="color: #000000;">&#125;</span>;
  <span style="color: #0000ff;">void</span> *operator <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span><span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #0000ff;">void</span> operator <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> *<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>
<p>( Źródło: X_new.h)
</p><p>Składowa <span class="geshifilter"><code class="text geshifilter-text">pool</code></span> jest składową statyczną, ponieważ musi istnieć
niezależnie od obiektów klasy. Podobnie operatory <span class="geshifilter"><code class="text geshifilter-text">new</code></span>  i
<span class="geshifilter"><code class="text geshifilter-text">delete</code></span> automatycznie są traktowane jako metody statyczne.   
Ponieważ składowe statyczne klasy są inicjalizowane na zewnątrz,
dodajemy do kodu linijkę:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">boost::<span style="color: #00eeff;">pool</span>&lt;&gt; X::<span style="color: #00eeff;">pool</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>X<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>która tworzy obiekt <span class="geshifilter"><code class="text geshifilter-text">X::pool</code></span> służący do przydzielania pamięci w kawałkach 
po <span class="geshifilter"><code class="text geshifilter-text">sizeof(X)</code></span> bajtów. 
</p><p>Następnie definiujemy <span class="geshifilter"><code class="text geshifilter-text">operator new</code></span>:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> * X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> size<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span>std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">void</span> *p = pool.<span style="color: #0000dd;">malloc</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">return</span> p;
    std::<span style="color: #00eeff;">new_handler</span> handler = std::<span style="color: #00eeff;">set_new_handler</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;
    std::<span style="color: #00eeff;">set_new_handler</span><span style="color: #000000;">&#40;</span>handler<span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>handler<span style="color: #000000;">&#41;</span>
      handler<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    <span style="color: #0000ff;">else</span>   
      throw std::<span style="color: #00eeff;">bad_alloc</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;    
  <span style="color: #000000;">&#125;</span>   
<span style="color: #000000;">&#125;</span></pre></div>
<p>( Źródło: X_new.cpp)
</p><p>Sam przydział pamięci jest najłatwiejszy: korzystamy  z gotowej
funkcji <span class="geshifilter"><code class="text geshifilter-text">malloc()</code></span> z klasy <span class="geshifilter"><code class="text geshifilter-text">boost::pool&lt;&gt;</code></span>.  Reszta kodu
implementuje zachowanie się operatora w przypadku braku pamięci, co
funkcja <span class="geshifilter"><code class="text geshifilter-text">_pool.malloc()</code></span> sygnalizuje poprzez zwrócenie wskaźnika
zerowego.
</p><p>Operator <span class="geshifilter"><code class="text geshifilter-text">delete</code></span> jest dużo prostszy:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> X::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">void</span> *p<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span>
    pool.<span style="color: #0000dd;">free</span><span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>
<br />
<h2>Alokatory</h2>
<hr />
<p>Trudno omawiać zarządzanie pamięcią w wykładzie dotyczącym
programowania uogólnionego i nie wspomnieć o alokatorach STL.  W
poprzedniej części wykładu używałem słowa alokator na określenie
każdej funkcji przydzielającej pamięć. W STL alokator jest konceptem i
oznacza klasy, których obiekty służą do przydzielania pamięci dla
standardowych kontenerów. Biblioteka C++ dostarcza standardową
implementację szablonu alokatora, której konkretyzacje przekazywane są
jako domyślny drugi lub trzeci argument szablonów kontenerów: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">namespace</span> std <span style="color: #000000;">&#123;</span>
template&lt;class T, <span style="color: #0000ff;">class</span> Allocator=allocator&lt;T&gt; &gt; <span style="color: #0000ff;">class</span> vector;
&nbsp;
template&lt;class T,
         <span style="color: #0000ff;">class</span> Compare = less&lt;T&gt;,
         <span style="color: #0000ff;">class</span> Allocator = allocator&lt;T&gt;&gt;
<span style="color: #0000ff;">class</span> set;
<span style="color: #000000;">&#125;</span></pre></div>
<p>Dlatego można używać kontenerów i nie wiedzieć nawet, że alokatory istnieją.
</p><p>Wymagane elementy szablonu kontenera opiszę na przykładzie możliwej
implementacji alokatora standardowego allocator.h:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T&gt; <span style="color: #0000ff;">class</span>      allocator <span style="color: #000000;">&#123;</span>...<span style="color: #000000;">&#125;</span>;</pre></div>
<p>Alokator jest szablonem przyjmujacym jako argument typ obiektów, dla
których będzie przydzielał pamięć.  Ponieważ parametrem szablonu
kontenera jest typ, a nie szablon, można by sądzić, że alokator klasą
być nie musi, bo możemy tworzyć konkretne alokatory dla konkretnych
typów, np.:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">vector&lt;int,alokator_int&gt; v;</pre></div>
<p>Alokator musi jednak być szablonem, bo wewnątrz kontenera może zajść
potrzeba przydzielenia pamięci dla obiektu innego typu niż typ
przechowywany <span class="geshifilter"><code class="text geshifilter-text">T</code></span>. Dzieje się tak w przypadku kontenerów opartych na
węzłach, takich jak listy czy kontenery asocjacyjne. Taki kontener
musi przydzielić pamięć na węzęł, a nie na element typu <span class="geshifilter"><code class="text geshifilter-text">T</code></span>. Żeby
móc to zrobić alokator  posiada wewnętrzną strukturę:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class U&gt; 
  <span style="color: #0000ff;">struct</span> rebind <span style="color: #000000;">&#123;</span> <span style="color: #0000ff;">typedef</span> pool_allocator U other; <span style="color: #000000;">&#125;</span>;</pre></div>
<p>Kontener może z niej korzystać następująco:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">typename</span> allocator&lt;T&gt;::<span style="color: #00eeff;">rebind</span>&lt;node&lt;T&gt; &gt;::<span style="color: #00eeff;">other</span> node_allocator;</pre></div>
<p>Obiekty klasy <span class="geshifilter"><code class="text geshifilter-text">node_allocator</code></span> przydzielają  pamięć na obiekty klasy
<span class="geshifilter"><code class="text geshifilter-text">node&lt;T&gt;</code></span>, a nie <span class="geshifilter"><code class="text geshifilter-text">T</code></span>. 
</p><p>Alokator definiuje szereg  typów stowarzyszonych:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">typedef</span> T                 value_type;
  <span style="color: #0000ff;">typedef</span> value_type*       pointer;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">const</span> value_type* const_pointer;
  <span style="color: #0000ff;">typedef</span> value_type&amp;       reference;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">const</span> value_type&amp; const_reference;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">size_t</span>            size_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">size_t</span>            difference_type;</pre></div>
<p>i operator zwracający adres elementu typu <span class="geshifilter"><code class="text geshifilter-text">T</code></span>:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">pointer address<span style="color: #000000;">&#40;</span>reference x<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span> <span style="color: #0000ff;">return</span> &amp;x; <span style="color: #000000;">&#125;</span>
  const_pointer address<span style="color: #000000;">&#40;</span>const_reference x<span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span> 
    <span style="color: #0000ff;">return</span> x;
  <span style="color: #000000;">&#125;</span>;</pre></div>
<p>Miało to umożliwić używanie
niestandardowych typów wskaźnikowych i referencyjnych. W praktyce te
typy i funkcje muszą być zdefiniowane dokładnie tak jak powyżej (zob.
S. Meyers <i>"STL w praktyce. 50 sposobów efektywnego wykorzystania"</i> oraz N.M. Josuttis <i>"C++ Biblioteka Standardowa. Podręcznik programisty"</i>). 
</p><p>Kontener używa obiektów klasy <span class="geshifilter"><code class="text geshifilter-text">allocator</code></span>, wobec czego musimy mieć
możność tworzenia i niszczenia ich:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">pool_allocator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span> 
  pool_allocator<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> pool_allocator&amp;<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>
   ~pool_allocator<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span></pre></div>
<p>Ważnym ograniczeniem narzuconym przez standard C++ jest wymaganie, aby
każde dwa obiekty alokatora tej samej klasy były równoważne.
Rownoważność oznacza, że pamięc przydzielona przez jeden obiekt
alokatora może być zwolniona przez drugi. W naszym przypadku alokator
nie posiada żadnego stanu i jego konstruktory i destruktor nic nie
robią, zatem ten warunek jest spełniony. Alokator nie musi posiadać
operatora przypisania, więc uniemożliwimy jego użycie:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">private</span>:
  <span style="color: #0000ff;">void</span> operator=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> pool_allocator&amp;<span style="color: #000000;">&#41;</span>;</pre></div>
<p>Dochodzimy wreszcie do funkcji, które zarządzają pamięcią. Funkcja: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">pointer allocate<span style="color: #000000;">&#40;</span>size_type n, const_pointer = <span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">return</span> static_cast&lt;pointer&gt;<span style="color: #000000;">&#40;</span>::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span>;</pre></div>
<p>przydziela pamięć dla <span class="geshifilter"><code class="text geshifilter-text">n</code></span> elementów typu <span class="geshifilter"><code class="text geshifilter-text">T</code></span>. Pamięć nie jest
inicjalizowana. Proszę zwrócić uwagę, że w przeciwieństwie do
<span class="geshifilter"><code class="text geshifilter-text">operator new</code></span> czy <span class="geshifilter"><code class="text geshifilter-text">malloc</code></span>, <span class="geshifilter"><code class="text geshifilter-text">allocate</code></span> zwraca wskaźnik
<span class="geshifilter"><code class="text geshifilter-text">T *</code></span>, a nie <span class="geshifilter"><code class="text geshifilter-text">void *</code></span>. Drugi parametr funkcji <span class="geshifilter"><code class="text geshifilter-text">allocate</code></span> może
być użyty przez bardziej wyrafinowane schematy przydziału pamięci. 
Tworzeniem obiektu wewnątrz przydzielonej pamięci zajmuje się funkcja
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">vvoid construct<span style="color: #000000;">&#40;</span>pointer p, <span style="color: #0000ff;">const</span> value_type&amp; x<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    <span style="color: #0000dd;">new</span><span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span> value_type<span style="color: #000000;">&#40;</span>x<span style="color: #000000;">&#41;</span>; 
  <span style="color: #000000;">&#125;</span></pre></div>
<p>korzystająca ze standardowego  placement <span class="geshifilter"><code class="text geshifilter-text">new</code></span>. Funkcja: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> deallocate<span style="color: #000000;">&#40;</span>pointer p, size_type n<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>  <span style="color: #000000;">&#123;</span>
    ::<span style="color: #00eeff;">operator</span> <span style="color: #0000dd;">delete</span><span style="color: #000000;">&#40;</span>p<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span></pre></div>
<p>zwalnia pamięć wskazywaną przez wskaźnik <span class="geshifilter"><code class="text geshifilter-text">p</code></span>. 
Funkcja <span class="geshifilter"><code class="text geshifilter-text">deallocate()</code></span> nie wywołuje destruktora.  Robi to funkcja:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> destroy<span style="color: #000000;">&#40;</span>pointer p<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 
    p-&gt; ~value_type<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
  <span style="color: #000000;">&#125;</span></pre></div>
<p>Na koniec została pomocnicza funkcja:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">size_type max_size<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span> 
    <span style="color: #0000ff;">return</span> static_cast&lt;size_type&gt;<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">-1</span><span style="color: #000000;">&#41;</span> / <span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span>T<span style="color: #000000;">&#41;</span>;
  <span style="color: #000000;">&#125;</span></pre></div>
<p>która zwraca największą wartość możliwą do przekazania do funkcji
<span class="geshifilter"><code class="text geshifilter-text">allocate</code></span>. Nie oznacza to jednak, że przydział tej pamięci musi
się powieść.
</p><p>Koncept alokatora wymaga jeszcze dwu operatorów  testujących równoważność
obiektów alokatora. Ponieważ kontenery wymagają, aby każde dwa obiekty 
były równoważne, te operatory zdefiniowane są następująco:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T&gt;
<span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">bool</span> operator==<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> allocator&lt;T&gt;&amp;, 
                       <span style="color: #0000ff;">const</span> allocator&lt;T&gt;&amp;<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;
<span style="color: #000000;">&#125;</span>
&nbsp;
<span style="color: #0000ff;">template</span> &lt;class T&gt;
<span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">bool</span> operator!=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> allocator&lt;T&gt;&amp;, 
                       <span style="color: #0000ff;">const</span> allocator&lt;T&gt;&amp;<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;
<span style="color: #000000;">&#125;</span></pre></div>
<p>Na koniec zabezpieczmy się jeszcze tylko na wypadek możliwości
skonkretyzowania szablonu <span class="geshifilter"><code class="text geshifilter-text">allocator&lt;void&gt;</code></span> poprzez odpowiednią
specjalizację:
</p>

<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;&gt; <span style="color: #0000ff;">class</span> allocator&lt;void&gt; <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">void</span>        value_type;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">void</span>*       pointer;
  <span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span>* const_pointer;
&nbsp;
  <span style="color: #0000ff;">template</span> &lt;class U&gt; 
  <span style="color: #0000ff;">struct</span> rebind <span style="color: #000000;">&#123;</span> <span style="color: #0000ff;">typedef</span> allocator&lt;U&gt; other; <span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>
<div class="image-clear"></div><table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/X_new.cpp">X_new.cpp</a></td><td>470 bajtów</td> </tr>
 <tr class="even"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/X_new.h">X_new.h</a></td><td>326 bajtów</td> </tr>
</tbody>
</table>
  </div>
<div id="node-1349" class="section-2">
  <h1 class="book-heading">Wyjątkowo odporny kod</h1>
  <h2>Wstęp</h2>
<p>W poprzednim wykładzie opisałem mechanizm obsługi błędów za pomocą
wyjątków.  Jest to bardzo silny mechanizm: rzucony wyjątek powoduje
natychmiastowe przekazanie sterowania do najbliższej klauzuli
<span class="geshifilter"><code class="text geshifilter-text"> catch</code></span>, niejako "tnąc" w poprzek dowolnie głęboko zagnieżdżone
funkcje. To oczywiście jest jedną z jego podstawowych zalet, ale musimy
podchodzić do tej własności bardzo ostrożnie.  
</p><p>W tym wykładzie zwrócę uwagę na  kilka niebezpieczeństw
wynikających z obsługi wyjątków i na sposoby zapobiegania im.
</p>
<h2>Wyjątkowe niebezpieczeństwa</h2>
<p>W zasadzie korzystanie z wyjątków jest proste: funkcja, która stwierdza
wystąpienie błędu, a nie umie go sama obsłużyć, przekazuje
odpowiedzialność  swoim przełożonym, rzucając wyjątek. Jej
przełożeni mogą zrobić to samo (wystarczy, że nie przechwycą wyjątku).
Zakładamy jednak, że gdzieś w tej hierarchii wyjątek zostanie złapany przez
kogoś, kto wie jak go obsłużyć. W praktyce sprawa może być bardziej
skomplikowana.  Rzucony wyjątek powoduje natychmiastowe przerwanie
nie tylko funkcji, która go rzuciła, ale również wszystkich funkcji,
przez które "przelatuje". Jeśli te funkcje nie są na to
przygotowane, to wyjątek może narobić dodatkowych szkód.
Typowy przykład to niezwolnione zasoby:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    przydziel_zasob<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
    g<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000; font-style: italic;">/*może rzucić wyjątek*/</span>
    zwolnij_zasob<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre></div>
<p>Rzucenie wyjątku z <span class="geshifilter"><code class="text geshifilter-text">g()</code></span> spowoduje wyciek zasobu (zwykle pamięci). Taki przykład był już rozważany w Wykładzie 10
Podane tam rozwiązanie to technika "przydział zasobu jest
inicjalizacją", czyli oddelegowanie zarządzania zasobem do osobnej
klasy, której konstruktor przydziela zasób, a destruktor zwalnia:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
Zasob x;
g<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000; font-style: italic;">/*może rzucić wyjątek*/</span>
<span style="color: #000000;">&#125;</span> <span style="color: #ff0000; font-style: italic;">/* niejawnie wywoływany  destruktor x. Zasob() */</span></pre></div>
<p>Wtedy podczas zwijania stosu zasób zostanie zwolniony automatycznie.
Proszę zauważyć jednak, że jeśli nie przechwycimy wyjątku, to zasób
może dalej pozostać niezwolniony. Rozwiązaniem może być kod:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> f<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
przydziel_zasob<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
g<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; <span style="color: #ff0000; font-style: italic;">/*może rzucić wyjątek*/</span>
<span style="color: #000000;">&#125;</span>
cath<span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>zwolnij_zasob<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;throw;<span style="color: #000000;">&#125;</span>
&nbsp;
zwolnij_zasob<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 
<span style="color: #000000;">&#125;</span></pre></div>
<p>Po zwolnieniu zasobu rzucamy (podrzucamy?) ponownie ten sam wyjątek. W
ten sposób funkcja <span class="geshifilter"><code class="text geshifilter-text"> f()</code></span> staje się "przeźroczysta dla wyjątków"
(exception-neutral).
</p>
<h2>Konstruktory</h2>
<p>Szczególnym przypadkiem mogącym prowadzić  do wycieku pamięci są 
wyjątki rzucane z konstruktora. Rozważmy następujący kod:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> BigRsource <span style="color: #000000;">&#123;</span>
    <span style="color: #0000ff;">char</span> c<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">10000000</span><span style="color: #000000;">&#93;</span>;
<span style="color: #000000;">&#125;</span>;
<span style="color: #0000ff;">struct</span> BadBoy <span style="color: #000000;">&#123;</span>
 BadBoy<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>throw <span style="color: #0000dd;">0</span>;<span style="color: #000000;">&#125;</span>;
<span style="color: #000000;">&#125;</span>;
&nbsp;
<span style="color: #0000ff;">struct</span> X <span style="color: #000000;">&#123;</span>
  BigResource *p1;
  BadBoy      p2;
 X: p1<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> BigResource<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>
&nbsp;
X<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
  <span style="color: #0000dd;">delete</span> p1;
  <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>
<p>Na pierwszy rzut oka jest to pierwszorzędny przykład programowania
obiektowego: pamięć jest przydzielana w konstruktorze i zwalniana w
destruktorze, nie ma więc możliwości wycieku. Prześledźmy jednak, co
się stanie, gdy napiszemy:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
    X x;
<span style="color: #000000;">&#125;</span> <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;</pre></div>
<p>Konstruktor najpierw przydzieli pamięć dla wskaźnika <span class="geshifilter"><code class="text geshifilter-text"> p1</code></span>. Załóżmy,
że ta alokacja się powiedzie. Następnie zostanie wywołany konstruktor
<span class="geshifilter"><code class="text geshifilter-text"> BadBoy</code></span>, który rzuci wyjątek. Wyjątek nie zostanie złapany w
konstruktorze <span class="geshifilter"><code class="text geshifilter-text"> X</code></span>, więc sterowanie zostane przekazane do klauzuli
<span class="geshifilter"><code class="text geshifilter-text"> catch</code></span>.  Nastąpi zwinięcie stosu, ale destruktor obiektu <span class="geshifilter"><code class="text geshifilter-text"> x</code></span>
<b>nie</b> zostanie wywołany! Dzieje się tak dlatego, że w C++
destruktory nie są wołane dla obiektów, których konstrukcja się nie
powiodła. W taki sposób tracimy 10MB.  Możliwe rozwiązania są podobne
jak w poprzednim wypadku: korzystamy z <span class="geshifilter"><code class="text geshifilter-text"> auto_ptr</code></span>:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> X <span style="color: #000000;">&#123;</span>
 std::<span style="color: #00eeff;">auto_ptr</span>&lt;BigResource&gt; p1;
 BadBoy      p2;
 X: p1<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span>  BigResource<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>
&nbsp;
 X<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000dd;">delete</span> p1;
 <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>
<p>lub sami łapiemy wyjątek:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">struct</span> X <span style="color: #000000;">&#123;</span>
 BigResource *p1;
 BadBoy      p2;
 X: <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>p1<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> BigResource<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span><span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span><span style="color: #0000dd;">delete</span> p1;<span style="color: #000000;">&#125;</span>;
&nbsp;
 ~X<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000dd;">delete</span> p1;
 <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>
<p>Proszę zwrócić uwagę na blok  <span class="geshifilter"><code class="text geshifilter-text"> try</code></span>, który otacza cały 
konstruktor łącznie z listą inicjalizatorów.
</p>
<h2>The bad, the good and the ugly</h2>
<p>Jeżeli wyjątek został rzucony przez metodę jakiegoś obiektu, to dla
dalszego działania programu ważne jest, w jakim stanie go pozostawił. 
Wyróżnimy trzy możliwości:
</p><p><b>The bad. </b>  Obiekt jest w stanie niekonsystentnym, nie
są zachowane  niezmienniki jego typu, być może nastąpił wyciek zasobów.
Nieokreślone jest zachowanie wywoływanych metod, w szczególności może nie powieść się destrukcja obiektu.
</p><p><b>The ugly. </b>  Obiekt jest w stanie konsystentnym, ale
niezdefiniowanym.
</p><p><b>The good. </b>  Obiekt pozostaje w stanie, w jakim był przed
rzuceniem wyjątku. Jest to semantyka transakcji: commit--rollback. 
</p><p>Ewidentnie najbardziej pożądanym zachowaniem jest stan ostatni.  Nie
zawsze da się jednak zapewnić takie zachowanie bez ponoszenia dużych
kosztów. Wtedy możemy zadowolić się stanem drugim. Stan pierwszy
to oczywista katastrofa.
</p>
<h2>Przykład: stos</h2>
<p>Rozważmy  stos z dynamiczną obsługą pamięci. Przykład takiego
stosu był podany w Wykładzie 7. Żeby nie wprowadzać
komplikacji, nie będziemy tu korzystać z klas wytycznych:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T,<span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">10</span>&gt; <span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
  <span style="color: #0000ff;">size_t</span> nelems;
  <span style="color: #0000ff;">size_t</span> top;
  T* v;
&nbsp;
<span style="color: #0000ff;">public</span>:
  <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span>;
  <span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T&amp;<span style="color: #000000;">&#41;</span>;
  T pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
  Stack<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n = N<span style="color: #000000;">&#41;</span>;
   Stack<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
  Stack<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Stack&amp;<span style="color: #000000;">&#41;</span>;
  Stack&amp; operator=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Stack&amp;<span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre></div>
<p>W powyższym konstruktorze może nie powieść się tylko operacja
tworzenia tablicy <span class="geshifilter"><code class="text geshifilter-text"> v</code></span>. Ale wtedy, zgodnie z tym co już omawialiśmy w
poprzednim wykładzie, wyrażenie <span class="geshifilter"><code class="text geshifilter-text"> new</code></span> samo po sobie posprząta.  Nie
musimy się  martwić stanem pozostawionego obiektu, bo jeśli konstrukcja
się nie powiedzie, to obiektu po prostu nie ma.
</p><p>Z konstruktorem kopiującym jest już trochę gorzej:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T,<span style="color: #0000ff;">size_t</span> N&gt;  Stack&lt;T,N&gt;::<span style="color: #00eeff;">Stack</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Stack&lt;T,N&gt;&amp; s<span style="color: #000000;">&#41;</span>:
v<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>nelems = s.<span style="color: #00eeff;">nelems</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> s.<span style="color: #00eeff;">top</span> &gt; <span style="color: #0000dd;">0</span> <span style="color: #000000;">&#41;</span>
 <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>top = <span style="color: #0000dd;">0</span>; top &lt; s.<span style="color: #00eeff;">top</span>; top++<span style="color: #000000;">&#41;</span>
 v<span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span> = s.<span style="color: #00eeff;">v</span><span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span>; <span style="color: #ff0000; font-style: italic;">/* tu może zostać rzucony wyjatek */</span>  
<span style="color: #000000;">&#125;</span></pre></div>
<p>Podobnie jak poprzednio, w wypadku niepowodzenia wyrażenie <span class="geshifilter"><code class="text geshifilter-text"> new</code></span>
posprząta po sobie. Ale wyjątek może zostać rzucony również przez
operator przypisania klasy <span class="geshifilter"><code class="text geshifilter-text"> T</code></span>. Wtedy będziemy mieli do czynienia z
wyciekiem pamięci, ponieważ nie zostanie wywołany destruktor stosu,
który zwalnia pamięć <span class="geshifilter"><code class="text geshifilter-text"> v</code></span>. Taki przykład już omawialiśmy na początku
wykładu. Rozwiązaniem jest użycie <span class="geshifilter"><code class="text geshifilter-text"> auto_ptr</code></span> lub przechwycenie wyjątku:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T,<span style="color: #0000ff;">size_t</span> N&gt;  Stack&lt;T,N&gt;::<span style="color: #00eeff;">Stack</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Stack&lt;T,N&gt;&amp; s<span style="color: #000000;">&#41;</span>:
v<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>nelems = s.<span style="color: #00eeff;">nelems</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
   <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> s.<span style="color: #00eeff;">top</span> &gt; <span style="color: #0000dd;">0</span> <span style="color: #000000;">&#41;</span>
   <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>top = <span style="color: #0000dd;">0</span>; top &lt; s.<span style="color: #00eeff;">top</span>; top++<span style="color: #000000;">&#41;</span>
   v<span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span> = s.<span style="color: #00eeff;">v</span><span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span>; <span style="color: #ff0000; font-style: italic;">/* tu może zostać rzucony wyjatek */</span>  
 <span style="color: #000000;">&#125;</span>
 <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   <span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> v; throw ;
 <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre></div>
<p>To rozwiązanie zakłada, że destrukcja <span class="geshifilter"><code class="text geshifilter-text"> v</code></span> powiedzie się, tzn. że operator 
przypisania: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">v<span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span> = s.<span style="color: #00eeff;">v</span><span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span>;</pre></div>
<p>pozostawił lewą stronę w stanie umożliwiającym jej destrukcję.
</p><p>Sytuacja jest groźniejsza w przypadku operatora przypisania:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T,<span style="color: #0000ff;">size_t</span> N&gt; Stack&lt;T,N&gt;&amp;
Stack&lt;T,N&gt;::<span style="color: #00eeff;">operator</span>=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Stack&lt;T,N&gt;&amp; s<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span> <span style="color: #000000;">&#93;</span> v;
 v = <span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>nelems=s.<span style="color: #00eeff;">nelems</span><span style="color: #000000;">&#93;</span>;
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> s.<span style="color: #00eeff;">top</span> &gt; <span style="color: #0000dd;">0</span> <span style="color: #000000;">&#41;</span>
 <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span>top = <span style="color: #0000dd;">0</span>; top &lt; s.<span style="color: #00eeff;">top</span>; top++<span style="color: #000000;">&#41;</span>
    v<span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span> = s.<span style="color: #00eeff;">v</span><span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span>;
 <span style="color: #0000ff;">return</span> *<span style="color: #0000dd;">this</span>;
<span style="color: #000000;">&#125;</span></pre></div>
<p>Wyjątek rzucony przez wyrażenie <span class="geshifilter"><code class="text geshifilter-text"> new</code></span> zostawia stos w stanie złym,
z wiszącym luźno wskaźnikiem <span class="geshifilter"><code class="text geshifilter-text"> v</code></span>.  Wyjątek rzucony przez operator
przypisania elementów tablicy <span class="geshifilter"><code class="text geshifilter-text"> v</code></span> w najlepszym przypadku zostawia
stos w stanie niezdefiniowanym.  Implementacja, która w wypadku
wystąpienia wyjątku zostawia stos w takim stanie, w jakim go zastała,
jest podana poniżej: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T,<span style="color: #0000ff;">size_t</span> N&gt; Stack&lt;T,N&gt;&amp;
Stack&lt;T,N&gt;::<span style="color: #00eeff;">operator</span>=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Stack&lt;T,N&gt;&amp; s<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 T *tmp;
 <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
   tmp = <span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>nelems=s.<span style="color: #00eeff;">nelems</span><span style="color: #000000;">&#93;</span>;
   <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> s.<span style="color: #00eeff;">top</span> &gt; <span style="color: #0000dd;">0</span> <span style="color: #000000;">&#41;</span>
     <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i = <span style="color: #0000dd;">0</span>; i &lt; s.<span style="color: #00eeff;">top</span>; i++<span style="color: #000000;">&#41;</span>
         tmp<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span> = s.<span style="color: #00eeff;">v</span><span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;
  <span style="color: #000000;">&#125;</span>
  <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> tmp,throw;<span style="color: #000000;">&#125;</span>
  swap<span style="color: #000000;">&#40;</span>v,tmp<span style="color: #000000;">&#41;</span>;
  <span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> tmp;
  top=s.<span style="color: #00eeff;">top</span>;
  <span style="color: #0000ff;">return</span> *<span style="color: #0000dd;">this</span>;
<span style="color: #000000;">&#125;</span></pre></div>
<p>Przejdźmy teraz do podstawowych funkcji stosu, zaczynając od funkcji <span class="geshifilter"><code class="text geshifilter-text"> push</code></span>:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T,<span style="color: #0000ff;">size_t</span> N&gt;
<span style="color: #0000ff;">void</span> Stack&lt;T,N&gt;::<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;element<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> top == nelems <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   T* new_buffer = <span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>nelems += N<span style="color: #000000;">&#93;</span>;
   <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i = <span style="color: #0000dd;">0</span>; i &lt; top; i++<span style="color: #000000;">&#41;</span>
     new_buffer<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span> = v<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;
   <span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> v;
   v = new_buffer;
 <span style="color: #000000;">&#125;</span>
 v<span style="color: #000000;">&#91;</span>top++<span style="color: #000000;">&#93;</span> = element;
<span style="color: #000000;">&#125;</span></pre></div>
<p>Załóżmy na początek, że nie ma potrzeby zwiększania pamięci, 
wykonywane jest więc tylko polecenie:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">v<span style="color: #000000;">&#91;</span>top++<span style="color: #000000;">&#93;</span> = element;</pre></div>
<p>Jak już  zauważyliśmy, przypisanie może się nie powieść, wtedy stos
zostanie w stanie złym lub niezdefiniowanym, ponieważ <span class="geshifilter"><code class="text geshifilter-text"> top</code></span> zostanie
zwiększone. Lepiej jest więc napisać:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">v<span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span> = element;
 ++top;</pre></div>
<p>Zobaczmy, co się dzieje, jeśli zażądamy zwiększenia pamięci.
Niepowodzenie wyrażenia <span class="geshifilter"><code class="text geshifilter-text"> new</code></span> zostawi nas ze zwiększonym polem
<span class="geshifilter"><code class="text geshifilter-text"> nelems</code></span>, pomimo że pamięć się nie zwiększyła. Wyjątek z operatora
przypisania zostawi nas z wyciekiem pamięci, ponieważ pamięć
przydzielona do <span class="geshifilter"><code class="text geshifilter-text"> new_buffer</code></span> nigdy nie zostanie zwolniona.
Uwzględaniając te uwagi, poprawimy funkcję <span class="geshifilter"><code class="text geshifilter-text"> push</code></span> następująco:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T,<span style="color: #0000ff;">size_t</span> N&gt;
<span style="color: #0000ff;">void</span> Stack&lt;T,N&gt;::<span style="color: #00eeff;">push</span><span style="color: #000000;">&#40;</span>T element<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> top == nelems <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   T* new_buffer;
   <span style="color: #0000ff;">size_t</span> new_nelems;
   <span style="color: #0000ff;">try</span> <span style="color: #000000;">&#123;</span>
     new_nelems=nelems+N;
     new_buffer = <span style="color: #0000dd;">new</span> T<span style="color: #000000;">&#91;</span>new_nelems<span style="color: #000000;">&#93;</span>;
     <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">int</span> i = <span style="color: #0000dd;">0</span>; i &lt; top; i++<span style="color: #000000;">&#41;</span>
       new_buffer<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span> = v<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span>;
   <span style="color: #000000;">&#125;</span>
   <span style="color: #0000ff;">catch</span><span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> <span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> new_buffer;<span style="color: #000000;">&#125;</span>
     swap<span style="color: #000000;">&#40;</span>v,new_buffer<span style="color: #000000;">&#41;</span>;
     <span style="color: #0000dd;">delete</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> new_buffer;
     nelems = new_nelems;
   <span style="color: #000000;">&#125;</span>
&nbsp;
 v<span style="color: #000000;">&#91;</span>top<span style="color: #000000;">&#93;</span> = element;
 ++top;
 <span style="color: #000000;">&#125;</span></pre></div>
<p>Na koniec została nam jeszcze funkcja <span class="geshifilter"><code class="text geshifilter-text"> pop</code></span>:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T,<span style="color: #0000ff;">size_t</span> N&gt; T Stack&lt;T,N&gt;::<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> top == <span style="color: #0000dd;">0</span> <span style="color: #000000;">&#41;</span>
   throw std::<span style="color: #00eeff;">domain_error</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;pop on empty stack&quot;</span><span style="color: #000000;">&#41;</span>;
 <span style="color: #0000ff;">return</span> v<span style="color: #000000;">&#91;</span>--top<span style="color: #000000;">&#93;</span>; <span style="color: #ff0000; font-style: italic;">/* tu może nastąpić kopiowanie */</span>
<span style="color: #000000;">&#125;</span></pre></div>
<p>Jak widać funkcja <span class="geshifilter"><code class="text geshifilter-text"> pop</code></span> może rzucić jawnie wyjątek
<span class="geshifilter"><code class="text geshifilter-text"> std::domain_error</code></span>. Z tym  wyjątkiem nie ma problemów. 
Potencjalny problem stwarza za to wyrażenie:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">return</span> v<span style="color: #000000;">&#91;</span>--top<span style="color: #000000;">&#93;</span>; <span style="color: #ff0000; font-style: italic;">/* tu może nastąpić kopiowanie */</span></pre></div>
<p>Ponieważ zwracamy <span class="geshifilter"><code class="text geshifilter-text"> v[--top]</code></span> przez wartość, to może nastąpić
kopiowanie elementu typu <span class="geshifilter"><code class="text geshifilter-text"> T</code></span>. Nie musi, ponieważ kompilator ma prawo
wyoptymalizować powstały obiekt tymczasowy. Jeżeli jednak zostanie 
wywołany konstruktor kopiujący, to może rzucić wyjątek. Wtedy stos 
pozostanie w zmienionym stanie, bo wartość <span class="geshifilter"><code class="text geshifilter-text"> top</code></span> zostanie zmniejszona. 
Rozważmy też wyrażenie:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">x = s.<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre></div>
<p>Jeżeli operacja przypisania się nie powiedzie, to stracimy
bezpowrotnie jeden element stosu. Można by powiedzieć, że to już nie
jest sprawa stosu, ale lepiej  po prostu rozdzielić operacje 
modyfikujące stan stosu od operacji tylko ten stan odczytujących:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">template</span> &lt;class T,<span style="color: #0000ff;">size_t</span> N&gt; <span style="color: #0000ff;">void</span> Stack&lt;T,N&gt;::<span style="color: #00eeff;">pop</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> top == <span style="color: #0000dd;">0</span> <span style="color: #000000;">&#41;</span>
   throw std::<span style="color: #00eeff;">domain_error</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;pop on empty stack&quot;</span><span style="color: #000000;">&#41;</span>;
   --top;
 <span style="color: #000000;">&#125;</span>
template&lt;class T,<span style="color: #0000ff;">size_t</span> N&gt; T &amp;Stack&lt;T,N&gt;::<span style="color: #00eeff;">top</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> top == <span style="color: #0000dd;">0</span> <span style="color: #000000;">&#41;</span>
   throw std::<span style="color: #00eeff;">domain_error</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;pop on empty stack&quot;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
 <span style="color: #0000ff;">return</span> v<span style="color: #000000;">&#91;</span>top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>;
<span style="color: #000000;">&#125;</span>
template&lt;class T,<span style="color: #0000ff;">size_t</span> N&gt; <span style="color: #0000ff;">const</span> T &amp;Stack&lt;T,N&gt;::<span style="color: #00eeff;">top</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span>
 <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> top == <span style="color: #0000dd;">0</span> <span style="color: #000000;">&#41;</span>
   throw std::<span style="color: #00eeff;">domain_error</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;pop on empty stack&quot;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
 <span style="color: #0000ff;">return</span> v<span style="color: #000000;">&#91;</span>top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>;
<span style="color: #000000;">&#125;</span></pre></div>
<p>W przeciwieństwie do <span class="geshifilter"><code class="text geshifilter-text"> pop()</code></span> operacja <span class="geshifilter"><code class="text geshifilter-text"> top()</code></span> może zwracać
wartość przez referencje. Funkcja <span class="geshifilter"><code class="text geshifilter-text"> pop()</code></span>  robić tego w ogólności
nie mogła, bo potencjalnie niszczyła obiekt zdejmowany ze stosu.
</p>
<h2>Kolejny stos</h2>
<p>Zaprezentowana w poprzedniej części implementacja stosu wymagała, aby
parametr szablonu <span class="geshifilter"><code class="text geshifilter-text"> T</code></span> posiadał:
</p>
<ul><li> konstruktor domyślny. 
</li><li> bezpieczny (względem wyjątków) operator przypisania.
</li><li> destruktor nie rzucający wyjątków.
</li></ul>
<p>Proszę zauważyć, że konstruktor domyślny właściwie niczemu nie służy.
Jest potrzebny tylko po to, aby stworzyć tablicę obiektów, które potem
będą tak naprawdę nadpisywane za pomocą operatora przypisania. Taka
inicjalizacja i przypisanie jest w C++ dokonywana za pomocą
konstruktora kopiującego. Na zakończenie przedstawię implementację
klasy <span class="geshifilter"><code class="text geshifilter-text"> Stack</code></span>, która od typu <span class="geshifilter"><code class="text geshifilter-text"> T</code></span> potrzebuje tylko destruktora i
konstruktora kopiującego.  W tym celu będziemy przydzielać "gołą"
pamięć oraz tworzyć i niszczyć w niej obiekty bezpośrednio.  Do tego celu
wykorzystamy alokator opisany w poprzednim wykładzie.  
Zaczniemy od zdefiniowania  pomocniczej klasy do zarządzania pamięcią:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">typename</span> Allocator = std::<span style="color: #00eeff;">allocator</span>&lt;T&gt; &gt; 
<span style="color: #0000ff;">struct</span>  Stack_impl : <span style="color: #0000ff;">public</span> Allocator<span style="color: #000000;">&#123;</span> 
 <span style="color: #0000ff;">size_t</span> _top;
 <span style="color: #0000ff;">size_t</span> _size;
 T* _buffer;
&nbsp;
 Stack_impl<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n<span style="color: #000000;">&#41;</span>:
   _top<span style="color: #000000;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>, 
   _size<span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span>,
   _buffer<span style="color: #000000;">&#40;</span>Allocator::<span style="color: #00eeff;">allocate</span><span style="color: #000000;">&#40;</span>_size<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
  Stack_impl<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   <span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> i=<span style="color: #0000dd;">0</span>;i&lt;_top;++i<span style="color: #000000;">&#41;</span>
     destroy<span style="color: #000000;">&#40;</span>_buffer++<span style="color: #000000;">&#41;</span>;
&nbsp;
   deallocate<span style="color: #000000;">&#40;</span>_buffer,_size<span style="color: #000000;">&#41;</span>;
 <span style="color: #000000;">&#125;</span>
&nbsp;
 <span style="color: #0000ff;">void</span> swap<span style="color: #000000;">&#40;</span>Stack_impl&amp; rhs<span style="color: #000000;">&#41;</span> throw<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   std::<span style="color: #00eeff;">swap</span><span style="color: #000000;">&#40;</span>_buffer,rhs._buffer<span style="color: #000000;">&#41;</span>;
   std::<span style="color: #00eeff;">swap</span><span style="color: #000000;">&#40;</span>_size,rhs._size<span style="color: #000000;">&#41;</span>;
   std::<span style="color: #00eeff;">swap</span><span style="color: #000000;">&#40;</span>_top,rhs._top<span style="color: #000000;">&#41;</span>;
 <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>
<p>Jedyne miejsce, gdzie może zostać rzucony wyjątek to funkcja
<span class="geshifilter"><code class="text geshifilter-text"> allocate()</code></span>, ale wtedy żadna pamięć nie zostanie przydzielona ani
żaden obiekt nie zostanie stworzony. Korzystamy tu też z żądania, aby
alokator był bezstanowy, inaczej funkcja <span class="geshifilter"><code class="text geshifilter-text"> swap</code></span> musiałaby też
zamieniać składowe alokatorów. 
</p><p>Klasa <span class="geshifilter"><code class="text geshifilter-text"> Stack</code></span> korzysta z klasy <span class="geshifilter"><code class="text geshifilter-text"> Stack_impl</code></span>:  
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">template&lt;typename T,<span style="color: #0000ff;">size_t</span> N = <span style="color: #0000dd;">10</span>,
        <span style="color: #0000ff;">typename</span> Allocator = std::<span style="color: #00eeff;">allocator</span>&lt;T&gt; &gt; 
<span style="color: #0000ff;">class</span> Stack <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">private</span>:
  Stack_impl&lt;T,Allocator&gt; _impl;</pre></div>
<p>( Źródło: stack_sutter.h)
</p><p>Konstruktory: 
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">public</span>:
  Stack<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">size_t</span> n = N<span style="color: #000000;">&#41;</span>:_impl<span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span><span style="color: #000000;">&#125;</span>;
&nbsp;
 Stack<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Stack&amp; rhs<span style="color: #000000;">&#41;</span>:_impl<span style="color: #000000;">&#40;</span>rhs._impl<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>_impl._top &lt; rhs._impl._top<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
     _impl.<span style="color: #00eeff;">construct</span><span style="color: #000000;">&#40;</span>_impl._buffer+_impl._top, rhs._impl._buffer<span style="color: #000000;">&#91;</span>_impl._top<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;
     ++_impl._top;
   <span style="color: #000000;">&#125;</span>
 <span style="color: #000000;">&#125;</span></pre></div>
<p>( Źródło: stack_sutter.h)
</p><p>robią się teraz prostsze. Nie ma potrzeby definiowania destruktora.
Destruktor domyślny sam wywoła destruktor pola <span class="geshifilter"><code class="text geshifilter-text"> _impl</code></span>.  Jeżeli w
konstruktorze kopiującym zostanie rzucony wyjątek w funkcji
<span class="geshifilter"><code class="text geshifilter-text"> construct</code></span>, to wywołany podczas zwijania stosu destruktor <span class="geshifilter"><code class="text geshifilter-text"> Stack_impl</code></span>
wywoła destruktory stworzonych obiektów i zwolni pamięć.
</p><p>Operator przypisania korzysta z "triku":
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">Stack &amp;operator=<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> Stack&amp; rhs<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   Stack tmp<span style="color: #000000;">&#40;</span>rhs<span style="color: #000000;">&#41;</span>;
   _impl.<span style="color: #00eeff;">swap</span><span style="color: #000000;">&#40;</span>tmp._impl<span style="color: #000000;">&#41;</span>;
   <span style="color: #0000ff;">return</span> *<span style="color: #0000dd;">this</span>;
 <span style="color: #000000;">&#125;</span></pre></div>
<p>( Źródło: stack_sutter.h)
</p><p>Tworzymy kopię prawej strony i zamieniamy z lewą stroną. Obiekt
<span class="geshifilter"><code class="text geshifilter-text"> tmp</code></span> jest obiektem lokalnym, więc zostanie zniszczony.  Jeśli nie
powiedzie się kopiowanie, to stos pozostaje w stanie niezmienionym.
Proszę zauważyć, że jest to bezpieczne nawet w przypadku 
samopodstawienia <span class="geshifilter"><code class="text geshifilter-text"> s=s</code></span>. 
</p><p>Funkcja <span class="geshifilter"><code class="text geshifilter-text"> push</code></span> stosuje podobną technikę:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp"><span style="color: #0000ff;">void</span> push<span style="color: #000000;">&#40;</span><span style="color: #0000ff;">const</span> T &amp;elem<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>_impl._top==_impl._size<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
     Stack tmp<span style="color: #000000;">&#40;</span>_impl._size+N<span style="color: #000000;">&#41;</span>;
     <span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span>tmp._impl._top &lt; _impl._top<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
        _impl.<span style="color: #00eeff;">construct</span><span style="color: #000000;">&#40;</span>tmp._impl._buffer+tmp._impl._top,
              _impl._buffer<span style="color: #000000;">&#91;</span>tmp._impl._top<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;
        ++tmp._impl._top;
    <span style="color: #000000;">&#125;</span>
     _impl.<span style="color: #00eeff;">swap</span><span style="color: #000000;">&#40;</span>tmp._impl<span style="color: #000000;">&#41;</span>;
   <span style="color: #000000;">&#125;</span>
&nbsp;
   _impl.<span style="color: #00eeff;">construct</span><span style="color: #000000;">&#40;</span>_impl._buffer+_impl._top,elem<span style="color: #000000;">&#41;</span>;
   ++_impl._top;
 <span style="color: #000000;">&#125;</span></pre></div>
<p>( Źródło: stack_sutter.h)
</p><p>Funkcje <span class="geshifilter"><code class="text geshifilter-text"> top()</code></span> i <span class="geshifilter"><code class="text geshifilter-text"> pop()</code></span> pozostają praktycznie niezmienione, z
tym, że funkcja <span class="geshifilter"><code class="text geshifilter-text"> pop()</code></span> niszczy obiekt na wierzchołku stosu:
</p>
<div class="geshifilter"><pre class="geshifilter-cpp">T &amp;top<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>_impl._top==<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>
     throw std::<span style="color: #00eeff;">domain_error</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;empty stack&quot;</span><span style="color: #000000;">&#41;</span>;
   <span style="color: #0000ff;">return</span> _impl._buffer<span style="color: #000000;">&#91;</span>_impl._top<span style="color: #0000dd;">-1</span><span style="color: #000000;">&#93;</span>;
 <span style="color: #000000;">&#125;</span>
&nbsp;
 <span style="color: #0000ff;">void</span> pop<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   <span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span>_impl._top==<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>
     throw std::<span style="color: #00eeff;">domain_error</span><span style="color: #000000;">&#40;</span><span style="color: #666666;">&quot;empty stack&quot;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
   --_impl._top;
   _impl.<span style="color: #00eeff;">destroy</span><span style="color: #000000;">&#40;</span>_impl._buffer+_impl._top<span style="color: #000000;">&#41;</span>;
 <span style="color: #000000;">&#125;</span>
&nbsp;
 <span style="color: #0000ff;">bool</span> is_empty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
   <span style="color: #0000ff;">return</span> _impl._top==<span style="color: #0000dd;">0</span>;
 <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span>;</pre></div>
<p>( Źródło: stack_sutter.h)
</p>
<table id="attachments" class="sticky-enabled">
 <thead><tr><th>Załącznik</th><th>Wielkość</th> </tr></thead>
<tbody>
 <tr class="odd"><td><a href="http://smurf.mimuw.edu.pl/sites/default/files/Stack_sutter.h">Stack_sutter.h</a></td><td>1.81 KB</td> </tr>
</tbody>
</table>
  </div>
</div>
    
  </body>
</html>
